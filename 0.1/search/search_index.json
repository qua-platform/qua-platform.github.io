{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"About this Document","text":"<p>This document introduces and details the Quantum Orchestration Platform (QOP) programming environment. It is intended for quantum developers and researchers working with the QOP.</p>"},{"location":"#shields","title":"Shields","text":"<p>As more and more hardware products and QUA features are joining the QM arsenal, the documentation grows and branches out. Keeping our documentation under a single (virtual) roof means that some of the features documented here are only applicable for specific combinations of hardware and software.</p> <p>To keep track of these specifications we introduce the usage of <code>shields</code>.</p> <ul> <li>Blue shields specify the required hardware and QOP version.</li> <li>Green shields indicate the required minimal version of QUA.</li> <li>Orange shields indicate required hardware add-ons, such as Octave.</li> </ul> <p>For example, a feature that only works on an OPX+ with QOP version &gt;2.0, with the Octave add-on, and requires QUA version &gt;0.3.3 will have these shields:  </p>"},{"location":"community/","title":"Community","text":"<p>Placeholder until Discourse is not implemented.</p>"},{"location":"learn/","title":"Place for QM's learning resources","text":"<p>Here you can find didactic tutorials that would help you to become confident in using QM's hardware and software. Please select from the left menu topic you are interested in.</p>"},{"location":"qm-qua-sdk/","title":"QUA SDK","text":"<p>QUA language SDK to control a Quantum Computer</p>"},{"location":"qm-qua-sdk/CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog.</p>"},{"location":"qm-qua-sdk/CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"qm-qua-sdk/CHANGELOG/#deprecation","title":"Deprecation","text":"<ul> <li>The <code>hold_offset</code> entry in the config is deprecated and is replaced by a new <code>sticky</code> entry with an improved API</li> <li>Moved <code>_Program</code> path to <code>qm.program.program.Program</code>. Old path will be removed in 1.2.0</li> <li>Moved <code>QmJob</code> path to <code>qm.jobs.qm_job.QmJob</code>. Old path will be removed in 1.2.0</li> <li>Moved <code>QmPendingJob</code> path to <code>qm.jobs.pending_job.QmPendingJob</code>. Old path will be removed in 1.2.0</li> <li>Moved <code>QmQueue</code> path to <code>qm.jobs.job_queue.QmQueue</code>. Old path will be removed in 1.2.0</li> <li>Renamed <code>JobResults</code> into <code>StreamingResultFetcher</code>. Old name will be removed in 1.2.0</li> <li>Moved <code>StreamingResultFetcher</code> path to <code>qm.results.StreamingResultFetcher</code>. </li> <li><code>QmJob.id()</code> is deprecated, use <code>QmJob.id</code> instead, will be removed in 1.2.0</li> <li><code>QmJob</code> no longer has <code>manager</code> property </li> <li><code>QmPendingJob.id()</code> is deprecated, use <code>QmPendingJob.id</code> instead, will be removed in 1.2.0</li> <li><code>QuantumMachine</code> no longer has <code>manager</code> property</li> <li><code>QuantumMachine.peek</code> will be removed (was never implemented)</li> <li><code>QuantumMachine.poke</code> will be removed (was never implemented)</li> <li><code>IsInt()</code> function for qua variables is deprecated, use <code>is_int()</code> instead, will be removed in 1.2.0</li> <li><code>IsFixed()</code> function for qua variables is deprecated, use <code>is_fixed()</code> instead, will be removed in 1.2.0 </li> <li><code>IsBool()</code> function for qua variables is deprecated, use <code>is_bool()</code> instead, will be removed in 1.2.0 </li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#added","title":"Added","text":"<ul> <li>:guardswoman: Support <code>fast_frame_rotation</code>, a frame rotation with a cosine and sine rotation matrix rather than an angle.  </li> <li>Added support for floating point numbers in the <code>intermediate_frequency</code> field of <code>element</code> .</li> <li>Conditional <code>play</code> is extended to both the digital pulse if defined for operation. </li> <li>:guardswoman: Extended the sticky capability to include the digital pulse (optional)</li> <li>Added option to validate QUA config with protobuf instead of marshmallow. It is usually faster when working with large configs, to use this feature, set <code>validate_with_protobuf=True</code> while opening a quantum machine.</li> <li>Added type hinting for all <code>qua</code> functions and programs</li> <li>Added more ways of getting results from job results, added <code>job.result_handles[\"result_name\"]</code>.`</li> <li>Octave reset request command added to \"Octave manager\".</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Updated <code>play</code> docstrings to reflect that the changes to conditional digital pulse.</li> <li>Changed internal grpc infrastructure</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#102-2023-01-01","title":"1.0.2 - 2023-01-01","text":""},{"location":"qm-qua-sdk/CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Removed deprecated <code>math</code> library (use <code>Math</code> instead).</li> <li>Removed deprecated <code>qrun_</code> context manager (use <code>strict_timing_</code> instead).</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Better exception error printing.</li> <li>An api to add more information to error printing <code>activate_verbose_errors</code>.</li> <li>:guardswoman: Add support for OPD (Please check the OPD documentation for more details).</li> <li>:guardswoman: Added timestamps for play and measure statements.</li> <li>Support for numpy float128.</li> <li>Added the function <code>create_new_user_config()</code> under <code>qm.user_config</code> to create a configuration file with the QOP host IP &amp; Port to allow opening <code>QuantumMachinesManager()</code> without inputs.</li> <li>Added infrastructure for anonymous log sending (by default, no logs are sent). </li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Serializer - Added support for averaging on different axes.</li> <li>Serializer - Remove false message about lacking <code>play(ramp()...)</code> support.</li> <li>Serializer - Fixed the serialization when <code>.length()</code> is used.</li> <li>Serializer - Fixed cases in which the serializer did not deal with <code>adc_trace=true</code> properly. </li> <li>Serializer - The serializer does not report failed serialization when the only difference is the streams' order. </li> <li>Serializer - The serializer now correctly serialize the configuration when an element's name has a <code>'</code>.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#101-2022-09-22","title":"1.0.1 - 2022-09-22","text":""},{"location":"qm-qua-sdk/CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Octave - Added a flag to not close all the quantum machines in <code>calibrate_element</code>.</li> <li>Octave - The quantum machine doing the calibrations will be closed after the calibration is done.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#100-2022-09-04","title":"1.0.0 - 2022-09-04","text":"<ul> <li>Removed deprecated entries from the configuration schema</li> <li>Removed dependency in <code>qua</code> package</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>QuantumMachineManager - Fixed a bug where you could not connect using SSL on python version 3.10+</li> <li>Serializer - Fixed <code>declare_stream()</code> with <code>adc_true=True</code></li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Update betterproto version.</li> <li>OctaveConfig: changed <code>set_device_info</code> name to <code>add_device_info</code></li> <li>OctaveConfig: changed <code>add_opx_connections</code> name to <code>add_opx_octave_port_mapping</code></li> <li>OctaveConfig: changed <code>get_opx_octave_connections</code> name to <code>get_opx_octave_port_mapping</code></li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#added_2","title":"Added","text":"<ul> <li>:guardswoman: API to control Octave - an up-conversion and down-conversion module with built-in Local Oscillator (LO) sources.</li> <li>Support Numpy as input - Support numpy scalars and arrays as valid input. Numpy object can now be used interchangeably with python scalars and lists. This applies to all statements imported with <code>from qm.qua import *</code></li> <li>Serializer - Added support for legacy save</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#038-2022-07-10","title":"0.3.8 - 2022-07-10","text":""},{"location":"qm-qua-sdk/CHANGELOG/#fixed_2","title":"Fixed","text":"<ul> <li>Serializer - Fixed a bug which caused binary expression to fail</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>QuantumMachineManager will try to connect to 80 before 9510 if the user did not specify a port.</li> <li>QuantumMachineManager will give an error if no host is given and config file does not contain one.</li> <li>:guardswoman: QRun - Change qrun to strict_timing</li> <li>:guardswoman: Input Stream - Fixed API for input stream</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Serializer - add strict_timing to serializer</li> <li>Logger - Can now add an environment variable to disable the output to stdout </li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#037-2022-05-31","title":"0.3.7 - 2022-05-31","text":""},{"location":"qm-qua-sdk/CHANGELOG/#fixed_3","title":"Fixed","text":"<ul> <li>Serializer - Fixed a bug which caused the serializer to fail when given completely arbitrary integration weights</li> <li>Serializer - Fixed a bug which caused the serializer to fail when given a list of correction matrices</li> <li>Serializer - Added support for \"pass\" inside blocks (if, for, etc). \"pass\" inside \"else\" is not supported.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#added_4","title":"Added","text":"<ul> <li>:guardswoman: play - Add support for continue chirp feature</li> <li>:guardswoman: High Resolution Time Tagging - Add support for high resolution time-tagging measure process</li> <li>:guardswoman: Input Stream - Add support for streaming data from the computer to the program</li> <li>:guardswoman: OPD - Added missing OPD timetagging function</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>set_dc_offset - 2nd input for function was renamed from <code>input_reference</code> to <code>element_input</code></li> <li>QuantumMachineManager will try to connect to ports 9510 and 80 if the user did not specify a port.</li> <li>set_output_dc_offset_by_element - can now accept a tuple of ports and offsets</li> <li><code>signalPolarity</code> in the timetagging parameters (<code>outputPulseParameters</code> in configuration) now accept <code>Above</code> and <code>Below</code> instead of <code>Rising</code> and <code>Falling</code>, which better represent it's meaning.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#036-2022-01-23","title":"0.3.6 - 2022-01-23","text":""},{"location":"qm-qua-sdk/CHANGELOG/#added_5","title":"Added","text":"<ul> <li><code>signalPolarity</code> in the timetagging parameters (<code>outputPulseParameters</code> in configuration) now accept also <code>Rising</code> and <code>Falling</code>, which better represent it's meaning. </li> <li><code>derivativePolarity</code> in the timetagging parameters (<code>outputPulseParameters</code> in configuration) now accept also <code>Above</code> and <code>Below</code>, which better represent it's meaning. </li> <li>Add unsafe switch to <code>generate_qua_config</code> function</li> <li>Add library functions and *amp() in measure statement to <code>generate_qua_config</code> function</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>Better error for library functions as save source</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#035-2021-12-27","title":"0.3.5 - 2021-12-27","text":""},{"location":"qm-qua-sdk/CHANGELOG/#added_6","title":"Added","text":"<ul> <li>Raises an error when using Python logical operators </li> <li>Add elif statement to <code>generate_qua_config</code> function</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#changed_6","title":"Changed","text":"<ul> <li>Fix indentation problem on the end of for_each block in <code>generate_qua_config</code> function</li> <li>The <code>generate_qua_config</code> now compresses lists to make the resulting file smaller and more readable</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#034-2021-12-05","title":"0.3.4 - 2021-12-05","text":""},{"location":"qm-qua-sdk/CHANGELOG/#added_7","title":"Added","text":"<ul> <li>:guardswoman: Define multiple elements with shared oscillator.</li> <li>:guardswoman: Define an analog port with channel weights.</li> <li>Add measure and play features to <code>generate_qua_config</code> function</li> <li>format <code>generate_qua_config</code> function output</li> <li>improve <code>wait_for_all_values</code> execution time</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#033-2021-10-24","title":"0.3.3 - 2021-10-24","text":""},{"location":"qm-qua-sdk/CHANGELOG/#added_8","title":"Added","text":"<ul> <li>:guardswoman: Define an analog port with delay.</li> <li>:guardswoman: New <code>set_dc_offset()</code> statement that can change the DC offset of element input in real time.</li> <li>:guardswoman: New input stream capabilities facilitating data transfer from job to QUA.</li> <li>:guardswoman: New flag for stream processing fft operator to control output type.</li> <li> Add information about demod on a tuple.</li> <li> Added best practice guide.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#changed_7","title":"Changed","text":"<ul> <li>Validate that element has one and only one of the available input type QMQUA-26</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#032-2021-10-03","title":"0.3.2 - 2021-10-03","text":""},{"location":"qm-qua-sdk/CHANGELOG/#added_9","title":"Added","text":"<ul> <li>:guardswoman: QuantumMachinesManager health check shows errors and warnings.</li> <li>:guardswoman: Fetching job results indicates if there were execution errors.</li> <li>:guardswoman: Define an element with multiple input ports.</li> <li>:guardswoman: Stream processing demod now supports named argument <code>integrate</code>. If <code>False</code> is provided the demod will not sum the items, but only multiply by weights.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#changed_8","title":"Changed","text":"<ul> <li>Documentation structure and content.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#031-2021-09-13","title":"0.3.1 - 2021-09-13","text":""},{"location":"qm-qua-sdk/CHANGELOG/#fixed_4","title":"Fixed","text":"<ul> <li>Fixed serialization of IO values.</li> <li>Support running <code>QuantumMachinesManager</code> inside ipython or jupyter notebook.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#changed_9","title":"Changed","text":"<ul> <li>Removing deprecation notice from <code>with_timestamps</code> method on result streams.</li> <li>Setting <code>time_of_flight</code> or <code>smearing</code> are required if element has <code>outputs</code> and must not appear if it does not.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#030-2021-09-03","title":"0.3.0 - 2021-09-03","text":""},{"location":"qm-qua-sdk/CHANGELOG/#changed_10","title":"Changed","text":"<ul> <li>Support for result fetching of both versions of QM Server.</li> <li>Now the SDK supports all version of QM server.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#021-2021-09-01","title":"0.2.1 - 2021-09-01","text":""},{"location":"qm-qua-sdk/CHANGELOG/#changed_11","title":"Changed","text":"<ul> <li>Default port when creating new <code>QuantumMachineManager</code> is now <code>80</code> and user  config file is ignored.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#020-2021-08-31","title":"0.2.0 - 2021-08-31","text":""},{"location":"qm-qua-sdk/CHANGELOG/#added_10","title":"Added","text":"<ul> <li>The original QM SDK for QOP 2.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#010-2021-08-31","title":"0.1.0 - 2021-08-31","text":""},{"location":"qm-qua-sdk/CHANGELOG/#added_11","title":"Added","text":"<ul> <li>The original QM SDK for QOP 1.</li> </ul>"},{"location":"qm-qua-sdk/CHANGELOG/#legend","title":"Legend","text":"<ul> <li>:guardswoman: Features that are server specific and depend on capabilities and version</li> <li> Documentation only change</li> </ul>"},{"location":"qm-qua-sdk/docs/about_doc/","title":"About this Document","text":"<p>This document introduces and details the Quantum Orchestration Platform (QOP) programming environment. It is intended for quantum developers and researchers working with the QOP.</p>"},{"location":"qm-qua-sdk/docs/about_doc/#shields","title":"Shields","text":"<p>As more and more hardware products and QUA features are joining the QM arsenal, the documentation grows and branches out. Keeping our documentation under a single (virtual) roof means that some of the features documented here are only applicable for specific combinations of hardware and software.</p> <p>To keep track of these specifications we introduce the usage of <code>shields</code>.</p> <ul> <li>Blue shields specify the required hardware and QOP version.</li> <li>Green shields indicate the required minimal version of QUA.</li> <li>Orange shields indicate required hardware add-ons, such as Octave.</li> </ul> <p>For example, a feature that only works on an OPX+ with QOP version &gt;2.0, with the Octave add-on, and requires QUA version &gt;0.3.3 will have these shields:  </p>"},{"location":"qm-qua-sdk/docs/legal/","title":"Legal","text":"<pre><code>:maxdepth: 1\n\nlegal/terms_of_use\nlegal/privacy_policy\nlegal/cookie_policy\n</code></pre>"},{"location":"qm-qua-sdk/docs/support/","title":"Feedback and support","text":"<p>Join us in our QUA Discord server . You are welcome to ask questions, suggest features and share your experience!</p>"},{"location":"qm-qua-sdk/docs/support/#serializing-qua-programs","title":"Serializing QUA Programs","text":"<p>It is possible to serialize a QUA program and a config file using these commands:</p> <p>Note</p> <p>Make sure to always update your qua package before you serialize with <code>pip install -U qm-qua</code>.</p> <pre><code>from qm import generate_qua_script\n...\nwith program() as prog:\n...\n...\nqm = qmm.open_qm(config)\n...\nsourceFile = open('debug.py', 'w')\nprint(generate_qua_script(prog, config), file=sourceFile)\nsourceFile.close()\n</code></pre> <p>This code will create a file, <code>debug.py</code>, which is a standalone runnable serialized QUA program.</p>"},{"location":"qm-qua-sdk/docs/API_references/config_spec/","title":"Configuration Specification","text":"<p>The complete specification of the configuration schema can be found here.</p> <p>Note</p> <p>The config specification is in beta mode, and has the following issues:</p> <ol> <li>The type field does not represent the true type field, where this is relevant the type has been given in parentheses</li> <li>in <code>element</code> schema, only one of mixInputs/singleInput can be selected.</li> </ol>"},{"location":"qm-qua-sdk/docs/API_references/octave_config/","title":"QM Octave Configuration API","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/octave_config/#qm.octave.octave_config.QmOctaveConfig","title":"<code>qm.octave.octave_config.QmOctaveConfig</code>","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/octave_config/#qm.octave.octave_config.QmOctaveConfig.add_device_info","title":"<code>add_device_info</code>","text":"<p>Sets the octave info  - the IP address can be either the router ip or the actual ip depends on the installation configuration (cluster or standalone mode)</p> PARAMETER DESCRIPTION <code>name</code> <p>The octave name</p> <p> TYPE: <code>str</code> </p> <code>host</code> <p>The octave/QOP ip</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>The octave port</p> <p> TYPE: <code>int</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/octave_config/#qm.octave.octave_config.QmOctaveConfig.add_lo_loopback","title":"<code>add_lo_loopback</code>","text":"<p>Adds a loopback between an OctaveOutput and an OctaveLOSource</p> PARAMETER DESCRIPTION <code>octave_output_name</code> <p>octave name</p> <p> TYPE: <code>str</code> </p> <code>octave_output_port</code> <p>octave output port according to OctaveOutput</p> <p> TYPE: <code>OctaveOutput</code> </p> <code>octave_input_name</code> <p>octave name</p> <p> TYPE: <code>str</code> </p> <code>octave_input_port</code> <p>the LO input port according to OctaveLOSource</p> <p> TYPE: <code>OctaveLOSource</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/octave_config/#qm.octave.octave_config.QmOctaveConfig.add_opx_octave_port_mapping","title":"<code>add_opx_octave_port_mapping</code>","text":"<p>Adds port mapping which is different than the default one. should be in the form: <pre><code>{('con1', 1): ('oct1', 'I1'),\n('con1', 2): ('oct1', 'Q1'),\n('con1', 3): ('oct1', 'I2'),\n('con1', 4): ('oct1', 'Q2'),\n('con1', 5): ('oct1', 'I3'),\n('con1', 6): ('oct1', 'Q3'),\n('con1', 7): ('oct1', 'I4'),\n('con1', 8): ('oct1', 'Q4'),\n('con1', 9): ('oct1', 'I5'),\n('con1', 10): ('oct1', 'Q5')}\n</code></pre></p> PARAMETER DESCRIPTION <code>connections</code> <p>mapping of OPXs to octaves connections</p> <p> TYPE: <code>ConnectionMapping</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/octave_config/#qm.octave.octave_config.QmOctaveConfig.get_default_opx_octave_port_mapping","title":"<code>get_default_opx_octave_port_mapping</code>  <code>staticmethod</code>","text":"<p>Get the default opx-octave connections</p> PARAMETER DESCRIPTION <code>controller_name</code> <p>OPX name</p> <p> TYPE: <code>str</code> </p> <code>octave_name</code> <p>octave name</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ConnectionMapping</code> <p>Mapping of the given OPX to the given octave</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/octave_config/#qm.octave.octave_config.QmOctaveConfig.get_lo_loopbacks_by_octave","title":"<code>get_lo_loopbacks_by_octave</code>","text":"<p>Gets a list of all loop backs by octave name</p> PARAMETER DESCRIPTION <code>octave_name</code> <p>octave name to get LO loopback for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[OctaveLOSource, OctaveOutput]</code> <p>Dictionary with all the LO loopbacks</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/octave_config/#qm.octave.octave_config.QmOctaveConfig.get_opx_octave_port_mapping","title":"<code>get_opx_octave_port_mapping</code>","text":"<p>Get the configured opx-octave connections</p> RETURNS DESCRIPTION <code>ConnectionMapping</code> <p>Mapping of the configured OPXs to octaves connections</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/octave_config/#qm.octave.octave_config.QmOctaveConfig.set_calibration_db","title":"<code>set_calibration_db</code>","text":"<p>Sets the path to the calibration DB</p> PARAMETER DESCRIPTION <code>path</code> <p>path to the calibration database</p> <p> TYPE: <code>str</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/octave_config/#qm.octave.octave_config.QmOctaveConfig.set_opx_octave_mapping","title":"<code>set_opx_octave_mapping</code>","text":"<p>Sets the default port mapping for each <code>opx, octave</code> names</p> PARAMETER DESCRIPTION <code>mappings</code> <p>list of tuples of [OPX_name, octave_name] to connect</p> <p> TYPE: <code>List[Tuple[str, str]]</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/","title":"Quantum Machine API","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine","title":"<code>qm.QuantumMachine</code>","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine","title":"<code>QuantumMachine</code>","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.manager","title":"<code>manager</code>  <code>property</code>","text":"<p>Returns the Quantum Machines Manager</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.queue","title":"<code>queue: QmQueue</code>  <code>property</code>","text":"<p>Returns the queue for the Quantum Machine</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.close","title":"<code>close</code>","text":"<p>Closes the quantum machine.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the close request succeeded, raises an exception</p> <code>bool</code> <p>otherwise.</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.compile","title":"<code>compile</code>","text":"<p>Compiles a QUA program to be executed later. The returned <code>program_id</code> can then be directly added to the queue. For a detailed explanation see Precompile Jobs.</p> PARAMETER DESCRIPTION <code>program</code> <p>A QUA program</p> <p> TYPE: <code>Program</code> </p> <code>compiler_options</code> <p>Optional arguments for compilation</p> <p> TYPE: <code>Optional[CompilerOptionArguments]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>a program_id str</p> Example <pre><code>program_id = qm.compile(program)\npending_job = qm.queue.add_compiled(program_id)\njob = pending_job.wait_for_execution()\n</code></pre>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.execute","title":"<code>execute</code>","text":"<p>Executes a program and returns an job object to keep track of execution and get results.</p> Note <p>Calling execute will halt any currently running program and clear the current queue. If you want to add a job to the queue, use qm.queue.add()</p> PARAMETER DESCRIPTION <code>program</code> <p>A QUA <code>program()</code> object to execute</p> <p> TYPE: <code>Program</code> </p> <code>duration_limit</code> <p>This parameter is ignored as it is obsolete</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>data_limit</code> <p>This parameter is ignored as it is obsolete</p> <p> TYPE: <code>int</code> DEFAULT: <code>20000</code> </p> <code>force_execution</code> <p>This parameter is ignored as it is obsolete</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>dry_run</code> <p>This parameter is ignored as it is obsolete</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>QmJob</code> <p>A <code>QmJob</code> object (see QM Job API).</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.get_config","title":"<code>get_config</code>","text":"<p>Gets the current config of the qm</p> RETURNS DESCRIPTION <p>A dictionary with the qm's config</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.get_digital_buffer","title":"<code>get_digital_buffer</code>","text":"<p>Gets the buffer for digital input of the element</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to get the buffer for</p> <p> TYPE: <code>str</code> </p> <code>digital_input</code> <p>the digital input name as appears in the element's config</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>the buffer</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.get_digital_delay","title":"<code>get_digital_delay</code>","text":"<p>Gets the delay of the digital input of the element</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to get the delay for</p> <p> </p> <code>digital_input</code> <p>the digital input name as appears in the element's config</p> <p> </p> RETURNS DESCRIPTION <p>the delay</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.get_input_dc_offset_by_element","title":"<code>get_input_dc_offset_by_element</code>","text":"<p>Get the current DC offset of the OPX analog input channel associated with a element.</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to get the correction for</p> <p> </p> <code>output</code> <p>the output key name as appears in the element config under 'outputs'.</p> <p> </p> RETURNS DESCRIPTION <p>the offset, in normalized output units</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.get_io1_value","title":"<code>get_io1_value</code>","text":"<p>Gets the data stored in <code>IO1</code></p> <p>No inference is made on type.</p> RETURNS DESCRIPTION <p>A dictionary with data stored in <code>IO1</code>. (Data is in all</p> <p>three format: <code>int</code>, <code>float</code> and <code>bool</code>)</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.get_io2_value","title":"<code>get_io2_value</code>","text":"<p>Gets the data stored in <code>IO2</code></p> <p>No inference is made on type.</p> RETURNS DESCRIPTION <p>A dictionary with data from the second IO register. (Data is</p> <p>in all three format: <code>int</code>, <code>float</code> and <code>bool</code>)</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.get_io_values","title":"<code>get_io_values</code>","text":"<p>Gets the data stored in both <code>IO1</code> and <code>IO2</code></p> <p>No inference is made on type.</p> RETURNS DESCRIPTION <p>A list that contains dictionaries with data from the IO</p> <p>registers. (Data is in all three format: <code>int</code>, <code>float</code></p> <p>and <code>bool</code>)</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.get_output_dc_offset_by_element","title":"<code>get_output_dc_offset_by_element</code>","text":"<p>Get the current DC offset of the OPX analog output channel associated with a element.</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to get the correction for</p> <p> TYPE: <code>str</code> </p> <code>input</code> <p>the port name as appears in the element config. Options:</p> <p><code>'single'</code>     for an element with a single input</p> <p><code>'I'</code> or <code>'Q'</code>     for an element with mixer inputs</p> <p> </p> RETURNS DESCRIPTION <p>the offset, in normalized output units</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.get_running_job","title":"<code>get_running_job</code>","text":"<p>Gets the currently running job. Returns None if there isn't one.</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.get_smearing","title":"<code>get_smearing</code>","text":"<p>Gets the smearing associated with a measurement element.</p> <p>This is a broadening of the raw results acquisition window, to account for dispersive broadening in the measurement elements (readout resonators etc.) The acquisition window will be broadened by this amount on both sides.</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to get smearing for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>the smearing, in nesc.</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.get_time_of_flight","title":"<code>get_time_of_flight</code>","text":"<p>Gets the time of flight, associated with a measurement element.</p> <p>This is the amount of time between the beginning of a measurement pulse applied to element and the time that the data is available to the controller for demodulation or streaming.</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to get time of flight for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>the time of flight, in nsec</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.list_controllers","title":"<code>list_controllers</code>","text":"<p>Gets a list with the defined controllers in this qm</p> RETURNS DESCRIPTION <p>The names of the controllers configured in this qm</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.save_config_to_file","title":"<code>save_config_to_file</code>","text":"<p>Saves the qm current config to a file</p> PARAMETER DESCRIPTION <code>filename</code> <p>The name of the file where the config will be saved</p> <p> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.set_digital_buffer","title":"<code>set_digital_buffer</code>","text":"<p>Sets the buffer for digital input of the element</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to update buffer for</p> <p> TYPE: <code>str</code> </p> <code>digital_input</code> <p>the digital input name as appears in the element's config</p> <p> TYPE: <code>str</code> </p> <code>buffer</code> <p>the buffer value to set to, in nsec. Range: 0 to (255 - delay) / 2, in steps of 1</p> <p> TYPE: <code>int</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.set_digital_delay","title":"<code>set_digital_delay</code>","text":"<p>Sets the delay of the digital input of the element</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to update delay for</p> <p> TYPE: <code>str</code> </p> <code>digital_input</code> <p>the digital input name as appears in the element's config</p> <p> TYPE: <code>str</code> </p> <code>delay</code> <p>the delay value to set to, in nsec. Range: 0 to 255 - 2 * buffer, in steps of 1</p> <p> TYPE: <code>int</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.set_input_dc_offset_by_element","title":"<code>set_input_dc_offset_by_element</code>","text":"<p>set the current DC offset of the OPX analog input channel associated with a element.</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to update the correction for</p> <p> TYPE: <code>str</code> </p> <code>output</code> <p>the output key name as appears in the element config under 'outputs'.</p> <p> TYPE: <code>str</code> </p> <code>offset</code> <p>the dc value to set to, in normalized input units. Ranges from -0.5 to 0.5 - 2^-16 in steps of 2^-16.</p> <p> TYPE: <code>float</code> </p> Note <p>If the sum of the DC offset and the largest waveform data-point exceed the normalized unit range specified above, DAC output overflow will occur and the output will be corrupted.</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.set_intermediate_frequency","title":"<code>set_intermediate_frequency</code>","text":"<p>Sets the intermediate frequency of the element</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element whose intermediate frequency will be updated</p> <p> TYPE: <code>str</code> </p> <code>freq</code> <p>the intermediate frequency to set to the given element</p> <p> TYPE: <code>float</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.set_io1_value","title":"<code>set_io1_value</code>","text":"<p>Sets the value of <code>IO1</code>.</p> <p>This can be used later inside a QUA program as a QUA variable <code>IO1</code> without declaration. The type of QUA variable is inferred from the python type passed to <code>value_1</code>, according to the following rule:</p> <p>int -&gt; int float -&gt; fixed bool -&gt; bool</p> PARAMETER DESCRIPTION <code>value_1</code> <p>the value to be placed in <code>IO1</code></p> <p> TYPE: <code>Union[float, bool, int]</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.set_io2_value","title":"<code>set_io2_value</code>","text":"<p>Sets the value of <code>IO1</code>.</p> <p>This can be used later inside a QUA program as a QUA variable <code>IO2</code> without declaration. The type of QUA variable is inferred from the python type passed to <code>value_2</code>, according to the following rule:</p> <p>int -&gt; int float -&gt; fixed bool -&gt; bool</p> PARAMETER DESCRIPTION <code>value_2</code> <p>the value to be placed in <code>IO1</code></p> <p> TYPE: <code>Union[float, bool, int]</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.set_io_values","title":"<code>set_io_values</code>","text":"<p>Sets the values of <code>IO1</code> and <code>IO2</code></p> <p>This can be used later inside a QUA program as a QUA variable <code>IO1</code>, <code>IO2</code> without declaration. The type of QUA variable is inferred from the python type passed to <code>value_1</code>, <code>value_2</code>, according to the following rule:</p> <p>int -&gt; int float -&gt; fixed bool -&gt; bool</p> PARAMETER DESCRIPTION <code>value_1</code> <p>the value to be placed in <code>IO1</code></p> <p> TYPE: <code>Optional[Union[float, bool, int]]</code> </p> <code>value_2</code> <p>the value to be placed in <code>IO2</code></p> <p> TYPE: <code>Optional[Union[float, bool, int]]</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.set_mixer_correction","title":"<code>set_mixer_correction</code>","text":"<p>Sets the correction matrix for correcting gain and phase imbalances of an IQ mixer for the supplied intermediate frequency and LO frequency.</p> PARAMETER DESCRIPTION <code>mixer</code> <p>the name of the mixer, as defined in the configuration</p> <p> TYPE: <code>str</code> </p> <code>intermediate_frequency</code> <p>the intermediate frequency for which to apply the correction matrix</p> <p> TYPE: <code>Union[int | float]</code> </p> <code>lo_frequency</code> <p>the LO frequency for which to apply the correction matrix</p> <p> TYPE: <code>int</code> </p> <code>values</code> <p>tuple is of the form (v00, v01, v10, v11) where the matrix is | v00 v01 | | v10 v11 |</p> <p> TYPE: <code>tuple</code> </p> Note <p>Currently, the OPX does not support multiple mixer calibration entries. This function will accept IF &amp; LO frequencies written in the config file, and will update the correction matrix for all of the elements with the given mixer/frequencies combination when the program started.</p> <p>It\u2019s not recommended to use this method while a job is running. To change the calibration values for a running job, use job.set_element_correction</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.set_output_dc_offset_by_element","title":"<code>set_output_dc_offset_by_element</code>","text":"<p>Set the current DC offset of the OPX analog output channel associated with a element.</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to update the correction for</p> <p> TYPE: <code>str</code> </p> <code>input</code> <p>the input name as appears in the element config. Options:</p> <p><code>'single'</code>     for an element with a single input</p> <p><code>'I'</code> or <code>'Q'</code> or a tuple ('I', 'Q')     for an element with mixer inputs</p> <p> TYPE: <code>Union[str, Tuple[str, str], List[str]]</code> </p> <code>offset</code> <p>The dc value to set to, in normalized output units. Ranges from -0.5 to 0.5 - 2^-16 in steps of 2^-16.</p> <p> TYPE: <code>Union[float, Tuple[float, float], List[float]]</code> </p> <p>Examples:</p> <pre><code>qm.set_output_dc_offset_by_element('flux', 'single', 0.1)\nqm.set_output_dc_offset_by_element('qubit', 'I', -0.01)\nqm.set_output_dc_offset_by_element('qubit', ('I', 'Q'), (-0.01, 0.05))\n</code></pre> Note <p>If the sum of the DC offset and the largest waveform data-point exceed the normalized unit range specified above, DAC output overflow will occur and the output will be corrupted.</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.set_output_filter_by_element","title":"<code>set_output_filter_by_element</code>","text":"<p>Sets the intermediate frequency of the element</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element whose ports filters will be updated</p> <p> TYPE: <code>str</code> </p> <code>input</code> <p>the input name as appears in the element config. Options:</p> <p><code>'single'</code>     for an element with single input</p> <p><code>'I'</code> or <code>'Q'</code>     for an element with mixer inputs</p> <p> TYPE: <code>str</code> </p> <code>feedforward</code> <p>the values for the feedforward filter</p> <p> TYPE: <code>Union[List, numpy.ndarray, None]</code> </p> <code>feedback</code> <p>the values for the feedback filter</p> <p> TYPE: <code>Union[List, numpy.ndarray, None]</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_api/#qm.QuantumMachine.QuantumMachine.simulate","title":"<code>simulate</code>","text":"<p>Simulate the outputs of a deterministic QUA program.</p> <p>Equivalent to <code>execute()</code> with <code>simulate=SimulationConfig</code> (see example).</p> Note <p>A simulated job does not support calling QuantumMachine API functions.</p> <p>The following example shows a simple execution of the simulator, where the associated config object is omitted for brevity.</p> Example <pre><code>from qm.QuantumMachinesManager import QuantumMachinesManager\nfrom qm.qua import *\nfrom qm.simulate import SimulationConfig\nqmManager = QuantumMachinesManager()\nqm1 = qmManager.open_qm(config)\nwith program() as prog:\nplay('pulse1', 'element1')\njob = qm1.simulate(prog, SimulationConfig(duration=100))\n</code></pre> PARAMETER DESCRIPTION <code>program</code> <p>A QUA <code>program()</code> object to execute</p> <p> </p> <code>simulate</code> <p>A <code>SimulationConfig</code> configuration object</p> <p> TYPE: <code>SimulationConfig</code> </p> <code>kwargs</code> <p>additional parameteres to pass to execute</p> <p> </p> RETURNS DESCRIPTION <p>a <code>QmJob</code> object (see QM Job API).</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/","title":"QM Job API","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.base_job.QmBaseJob","title":"<code>qm.jobs.base_job.QmBaseJob</code>","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.base_job.QmBaseJob.id","title":"<code>id: str</code>  <code>property</code>","text":"<p>The id of the job</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.base_job.QmBaseJob.status","title":"<code>status: str</code>  <code>property</code>","text":"<p>Returns the status of the job, one of the following strings: \"unknown\", \"pending\", \"running\", \"completed\", \"canceled\", \"loading\", \"error\"</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.base_job.QmBaseJob.insert_input_stream","title":"<code>insert_input_stream</code>","text":"<p>Insert data to the input stream declared in the QUA program. The data is then ready to be read by the program using the advance input stream QUA statement.</p> <p>Multiple data entries can be inserted before the data is read by the program.</p> <p>See Input streams for more information.</p> <p>-- Available from QOP 2.0 --</p> PARAMETER DESCRIPTION <code>name</code> <p>The input stream name the data is to be inserted to.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>The data to be inserted. The data's size must match the size of the input stream.</p> <p> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.pending_job.QmPendingJob","title":"<code>qm.jobs.pending_job.QmPendingJob</code>","text":"<p>         Bases: <code>QmBaseJob</code></p> <p>A Class describing a job in the execution queue</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.pending_job.QmPendingJob.cancel","title":"<code>cancel</code>","text":"<p>Removes the job from the queue</p> RETURNS DESCRIPTION <code>bool</code> <p>true if the operation was successful</p> Example <pre><code>pending_job.cancel()\n</code></pre>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.pending_job.QmPendingJob.position_in_queue","title":"<code>position_in_queue</code>","text":"<p>Returns the current position of the job in the queue, returns -1 on if the job is not pending anymore</p> RETURNS DESCRIPTION <code>int</code> <p>The position in the queue</p> Example <pre><code>pending_job.position_in_queue()\n</code></pre>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.pending_job.QmPendingJob.wait_for_execution","title":"<code>wait_for_execution</code>","text":"<p>Waits for the job to be executed (start running) or until the timeout has elapsed. On zero and negative timeout, the job is checked once.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Timeout (in seconds) for this operation</p> <p> TYPE: <code>float</code> DEFAULT: <code>float('infinity')</code> </p> RAISES DESCRIPTION <code>TimeoutError</code> <p>When timeout is elapsed</p> RETURNS DESCRIPTION <code>QmJob</code> <p>The running <code>QmJob</code></p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.running_qm_job.RunningQmJob","title":"<code>qm.jobs.running_qm_job.RunningQmJob</code>","text":"<p>         Bases: <code>QmBaseJob</code></p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.running_qm_job.RunningQmJob.manager","title":"<code>manager</code>  <code>property</code>","text":"<p>The QM object where this job lives</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.running_qm_job.RunningQmJob.result_handles","title":"<code>result_handles: StreamingResultFetcher</code>  <code>property</code>","text":"<p>:type: qm._results.JobResults</p> RETURNS DESCRIPTION <code>StreamingResultFetcher</code> <p>The handles that this job generated</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.running_qm_job.RunningQmJob.execution_report","title":"<code>execution_report</code>","text":"<p>Get runtime errors report for this job. See Runtime errors.</p> RETURNS DESCRIPTION <code>ExecutionReport</code> <p>An object holding the errors that this job generated.</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.running_qm_job.RunningQmJob.get_element_correction","title":"<code>get_element_correction</code>","text":"<p>Gets the correction matrix for correcting gain and phase imbalances of an IQ mixer associated with a element.</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to update the correction for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Tuple[float, float, float, float]</code> <p>The current correction matrix</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.running_qm_job.RunningQmJob.halt","title":"<code>halt</code>","text":"<p>Halts the job on the opx</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.running_qm_job.RunningQmJob.is_paused","title":"<code>is_paused</code>","text":"RETURNS DESCRIPTION <code>bool</code> <p>Returns <code>True</code> if the job is in a paused state.</p> see also <p><code>resume()</code></p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.running_qm_job.RunningQmJob.resume","title":"<code>resume</code>","text":"<p>Resumes a program that was halted using the qm.qua._dsl.pause statement</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.running_qm_job.RunningQmJob.set_element_correction","title":"<code>set_element_correction</code>","text":"<p>Sets the correction matrix for correcting gain and phase imbalances of an IQ mixer associated with a element.</p> <p>Changes will only be done to the current job!</p> <p>Values will be rounded to an accuracy of \\(2^{-16}\\). Valid values for the correction values are between \\(-2\\) and \\((2 - 2^{-16})\\).</p> <p>Warning - the correction matrix can increase the output voltage which might result in an overflow.</p> PARAMETER DESCRIPTION <code>element</code> <p>the name of the element to update the correction for</p> <p> TYPE: <code>str</code> </p> <code>correction</code> <p>tuple is of the form (v00, v01, v10, v11) where the matrix is \\(\\begin{pmatrix} v_{00} &amp; v_{01} \\\\ v_{10} &amp; v_{11}\\end{pmatrix}\\)</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <code>Tuple[float, float, float, float]</code> <p>The correction matrix, after rounding to the OPX resolution.</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.simulated_job.SimulatedJob","title":"<code>qm.jobs.simulated_job.SimulatedJob</code>","text":"<p>         Bases: <code>RunningQmJob</code></p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.simulated_job.SimulatedJob.get_simulated_samples","title":"<code>get_simulated_samples</code>","text":"<p>Obtain the output samples of a QUA program simulation.</p> <p>Samples are returned in an object that holds the controllers in the current simulation, where each controller's name will be a property of this object. The value of each property of the returned value is an object with the following properties:</p> <p><code>analog</code>:</p> <pre><code>holds a dictionary with analog port names as keys and numpy array of samples as values.\n</code></pre> <p><code>digital</code>:</p> <pre><code>holds a dictionary with digital port names as keys and numpy array of samples as values.\n</code></pre> <p>It is also possible to directly plot the outputs using a built-in plot command.</p> Example <pre><code>samples = job.get_simulated_samples()\nanalog1 = samples.con1.analog[\"1\"]  # obtain analog port 1 of controller \"con1\"\ndigital9 = samples.con1.analog[\"9\"]  # obtain digital port 9 of controller \"con1\"\nsamples.con1.plot()  # Plots all active ports\nsamples.con1.plot(analog_ports=['1', '2'], digital_ports=['9'])  # Plots the given output ports\n</code></pre> <p>Note</p> <p>The simulated digital waveforms are delayed by 136ns relative to the real output of the OPX.</p> PARAMETER DESCRIPTION <code>include_analog</code> <p>Should we collect simulated analog samples</p> <p> DEFAULT: <code>True</code> </p> <code>include_digital</code> <p>Should we collect simulated digital samples</p> <p> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <p>The simulated samples of the job.</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.simulated_job.SimulatedJob.simulated_analog_waveforms","title":"<code>simulated_analog_waveforms</code>","text":"<p>Return the results of the simulation of elements and analog outputs.</p> <p>The returned dictionary has the following keys and entries:</p> <ul> <li> <p>elements: a dictionary containing the outputs with timestamps and values arranged by elements.</p> </li> <li> <p>**controllers: a dictionary containing the outputs with timestamps and values arranged by controllers.</p> <ul> <li> <p>ports: a dictionary containing the outputs with timestamps and values arranged by output ports.     for each element or output port, the entry is a list of dictionaries with the following information:</p> <ul> <li> <p>timestamp:     The time, in nsec, from the start of the program to the start of the pulse.</p> </li> <li> <p>samples:</p> <p>Output information, with <code>duration</code> given in nsec and <code>value</code> given normalized OPX output units.</p> </li> </ul> </li> </ul> </li> </ul> RETURNS DESCRIPTION <p>A dictionary containing output information for the analog outputs of the controller.</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.simulated_job.SimulatedJob.simulated_digital_waveforms","title":"<code>simulated_digital_waveforms</code>","text":"<p>Return the results of the simulation of digital outputs.</p> <ul> <li> <p>controllers: a dictionary containing the outputs with timestamps and values arranged by controllers.</p> <ul> <li> <p>ports: a dictionary containing the outputs with timestamps and values arranged by output ports.     for each element or output port, the entry is a list of dictionaries with the following information:</p> <ul> <li> <p>timestamp:     The time, in nsec, from the start of the program to the start of the pulse.</p> </li> <li> <p>samples:     A list containing the sequence of outputted values, with <code>duration</code> given in nsec     and <code>value</code> given as a boolean value.</p> </li> </ul> </li> </ul> </li> </ul> RETURNS DESCRIPTION <p>A dictionary containing output information for the analog outputs of the controller.</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_job_api/#qm.jobs.qm_job.QmJob","title":"<code>qm.jobs.qm_job.QmJob</code>","text":"<p>         Bases: <code>RunningQmJob</code></p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/","title":"Quantum Machine Manager API","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager","title":"<code>qm.QuantumMachinesManager.QuantumMachinesManager</code>","text":"PARAMETER DESCRIPTION <code>host</code> <p>Host where to find the QM orchestrator. If <code>None</code>, local settings are used</p> <p> TYPE: <code>string</code> DEFAULT: <code>None</code> </p> <code>port</code> <p>Port where to find the QM orchestrator. If None, local settings are used</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.clear_all_job_results","title":"<code>clear_all_job_results</code>","text":"<p>Deletes all data from all previous jobs</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.close","title":"<code>close</code>","text":"<p>Closes the Quantum machine manager</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.close_all_quantum_machines","title":"<code>close_all_quantum_machines</code>","text":"<p>Closes ALL open quantum machines</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.get_controllers","title":"<code>get_controllers</code>","text":"<p>Returns a list of all the controllers that are available</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.get_qm","title":"<code>get_qm</code>","text":"<p>Gets an open quantum machine object with the given machine id</p> PARAMETER DESCRIPTION <code>machine_id</code> <p>The id of the open quantum machine to get</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>QuantumMachine</code> <p>A quantum machine obj that can be used to execute programs</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.list_open_quantum_machines","title":"<code>list_open_quantum_machines</code>","text":"<p>Return a list of open quantum machines. (Returns only the ids, use <code>get_qm(...)</code> to get the machine object)</p> RETURNS DESCRIPTION <code>List[str]</code> <p>The ids list</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.open_qm","title":"<code>open_qm</code>","text":"<p>Opens a new quantum machine. A quantum machine can use multiple OPXes, and a single OPX can also be used by multiple quantum machines as long as they do not share the same physical resources (input/output ports) as defined in the config.</p> PARAMETER DESCRIPTION <code>config</code> <p>The config that will be used by the quantum machine</p> <p> </p> <code>close_other_machines</code> <p>When set to true (default) any open quantum machines will be closed. This simplifies the workflow, but does not enable opening more than one quantum machine.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>validate_with_protobuf</code> <p>Validates config with protobuf instead of marshmallow. It is usually faster when working with large configs. Defaults to False.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>QuantumMachine</code> <p>A quantum machine obj that can be used to execute programs</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.open_qm_from_file","title":"<code>open_qm_from_file</code>","text":"<p>Opens a new quantum machine with config taken from a file on the local file system</p> PARAMETER DESCRIPTION <code>filename</code> <p>The path to the file that contains the config</p> <p> TYPE: <code>str</code> </p> <code>close_other_machines</code> <p>Flag whether to close all other running machines</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>QuantumMachine</code> <p>A quantum machine obj that can be used to execute programs</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.perform_healthcheck","title":"<code>perform_healthcheck</code>","text":"<p>Perform a health check against the QM server.</p> PARAMETER DESCRIPTION <code>strict</code> <p>Will raise an exception if health check failed</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.reset_data_processing","title":"<code>reset_data_processing</code>","text":"<p>Stops current data processing for ALL running jobs</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.simulate","title":"<code>simulate</code>","text":"<p>Simulate the outputs of a deterministic QUA program.</p> <p>The following example shows a simple execution of the simulator, where the associated config object is omitted for brevity.</p> Example <pre><code>from qm.QuantumMachinesManager import QuantumMachinesManager\nfrom qm.qua import *\nfrom qm import SimulationConfig\nqmm = QuantumMachinesManager()\nwith program() as prog:\nplay('pulse1', 'qe1')\njob = qmm.simulate(config, prog, SimulationConfig(duration=100))\n</code></pre> PARAMETER DESCRIPTION <code>config</code> <p>A QM config</p> <p> </p> <code>program</code> <p>A QUA <code>program()</code> object to execute</p> <p> </p> <code>simulate</code> <p>A <code>SimulationConfig</code> configuration object</p> <p> </p> <code>kwargs</code> <p>additional parameters to pass to execute</p> <p> </p> RETURNS DESCRIPTION <code>SimulatedJob</code> <p>a <code>QmJob</code> object (see QM Job API).</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_manager_api/#qm.QuantumMachinesManager.QuantumMachinesManager.version","title":"<code>version</code>","text":"RETURNS DESCRIPTION <p>The SDK and QOP versions</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/","title":"QM Octave API","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave","title":"<code>qm.octave.qm_octave.QmOctave</code>","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave.calibrate_element","title":"<code>calibrate_element</code>","text":"<p>Calibrate the mixer associated with an element for the given LO &amp; IF frequencies.</p> PARAMETER DESCRIPTION <code>close_open_quantum_machines</code> <p>If true (default) all running QMs will be closed for the calibration. Otherwise, calibration might fail if there are not enough resources for the calibration</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>element</code> <p>The name of the element for calibration</p> <p> TYPE: <code>str</code> </p> <code>lo_if_frequencies_tuple_list</code> <p>a list of tuples that consists of all the (LO,IF) pairs for calibration</p> <p> TYPE: <code>list</code> DEFAULT: <code>None</code> </p> <code>save_to_db</code> <p>If true (default), The calibration parameters will be saved to the calibration database</p> <p> TYPE: <code>boolean</code> DEFAULT: <code>True</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave.get_clock","title":"<code>get_clock</code>","text":"<p>Gets the clock info for a given octave name</p> PARAMETER DESCRIPTION <code>octave_name</code> <p>The octave name to get clock for</p> <p> TYPE: <code>str</code> </p> <p>:returns ClockInfo: Info about the clock as an object</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave.load_lo_frequency_from_config","title":"<code>load_lo_frequency_from_config</code>","text":"<p>Loads into the octave synthesizers the LO frequencies specified for elements in the element list</p> PARAMETER DESCRIPTION <code>elements</code> <p>A list of elements to load LO frequencies from</p> <p> TYPE: <code>Union[List, str]</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave.set_clock","title":"<code>set_clock</code>","text":"<p>This function will set the octave clock type - internal, external or buffered. It can also set the clock frequency - 10, 100 or 1000 MHz</p> PARAMETER DESCRIPTION <code>octave_name</code> <p>The octave name to set clock for</p> <p> TYPE: <code>str</code> </p> <code>clock_type</code> <p>clock type according to ClockType</p> <p> TYPE: <code>ClockType</code> </p> <code>frequency</code> <p>Clock frequency according to ClockFrequency</p> <p> TYPE: <code>ClockFrequency</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave.set_downconversion","title":"<code>set_downconversion</code>","text":"<p>Sets the LO source and frequency for the downconverters. The LO source will be the one associated with the element's upconversion. If only the element is given, the LO source for downconversion will be the upconversion LO of the element.</p> PARAMETER DESCRIPTION <code>element</code> <p>The name of the element</p> <p> TYPE: <code>str</code> </p> <code>lo_source</code> <p>allowed LO source</p> <p> TYPE: <code>RFInputLOSource</code> DEFAULT: <code>None</code> </p> <code>lo_frequency</code> <p>The LO frequency</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>disable_warning</code> <p>Disable warnings about non- matching LO sources and elements if True</p> <p> TYPE: <code>Boolean</code> DEFAULT: <code>False</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave.set_lo_frequency","title":"<code>set_lo_frequency</code>","text":"<p>Sets the LO frequency of the synthesizer associated to element. Will not change the synthesizer if set_source = False</p> PARAMETER DESCRIPTION <code>element</code> <p>The name of the element</p> <p> TYPE: <code>str</code> </p> <code>lo_frequency</code> <p>The LO frequency</p> <p> TYPE: <code>float</code> </p> <code>set_source</code> <p>Set the synthesizer (True) or just update the client (False)</p> <p> TYPE: <code>Boolean</code> DEFAULT: <code>True</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave.set_lo_source","title":"<code>set_lo_source</code>","text":"<p>Associate  the given LO source with the given element. Always be sure the given LO source is internally connected to the element</p> PARAMETER DESCRIPTION <code>element</code> <p>The name of the element</p> <p> TYPE: <code>str</code> </p> <code>lo_port</code> <p>One of the allowed sources according the internal connectivity</p> <p> TYPE: <code>OctaveLOSource</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave.set_qua_element_octave_rf_in_port","title":"<code>set_qua_element_octave_rf_in_port</code>","text":"<p>Sets the octave downconversion port for the element.</p> PARAMETER DESCRIPTION <code>element</code> <p>The name of the element</p> <p> TYPE: <code>str</code> </p> <code>octave_name</code> <p>The octave name</p> <p> TYPE: <code>str</code> </p> <code>rf_input_index</code> <p>input index</p> <p> TYPE: <code>RFInputRFSource</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave.set_rf_output_gain","title":"<code>set_rf_output_gain</code>","text":"<p>Sets the RF output gain for the up-converter associated with the element. RF_gain is in steps of 0.5dB from -20 to +24 and is referring to the maximum OPX output power of 4dBm (=0.5V pk-pk) So for a value of -24 for example, an IF signal coming from the OPX at max power (4dBm) will be upconverted and come out of Octave at -20dBm</p> PARAMETER DESCRIPTION <code>element</code> <p>The name of the element</p> <p> TYPE: <code>str</code> </p> <code>gain_in_db</code> <p>The RF output gain in dB</p> <p> TYPE: <code>float</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave.set_rf_output_mode","title":"<code>set_rf_output_mode</code>","text":"<p>Configures the output switch of the upconverter associated to element. switch_mode can be either: 'on', 'off', 'trig_normal' or 'trig_inverse' When in 'trig_normal' mode a high trigger will turn the switch on and a low trigger will turn it off When in 'trig_inverse' mode a high trigger will turn the switch off and a low trigger will turn it on When in 'on' the switch will be permanently on. When in 'off' mode the switch will be permanently off.</p> PARAMETER DESCRIPTION <code>element</code> <p>The name of the element</p> <p> TYPE: <code>str</code> </p> <code>switch_mode</code> <p>switch mode according to the allowed states</p> <p> TYPE: <code>RFOutputMode</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/qm_octave/#qm.octave.qm_octave.QmOctave.update_external_lo_frequency","title":"<code>update_external_lo_frequency</code>","text":"<p>Updates the client on the external LO frequency (provided by the user) associated with element</p> PARAMETER DESCRIPTION <code>element</code> <p>The name of the element</p> <p> TYPE: <code>str</code> </p> <code>lo_frequency</code> <p>The LO frequency</p> <p> TYPE: <code>float</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/","title":"QM Job Queue API","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/#qm.jobs.job_queue.QmQueue","title":"<code>qm.jobs.job_queue.QmQueue</code>","text":"","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/#qm.jobs.job_queue.QmQueue.count","title":"<code>count</code>  <code>property</code>","text":"<p>Get the number of jobs currently on the queue</p> RETURNS DESCRIPTION <p>The number of jobs in the queue</p> Example <pre><code>qm.queue.count\n</code></pre>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/#qm.jobs.job_queue.QmQueue.pending_jobs","title":"<code>pending_jobs: List[QmPendingJob]</code>  <code>property</code>","text":"<p>Returns all currently pending jobs</p> RETURNS DESCRIPTION <code>List[QmPendingJob]</code> <p>A list of all of the currently pending jobs</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/#qm.jobs.job_queue.QmQueue.add","title":"<code>add</code>","text":"<p>Adds a QmJob to the queue. Programs in the queue will play as soon as possible.</p> PARAMETER DESCRIPTION <code>program</code> <p>A QUA program</p> <p> TYPE: <code>Program</code> </p> <code>compiler_options</code> <p>Optional arguments for compilation</p> <p> TYPE: <code>Optional[CompilerOptionArguments]</code> DEFAULT: <code>None</code> </p> Example <pre><code>qm.queue.add(program)  # adds at the end of the queue\nqm.queue.insert(program, position)  # adds at position\n</code></pre>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/#qm.jobs.job_queue.QmQueue.add_compiled","title":"<code>add_compiled</code>","text":"<p>Adds a compiled QUA program to the end of the queue, optionally overriding the values of analog waveforms defined in the program. Programs in the queue will play as soon as possible. For a detailed explanation see Precompile Jobs.</p> PARAMETER DESCRIPTION <code>program_id</code> <p>A QUA program ID returned from the compile function</p> <p> TYPE: <code>str</code> </p> <code>overrides</code> <p>Object containing Waveforms to run the program with</p> <p> DEFAULT: <code>None</code> </p> Example <pre><code>program_id = qm.compile(...)\npending_job = qm.queue.add_compiled(program_id, overrides={\n'waveforms': {\n'my_arbitrary_waveform': [0.1, 0.2, 0.3],\n'my_constant_waveform': 0.2\n}\n})\njob = pending_job.wait_for_execution()\n</code></pre>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/#qm.jobs.job_queue.QmQueue.add_to_start","title":"<code>add_to_start</code>","text":"<p>Adds a QMJob to the start of the queue. Programs in the queue will play as soon as possible.</p> PARAMETER DESCRIPTION <code>program</code> <p>A QUA program</p> <p> TYPE: <code>Program</code> </p> <code>compiler_options</code> <p>Optional arguments for compilation</p> <p> TYPE: <code>Optional[CompilerOptionArguments]</code> DEFAULT: <code>None</code> </p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/#qm.jobs.job_queue.QmQueue.clear","title":"<code>clear</code>","text":"<p>Empties the queue from all pending jobs</p> RETURNS DESCRIPTION <code>int</code> <p>The number of jobs removed</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/#qm.jobs.job_queue.QmQueue.get","title":"<code>get</code>","text":"<p>Get a pending job object by job_id</p> PARAMETER DESCRIPTION <code>job_id</code> <p>a QMJob id</p> <p> </p> RETURNS DESCRIPTION <code>QmPendingJob</code> <p>The pending job</p> Example <pre><code>qm.queue.get(job_id)\n</code></pre>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/#qm.jobs.job_queue.QmQueue.get_at","title":"<code>get_at</code>","text":"<p>Gets the pending job object at the given position in the queue</p> PARAMETER DESCRIPTION <code>position</code> <p>An integer position in queue</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>QmPendingJob</code> <p>The pending job</p> Example <pre><code>qm.queue.get(job_id)\n</code></pre>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/#qm.jobs.job_queue.QmQueue.remove_by_id","title":"<code>remove_by_id</code>","text":"<p>Removes the pending job object with a specific job id</p> PARAMETER DESCRIPTION <code>job_id</code> <p>a QMJob id</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The number of jobs removed</p> Example <pre><code>qm.queue.remove_by_id(job_id)\n</code></pre>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/queue/#qm.jobs.job_queue.QmQueue.remove_by_position","title":"<code>remove_by_position</code>","text":"<p>Remove the PendingQmJob object by position in queue</p> PARAMETER DESCRIPTION <code>position</code> <p>position in queue</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The number of jobs removed</p> Example <p><code>python qm.queue.remove_by_position(position)</code>python</p>","boost":1.5},{"location":"qm-qua-sdk/docs/API_references/results_api/","title":"Results API","text":""},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher","title":"<code>qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher</code>","text":""},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher.job_id","title":"<code>job_id: str</code>  <code>property</code>","text":"<p>The job id this result came from</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>The name of result this handle is connected to</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher.stream_metadata","title":"<code>stream_metadata: StreamMetadata</code>  <code>property</code>","text":"<p>Provides the StreamMetadata of this stream.</p> <p>Metadata currently includes the values and shapes of the automatically identified loops in the program.</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher.count_so_far","title":"<code>count_so_far</code>","text":"<p>also <code>len(handle)</code></p> RETURNS DESCRIPTION <code>int</code> <p>The number of values this result has so far</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher.fetch","title":"<code>fetch</code>","text":"<p>Fetch a result from the current result stream saved in server memory. The result stream is populated by the save() and save_all() statements. Note that if save_all() statements are used, calling this function twice with the same item index may give different results.</p> PARAMETER DESCRIPTION <code>item</code> <p>The index of the result in the saved results stream.</p> <p> TYPE: <code>Union[int, slice]</code> </p> <code>flat_struct</code> <p>results will have a flat structure - dimensions will be part of the shape and not of the type</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>numpy.array</code> <p>a single result if item is integer or multiple results if item is Python slice object.</p> Example <pre><code>res.fetch(0)         #return the item in the top position\nres.fetch(1)         #return the item in position number 2\nres.fetch(slice(1,6))# return items from position 1 to position 6 (exclusive)\n# same as res.fetch_all()[1:6]\n</code></pre>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher.fetch_all","title":"<code>fetch_all</code>","text":"<p>Fetch a result from the current result stream saved in server memory. The result stream is populated by the save() and save_all() statements. Note that if save_all() statements are used, calling this function twice may give different results.</p> PARAMETER DESCRIPTION <code>flat_struct</code> <p>results will have a flat structure - dimensions will be part of the shape and not of the type</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <p>all result of current result stream</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher.has_dataloss","title":"<code>has_dataloss</code>","text":"<p>if there was data loss during job execution</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher.save_to_store","title":"<code>save_to_store</code>","text":"<p>Saving to persistent store the NPY data of this result handle</p> PARAMETER DESCRIPTION <code>writer</code> <p>An optional writer to override the store defined in QuantumMachinesManager</p> <p> TYPE: <code>Optional[Union[BufferedWriter, BytesIO, str]]</code> DEFAULT: <code>None</code> </p> <code>flat_struct</code> <p>results will have a flat structure - dimensions will be part of the shape and not of the type</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The number of items saved</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher.wait_for_all_values","title":"<code>wait_for_all_values</code>","text":"<p>Wait until we know all values were processed for this named result</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Timeout for waiting in seconds</p> <p> TYPE: <code>float</code> DEFAULT: <code>float('infinity')</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if job finished successfully and False if job has</p> <code>bool</code> <p>closed before done</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher.wait_for_values","title":"<code>wait_for_values</code>","text":"<p>Wait until we know at least <code>count</code> values were processed for this named result</p> PARAMETER DESCRIPTION <code>count</code> <p>The number of items to wait for</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>timeout</code> <p>Timeout for waiting in seconds</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.streaming_result_fetcher.StreamingResultFetcher","title":"<code>qm.results.streaming_result_fetcher.StreamingResultFetcher</code>","text":"<p>Access to the results of a QmJob</p> <p>This object is created by calling QmJob.result_handles</p> <p>Assuming you have an instance of StreamingResultFetcher: <pre><code>    job_results: StreamingResultFetcher\n</code></pre> This object is iterable:</p> <pre><code>    for name, handle in job_results:\nprint(name)\n</code></pre> <p>Can detect if a name exists:</p> <pre><code>if \"somename\" in job_results:\nprint(\"somename exists!\")\nhandle = job_results.get(\"somename\")\n</code></pre>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.streaming_result_fetcher.StreamingResultFetcher.get","title":"<code>get</code>","text":"<p>Get a handle to a named result from stream_processing</p> PARAMETER DESCRIPTION <code>name</code> <p>The named result using in stream_processing</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Union[MultipleStreamingResultFetcher, SingleStreamingResultFetcher]]</code> <p>A handle object to the results <code>MultipleNamedJobResult</code> or <code>SingleNamedJobResult</code> or None if the named results in unknown</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.streaming_result_fetcher.StreamingResultFetcher.get_debug_data","title":"<code>get_debug_data</code>","text":"RETURNS DESCRIPTION <p>debugging data to report to QM</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.streaming_result_fetcher.StreamingResultFetcher.is_processing","title":"<code>is_processing</code>","text":"<p>Check if the job is still processing results</p> RETURNS DESCRIPTION <code>bool</code> <p>True if results are still being processed, False otherwise</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.streaming_result_fetcher.StreamingResultFetcher.save_to_store","title":"<code>save_to_store</code>","text":"<p>Save all results to store (file system by default) in a single NPZ file</p> PARAMETER DESCRIPTION <code>writer</code> <p>An optional writer to be used instead of the pre- populated store passed to qm.QuantumMachinesManager.QuantumMachinesManager</p> <p> TYPE: <code>Optional[Union[BufferedWriter, BytesIO, str]]</code> DEFAULT: <code>None</code> </p> <code>flat_struct</code> <p>results will have a flat structure - dimensions will be part of the shape and not of the type</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.streaming_result_fetcher.StreamingResultFetcher.wait_for_all_values","title":"<code>wait_for_all_values</code>","text":"<p>Wait until we know all values were processed for all named results</p> PARAMETER DESCRIPTION <code>timeout</code> <p>Timeout for waiting in seconds</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if all finished successfully, False if any result was closed before done</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.single_streaming_result_fetcher.SingleStreamingResultFetcher","title":"<code>qm.results.single_streaming_result_fetcher.SingleStreamingResultFetcher</code>","text":"<p>         Bases: <code>BaseStreamingResultFetcher</code></p> <p>A handle to a result of a pipeline terminating with <code>save</code></p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.single_streaming_result_fetcher.SingleStreamingResultFetcher.fetch","title":"<code>fetch</code>","text":"<p>Fetch a single result from the current result stream saved in server memory. The result stream is populated by the save().</p> PARAMETER DESCRIPTION <code>item</code> <p>ignored</p> <p> TYPE: <code>Union[int, slice]</code> </p> <code>flat_struct</code> <p>results will have a flat structure - dimensions will be part of the shape and not of the type</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <p>the current result</p> Example <pre><code>res.fetch() # return the item in the top position\n</code></pre>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.single_streaming_result_fetcher.SingleStreamingResultFetcher.fetch_all","title":"<code>fetch_all</code>","text":"<p>Fetch a result from the current result stream saved in server memory. The result stream is populated by the save() and save_all() statements. Note that if save_all() statements are used, calling this function twice may give different results.</p> PARAMETER DESCRIPTION <code>flat_struct</code> <p>results will have a flat structure - dimensions will be part of the shape and not of the type</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <p>all result of current result stream</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.multiple_streaming_result_fetcher.MultipleStreamingResultFetcher","title":"<code>qm.results.multiple_streaming_result_fetcher.MultipleStreamingResultFetcher</code>","text":"<p>         Bases: <code>BaseStreamingResultFetcher</code></p> <p>A handle to a result of a pipeline terminating with <code>save_all</code></p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.multiple_streaming_result_fetcher.MultipleStreamingResultFetcher.fetch","title":"<code>fetch</code>","text":"<p>Fetch a result from the current result stream saved in server memory. The result stream is populated by the save() and save_all() statements. Note that if save_all() statements are used, calling this function twice with the same item index may give different results.</p> PARAMETER DESCRIPTION <code>item</code> <p>The index of the result in the saved results stream.</p> <p> TYPE: <code>Union[int, slice]</code> </p> <code>flat_struct</code> <p>results will have a flat structure - dimensions will be part of the shape and not of the type</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>numpy.array</code> <p>a single result if item is integer or multiple results if item is Python slice object.</p> Example <pre><code>res.fetch(0)         # return the item in the top position\nres.fetch(1)         # return the item in position number 2\nres.fetch(slice(1,6))# return items from position 1 to position 6 (exclusive)\n# same as res.fetch_all()[1:6]\n</code></pre>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm.results.multiple_streaming_result_fetcher.MultipleStreamingResultFetcher.save_to_store","title":"<code>save_to_store</code>","text":"<p>Saving to persistent store the NPY data of this result handle</p> PARAMETER DESCRIPTION <code>writer</code> <p>An optional writer to override the store defined in QuantumMachinesManager</p> <p> TYPE: <code>Optional[Union[BufferedWriter, BytesIO, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The number of items saved</p>"},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm._results.JobResults","title":"<code>qm._results.JobResults = StreamingResultFetcher</code>  <code>module-attribute</code>","text":""},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm._results.MultipleNamedJobResult","title":"<code>qm._results.MultipleNamedJobResult = MultipleStreamingResultFetcher</code>  <code>module-attribute</code>","text":""},{"location":"qm-qua-sdk/docs/API_references/results_api/#qm._results.SingleNamedJobResult","title":"<code>qm._results.SingleNamedJobResult = SingleStreamingResultFetcher</code>  <code>module-attribute</code>","text":""},{"location":"qm-qua-sdk/docs/API_references/simulator_api/","title":"Simulator API","text":"","boost":2},{"location":"qm-qua-sdk/docs/API_references/simulator_api/#qm.simulate.interface.SimulationConfig","title":"<code>qm.simulate.interface.SimulationConfig</code>","text":"<p>Creates a configuration object to pass to qm.QuantumMachinesManager.QuantumMachinesManager.simulate</p> PARAMETER DESCRIPTION <code>duration</code> <p>The duration to run the simulation for, in clock cycles</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>include_analog_waveforms</code> <p>True to collect simulated analog waveform names</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>include_digital_waveforms</code> <p>True to collect simulated digital waveform names</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>simulation_interface</code> <p>Interface for to simulator. Currently supported interfaces - <code>None</code> - Zero inputs - qm.simulate.loopback.LoopbackInterface - Loopback output to input - qm.simulate.raw.RawInterface - Specify samples for inputs</p> <p> TYPE: <code>SimulatorInterface</code> DEFAULT: <code>None</code> </p> <code>controller_connections</code> <p>A list of connections between the controllers in the config</p> <p> TYPE: <code>List[ControllerConnection]</code> DEFAULT: <code>None</code> </p> <code>extraProcessingTimeoutInMs</code> <p>timeout in ms to wait for stream processing to finish. Default is -1, which is disables the timeout</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p>","boost":2},{"location":"qm-qua-sdk/docs/API_references/simulator_api/#qm.simulate.loopback.LoopbackInterface","title":"<code>qm.simulate.loopback.LoopbackInterface</code>","text":"<p>Creates a loopback interface for use in qm.simulate.interface.SimulationConfig. A loopback connects the output of the OPX into it's input. This can be defined directly using the ports or through the elements.</p> PARAMETER DESCRIPTION <code>connections</code> <p>List of tuples with loopback connections. Each tuple can be</p> <pre><code>1. Physical connection between ports:\n\n    ``(fromController: str, fromPort: int, toController: str, toPort: int)``\n\n2. Virtual connection between elements:\n\n    ``(fromQE: str, toQE: str, toQEInput: int)``\n</code></pre> <p> TYPE: <code>list</code> </p> <code>latency</code> <p>The latency between the OPX outputs and its input.</p> <p> TYPE: <code>int</code> DEFAULT: <code>24</code> </p> <code>noisePower</code> <p>How much noise to add to the input.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Example <pre><code>job = qmm.simulate(config, prog, SimulationConfig(\nduration=20000,\n# loopback from output 1 to input 2 of controller 1:\nsimulation_interface=LoopbackInterface([(\"con1\", 1, \"con1\", 2)])\n</code></pre>","boost":2},{"location":"qm-qua-sdk/docs/API_references/simulator_api/#qm.simulate.raw.RawInterface","title":"<code>qm.simulate.raw.RawInterface</code>","text":"<p>Creates a raw interface for use in qm.simulate.interface.SimulationConfig. A raw interface defines samples that will be inputted into the OPX inputs.</p> PARAMETER DESCRIPTION <code>connections</code> <p>List of tuples with the connection. Each tuple should be:</p> <pre><code>    ``(toController: str, toPort: int, toSamples: List[float])``\n</code></pre> <p> TYPE: <code>list</code> </p> <code>noisePower</code> <p>How much noise to add to the input.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> Example <pre><code>job = qmm.simulate(config, prog, SimulationConfig(\nduration=20000,\n# 500 ns of DC 0.2 V into con1 input 1\nsimulation_interface=RawInterface([(\"con1\", 1, [0.2]*500)])\n</code></pre>","boost":2},{"location":"qm-qua-sdk/docs/API_references/simulator_api/#qm.results.simulator_samples.SimulatorControllerSamples","title":"<code>qm.results.simulator_samples.SimulatorControllerSamples</code>","text":"","boost":2},{"location":"qm-qua-sdk/docs/API_references/simulator_api/#qm.results.simulator_samples.SimulatorControllerSamples.plot","title":"<code>plot</code>","text":"<p>Plots the simulated output of the OPX in the given ports. If no ports are given, all active ports are plotted.</p> PARAMETER DESCRIPTION <code>analog_ports</code> <p>Union[None, str, list[str]]</p> <p> DEFAULT: <code>None</code> </p> <code>digital_ports</code> <p>Union[None, str, list[str]]</p> <p> DEFAULT: <code>None</code> </p>","boost":2},{"location":"qm-qua-sdk/docs/API_references/qua/","title":"QUA Language API","text":"<p>The following is a reference of python functions and objects uses to build the QUA tree with.</p> <p>This tree that is built behind the scenes is a representational model of the program which is sent to the Quantum Machine, where it is being compiled and then executed on the OPX controller.</p> <p>This is a reference guide, so if you are a newcomer, please start with program.</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/cast/","title":"Casting","text":"","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/cast/#qm.qua.lib.Cast","title":"<code>qm.qua.lib.Cast</code>","text":"","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/cast/#qm.qua.lib.Cast.mul_fixed_by_int","title":"<code>mul_fixed_by_int</code>  <code>staticmethod</code>","text":"<p>Multiplies a fixed x by an int y, returning a fixed</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed</p> <p> </p> <code>y</code> <p>a QUA int</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed which equals x*y</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/cast/#qm.qua.lib.Cast.mul_int_by_fixed","title":"<code>mul_int_by_fixed</code>  <code>staticmethod</code>","text":"<p>Multiplies an int x by a fixed y, returning an int</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA integer</p> <p> </p> <code>y</code> <p>a QUA fixed</p> <p> </p> RETURNS DESCRIPTION <p>a QUA int which equals x*y</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/cast/#qm.qua.lib.Cast.to_bool","title":"<code>to_bool</code>  <code>staticmethod</code>","text":"<p>Casts a variable to bool. Supports int, fixed or bool</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA variable</p> <p> </p> RETURNS DESCRIPTION <p>a QUA bool</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/cast/#qm.qua.lib.Cast.to_fixed","title":"<code>to_fixed</code>  <code>staticmethod</code>","text":"<p>Casts a variable to fixed. Supports int, fixed or bool</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA variable</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/cast/#qm.qua.lib.Cast.to_int","title":"<code>to_int</code>  <code>staticmethod</code>","text":"<p>Casts a variable to int. Supports int, fixed or bool</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA variable</p> <p> </p> RETURNS DESCRIPTION <p>a QUA int</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/cast/#qm.qua.lib.Cast.unsafe_cast_bool","title":"<code>unsafe_cast_bool</code>  <code>staticmethod</code>","text":"<p>Treats the given input variable, bitwise, as a boolean. A boolean is determined by the right-most bit, so for a given integer, this is equivalent to a parity check.</p> <p>Supports int, fixed or bool.</p> Warning <p>Saving a boolean number which was unsafely cast from an integer/fixed will give the wrong value in python.</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA variable</p> <p> </p> RETURNS DESCRIPTION <p>a QUA bool</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/cast/#qm.qua.lib.Cast.unsafe_cast_fixed","title":"<code>unsafe_cast_fixed</code>  <code>staticmethod</code>","text":"<p>Treats the given input variable, bitwise, as a fixed point number. For a given integer, this is equivalent to multiplying by \\(2^{-28}\\)</p> <p>Supports int, fixed or bool.</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA variable</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/cast/#qm.qua.lib.Cast.unsafe_cast_int","title":"<code>unsafe_cast_int</code>  <code>staticmethod</code>","text":"<p>Treats the given input variable, bitwise, as an integer. For a given fixed point number, this is equivalent to multiplying by \\(2^{28}\\)</p> <p>Supports int, fixed or bool.</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA variable</p> <p> </p> RETURNS DESCRIPTION <p>a QUA int</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/","title":"QUA Statements Reference","text":"","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.program","title":"<code>qm.qua._dsl.program</code>","text":"<p>Create a QUA program.</p> <p>Used within a context manager, the program is defined in the code block below <code>with</code> statement.</p> <p>Statements in the code block below are played as soon as possible, meaning that an instruction will be played immediately unless it is dependent on a previous instruction. Additionally, commands output to the same elements will be played sequentially, and to different elements will be played in parallel. An exception is that pulses will be implicitly aligned at the end of each <code>for_</code> loop iteration.</p> <p>The generated <code>program_name</code> object is used as an input to the execute function of a qm.QuantumMachine object.</p> Example <pre><code>with program() as program_name:\nplay('pulse1', 'element1')\nwait('element1')\nqm.execute(program_name)\n</code></pre> <p>where <code>qm</code> is an instance of a qm.QuantumMachine</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.play","title":"<code>qm.qua._dsl.play</code>","text":"<p>Play a <code>pulse</code> based on an 'operation' defined in <code>element</code>.</p> <p>The pulse will be modified according to the properties of the element (see detailed explanation about pulse modifications below), and then played to the OPX output(s) defined to be connected to the input(s) of the element in the configuration.</p> PARAMETER DESCRIPTION <code>pulse</code> <p>The name of an <code>operation</code> to be performed, as defined in the element in the quantum machine configuration. Can also be a ramp function or be multiplied by an ramp.</p> <p> TYPE: <code>str</code> </p> <code>element</code> <p>The name of the element, as defined in the quantum machine configuration.</p> <p> TYPE: <code>str</code> </p> <code>duration</code> <p>The time to play this pulse in units of the clock cycle (4ns). If not provided, the default pulse duration will be used. It is possible to dynamically change the duration of both constant and arbitrary pulses. Arbitrary pulses can only be stretched, not compressed.</p> <p> TYPE: <code>Union[int,QUA variable of type int]</code> DEFAULT: <code>None</code> </p> <code>chirp</code> <p>Allows to perform piecewise linear sweep of the element\u2019s intermediate frequency in time. Input should be a tuple, with the 1st element being a list of rates and the second should be a string with the units. The units can be either: \u2018Hz/nsec\u2019, \u2019mHz/nsec\u2019, \u2019uHz/nsec\u2019, \u2019pHz/nsec\u2019 or \u2018GHz/sec\u2019, \u2019MHz/sec\u2019, \u2019KHz/sec\u2019, \u2019Hz/sec\u2019, \u2019mHz/sec\u2019.</p> <p> TYPE: <code>Union[list[int], str, int, str]</code> DEFAULT: <code>None</code> </p> <code>truncate</code> <p>Allows playing only part of the pulse, truncating the end. If provided, will play only up to the given time in units of the clock cycle (4ns).</p> <p> TYPE: <code>Union[int, QUA variable of type int]</code> DEFAULT: <code>None</code> </p> <code>condition</code> <p>Will play analog pulse only if the condition's value is true. Any digital pulses associated with the operation will always play.</p> <p> TYPE: <code>A logical expression to evaluate.</code> DEFAULT: <code>None</code> </p> <code>timestamp_stream</code> <p>(Supported from QOP 2.2) Adding a <code>timestamp_stream</code> argument will save the time at which the operation occurred to a stream. If the <code>timestamp_stream</code> is a string <code>label</code>, then the timestamp handle can be retrieved with <code>qm._results.JobResults.get</code> with the same <code>label</code>.</p> <p> TYPE: <code>Union[str, _ResultSource]</code> DEFAULT: <code>None</code> </p> Note <p>Arbitrary waveforms cannot be compressed and can only be expanded up to \\(2^{24}-1\\) clock cycles (67ms). Unexpected output will occur if a duration outside the range is given. See Dynamic pulse duration in the documentation for further information.</p> Note <p>When using chrip, it is possible to add a flag \"continue_chirp=True\" to the play command. When this flag is set, the internal oscillator will continue the chirp even after the play command had ended. See the `chirp documentation chirp documentation for more information.</p> Example <pre><code>with program() as prog:\nv1 = declare(fixed)\nassign(v1, 0.3)\nplay('pulse1', 'element1')\nplay('pulse1' * amp(0.5), 'element1')\nplay('pulse1' * amp(v1), 'element1')\nplay('pulse1' * amp(0.9, v1, -v1, 0.9), 'element_iq_pair')\ntime_stream = declare_stream()\n# Supported on QOP2.2+\nplay('pulse1', f'element1', duration=16, timestamp_stream='t1')\nplay('pulse1', f'element1', duration=16, timestamp_stream=time_stream)\nwith stream_processing():\nstream.buffer(10).save_all('t2')\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.pause","title":"<code>qm.qua._dsl.pause</code>","text":"<p>Pause the execution of the job until qm.jobs.running_qm_job.RunningQmJob.resume is called.</p> <p>The quantum machines freezes on its current output state.</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.update_frequency","title":"<code>qm.qua._dsl.update_frequency</code>","text":"<p>Dynamically update the frequency of the oscillator associated with a given <code>element</code>.</p> <p>This changes the frequency from the value defined in the quantum machine configuration.</p> <p>The behavior of the phase (continuous vs. coherent) is controlled by the <code>keep_phase</code> parameter and is discussed in the documentation.</p> PARAMETER DESCRIPTION <code>element</code> <p>The element associated with the oscillator whose frequency will be changed</p> <p> TYPE: <code>str</code> </p> <code>new_frequency</code> <p>The new frequency value to set in units set by <code>units</code> parameter. In steps of 1.</p> <p> TYPE: <code>int</code> </p> <code>units</code> <p>units of new frequency. Useful when sub-Hz precision is required. Allowed units are \"Hz\", \"mHz\", \"uHz\", \"nHz\", \"pHz\"</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Hz'</code> </p> <code>keep_phase</code> <p>Determine whether phase will be continuous through the change (if <code>True</code>) or it will be coherent, only the frequency will change (if <code>False</code>).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Example <pre><code>with program() as prog:\nupdate_frequency(\"q1\", 4e6) # will set the frequency to 4 MHz\n### Example for sub-Hz resolution\nupdate_frequency(\"q1\", 100.7) # will set the frequency to 100 Hz (due to casting to int)\nupdate_frequency(\"q1\", 100700, units='mHz') # will set the frequency to 100.7 Hz\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.update_correction","title":"<code>qm.qua._dsl.update_correction</code>","text":"<p>Updates the correction matrix used to overcome IQ imbalances of the IQ mixer for the next pulses played on the element</p> Note <p>Make sure to update the correction after you called <code>update_frequency</code></p> Note <p>Calling <code>update_correction</code> will also reset the frame of the oscillator associated with the element.</p> PARAMETER DESCRIPTION <code>element</code> <p>The element associated with the oscillator whose correction matrix will change</p> <p> TYPE: <code>str</code> </p> <code>c00</code> <p>The top left matrix element</p> <p> TYPE: <code>Union[float,QUA variable of type real]</code> </p> <code>c01</code> <p>The top right matrix element</p> <p> TYPE: <code>Union[float,QUA variable of type real]</code> </p> <code>c10</code> <p>The bottom left matrix element</p> <p> TYPE: <code>Union[float,QUA variable of type real]</code> </p> <code>c11</code> <p>The bottom right matrix element</p> <p> TYPE: <code>Union[float,QUA variable of type real]</code> </p> Example <pre><code>with program() as prog:\nupdate_correction(\"q1\", 1.0, 0.5, 0.5, 1.0)\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.set_dc_offset","title":"<code>qm.qua._dsl.set_dc_offset</code>","text":"<p>Set the DC offset of an element's input to the given value. This value will remain the DC offset until changed or until the Quantum Machine is closed. The offset value remains until it is changed or the Quantum Machine is closed.</p> <p>-- Available from QOP 2.0 --</p> PARAMETER DESCRIPTION <code>element</code> <p>The element to update its DC offset</p> <p> TYPE: <code>str</code> </p> <code>element_input</code> <p>The desired input of the element, can be 'single' for a 'singleInput' element or 'I' or 'Q' for a 'mixInputs' element</p> <p> TYPE: <code>str</code> </p> <code>offset</code> <p>The offset to set</p> <p> TYPE: <code>QuaNumberType</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.measure","title":"<code>qm.qua._dsl.measure</code>","text":"<p>Perform a measurement of <code>element</code> using <code>pulse</code> based on 'operation' as defined in the 'element'.</p> <p>An element for which a measurement is applied must have outputs defined in the configuration.</p> <p>A measurement consists of:</p> <ol> <li> <p>playing an operation to the element (identical to a :func:<code>play</code> statement)</p> </li> <li> <p>waiting for a duration of time defined as the <code>time_of_flight</code>    in the configuration of the element, and then sampling    the returning pulse.    The OPX input to be sampled is defined in the configuration of the element.</p> </li> <li> <p>Processing the aqcuired data according to a parameter defined in the measure command,     including Demodulation, Integration and Time Tagging.</p> </li> </ol> <p>For a more detailed description of the measurement operation, see Measure Statement Features</p> PARAMETER DESCRIPTION <code>pulse</code> <p>The name of an <code>operation</code> to be performed, as defined in the element in the quantum machine configuration. Pulse must have a <code>measurement</code> operation. Can also be multiplied by an amp.</p> <p> TYPE: <code>str</code> </p> <code>element</code> <p>name of the element, as defined in the quantum machine configuration. The element must have outputs.</p> <p> TYPE: <code>str</code> </p> <code>stream</code> <p>The stream variable which the raw ADC data will be saved and will appear in result analysis scope. You can receive the results with qm.QmJob.result_handles.get(\"name\"). A string name can also be used. In this case, the name of the result handle should be suffixed by <code>_input1</code> for data from analog input 1 and <code>_input2</code> for data from analog input 2.</p> <p>If <code>stream</code> is set to <code>None</code>, raw results will not be saved (note: must be explicitly set to <code>None</code>). The raw results will be saved as long as the digital pulse that is played with pulse is high.</p> <p>!!! Warning:</p> <pre><code>Streaming adc data without declaring the stream with `declare_stream(adc_trace=true)` might cause performance issues\n</code></pre> <p> TYPE: <code>Union[str, _ResultSource]</code> DEFAULT: <code>None</code> </p> <code>*outputs</code> <p>A parameter specifying the processing to be done on the ADC data, there are multiple options available, including demod(), integration() &amp; time_tagging().</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>()</code> </p> <code>timestamp_stream</code> <p>(Supported from QOP 2.2) Adding a <code>timestamp_stream</code> argument will save the time at which the operation occurred to a stream. If the <code>timestamp_stream</code> is a string <code>label</code>, then the timestamp handle can be retrieved with qm.results.streaming_result_fetcher.StreamingResultFetcher with the same <code>label</code>.</p> <p> TYPE: <code>Union[str, _ResultSource]</code> DEFAULT: <code>None</code> </p> Example <pre><code>with program() as prog:\nI = declare(fixed)\nQ = declare(fixed)\nadc_st = declare_stream(adc_trace=True)\n# measure by playing 'meas_pulse' to element 'resonator', do not save raw results.\n# demodulate data from \"out1\" port of 'resonator' using 'cos_weights' and store result in I, and also\n# demodulate data from \"out1\" port of 'resonator' using 'sin_weights' and store result in Q\nmeasure('meas_pulse', 'resonator', None, demod.full(\"cos_weights\", I, \"out1\"), demod.full(\"sin_weights\", Q, \"out1\"))\n# measure by playing 'meas_pulse' to element 'resonator', save raw results to `adc_st`\n# demodulate data from 'out1' port of 'resonator' using 'optimized_weights' and store result in I\nmeasure('meas_pulse', 'resonator', adc_st, demod.full(\"optimized_weights\", I, \"out1\"))\nwith stream_processing():\nadc_st.input1().save_all(\"raw_adc_stream\")\nfrom qm.QuantumMachinesManager import QuantumMachinesManager\nqm = QuantumMachinesManager().open_qm(config)\njob = qm.execute(prog)\n# ... we wait for the results to be ready...\njob.result_handles.wait_for_all_values()\n# raw results can be retrieved as follows (here job is a QmJob object:\nraw_I_handle = job.result_handles.get(\"raw_adc_stream\")\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.align","title":"<code>qm.qua._dsl.align</code>","text":"<p>Align several elements together.</p> <p>All the elements referenced in <code>elements</code> will wait for all the others to finish their currently running statement.</p> <p>If no arguments are given, the statement will align all the elements used in the program.</p> PARAMETER DESCRIPTION <code>*elements</code> <p>a single element, multiple elements, or none</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.reset_phase","title":"<code>qm.qua._dsl.reset_phase</code>","text":"<p>Resets the phase of the oscillator associated with <code>element</code>, setting the phase of the next pulse to absolute zero. This sets the phase of the currently playing intermediate frequency to the value it had at the beginning of the program (t=0).</p> Note <ul> <li>The phase will only be set to zero when the next play or align command is executed on the element.</li> <li>Reset phase will only reset the phase of the intermediate frequency (:math:<code>\\\\omega_{IF}</code>) currently in use.</li> </ul> PARAMETER DESCRIPTION <code>element</code> <p>an element</p> <p> TYPE: <code>str</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.ramp_to_zero","title":"<code>qm.qua._dsl.ramp_to_zero</code>","text":"<p>Starting from the last DC value, gradually lowers the DC to zero for <code>duration</code> *4nsec</p> <p>If <code>duration</code> is None, the duration is taken from the element's config</p> Warning <p>This feature does not protect from voltage jumps. Those can still occur, i.e. when the data sent to the analog output is outside the range -0.5 to \\(0.5 - 2^{16}\\) and thus will have an overflow.</p> PARAMETER DESCRIPTION <code>element</code> <p>element for ramp to zero</p> <p> TYPE: <code>str</code> </p> <code>duration</code> <p>time , <code>in multiples of 4nsec</code>. Range: [4, \\(2^{24}\\)] in steps of 1, or <code>None</code> to take value from config</p> <p> TYPE: <code>Union[int, None]</code> DEFAULT: <code>None</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.wait","title":"<code>qm.qua._dsl.wait</code>","text":"<p>Wait for the given duration on all provided elements without outputting anything. Duration is in units of the clock cycle (4ns)</p> PARAMETER DESCRIPTION <code>duration</code> <p>time to wait in units of the clock cycle (4ns). Range: [4, \\(2^{31}-1\\)] in steps of 1.</p> <p> TYPE: <code>Union[int,QUA variable of type int]</code> </p> <code>*elements</code> <p>elements to wait on</p> <p> TYPE: <code>Union[str,sequence of str]</code> DEFAULT: <code>()</code> </p> Warning <p>In case the value of this is outside the range above, unexpected results may occur.</p> Note <p>The purpose of the <code>wait</code> operation is to add latency. In most cases, the latency added will be exactly the same as that specified by the QUA variable or the literal used. However, in some cases an additional computational latency may be added. If the actual wait time has significance, such as in characterization experiments, the actual wait time should always be verified with a simulator.</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.wait_for_trigger","title":"<code>qm.qua._dsl.wait_for_trigger</code>","text":"<p>Wait for an external trigger on the provided element.</p> <p>During the command the OPX will play the pulse supplied by the <code>pulse_to_play</code> parameter</p> PARAMETER DESCRIPTION <code>element</code> <p>element to wait on</p> <p> TYPE: <code>str</code> </p> <code>pulse_to_play</code> <p>the name of the pulse to play on the element while waiting for the external trigger. Must be a constant pulse. Default None, no pulse will be played.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>trigger_element</code> <p>Available only with the OPD. The triggered element. See further details in the note.</p> <p> TYPE: <code>Union[str, tuple]</code> DEFAULT: <code>None</code> </p> <code>time_tag_target</code> <p>Available only with the OPD. The time at which the trigger arrived relative to the waiting start time. In ns.</p> <p> TYPE: <code>QUA variable of type int</code> DEFAULT: <code>None</code> </p> Warning <p>In the OPX - The maximum allowed voltage value for the digital trigger is 1.8V. A voltage higher than this can damage the controller.</p> <p>In the OPX+ and with the OPD - The maximum allowed voltage is 3.3V.</p> Note <p>Read more about triggering with the OPD here</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.save","title":"<code>qm.qua._dsl.save</code>","text":"<p>Stream a QUA variable, a QUA array cell, or a constant scalar. the variable is streamed and not immediately saved (see Stream processing). In case <code>result_or_tag</code> is a string, the data will be immediately saved to a result handle under the same name.</p> <p>If result variable is used, it can be used in results analysis scope see stream_processing if string tag is used, it will let you receive result with qm.QmJob.result_handles. The type of the variable determines the stream datatype, according to the following rule:</p> <ul> <li>int -&gt; int64</li> <li>fixed -&gt; float64</li> <li>bool -&gt; bool</li> </ul> Note <p>Saving arrays as arrays is not currently supported. Please use a QUA for loop to save an array.</p> Example <pre><code># basic save\na = declare(int, value=2)\nsave(a, \"a\")\n# fetching the results from python (job is a QmJob object):\na_handle = job.result_handles.get(\"a\")\na_data = a_handle.fetch_all()\n# save the third array cell\nvec = declare(fixed, value=[0.2, 0.3, 0.4, 0.5])\nsave(vec[2], \"ArrayCellSave\")\n# array iteration\ni = declare(int)\narray = declare(fixed, value=[x / 10 for x in range(30)])\nwith for_(i, 0, i &lt; 30, i + 1):\nsave(array[i], \"array\")\n# save a constant\nsave(3, \"a\")\n</code></pre> PARAMETER DESCRIPTION <code>var</code> <p>A QUA variable or a QUA array cell to save</p> <p> TYPE: <code>Union[QUA variable, a QUA array cell]</code> </p> <code>stream_or_tag</code> <p>A stream variable or string tag name to save the value under</p> <p> TYPE: <code>Union[str, stream variable]</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.frame_rotation","title":"<code>qm.qua._dsl.frame_rotation</code>","text":"<p>Shift the phase of the oscillator associated with an element by the given angle.</p> <p>This is typically used for virtual z-rotations.</p> Note <p>The fixed point format of QUA variables of type fixed is 4.28, meaning the phase must be between \\(-8\\) and \\(8-2^{28}\\). Otherwise the phase value will be invalid. It is therefore better to use <code>frame_rotation_2pi()</code> which avoids this issue.</p> Note <p>The phase is accumulated with a resolution of 16 bit. Therefore, N changes to the phase can result in a phase (and amplitude) inaccuracy of about :math:<code>N \\cdot 2^{-16}</code>. To null out this accumulated error, it is recommended to use <code>reset_frame(el)</code> from time to time.</p> PARAMETER DESCRIPTION <code>angle</code> <p>The angle to add to the current phase (in radians)</p> <p> TYPE: <code>Union[float, QUA variable of type fixed]</code> </p> <code>*elements</code> <p>a single element whose oscillator's phase will be shifted. multiple elements can be given, in which case all of their oscillators' phases will be shifted</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.frame_rotation_2pi","title":"<code>qm.qua._dsl.frame_rotation_2pi</code>","text":"<p>Shift the phase of the oscillator associated with an element by the given angle in units of 2pi radians.</p> <p>This is typically used for virtual z-rotations.</p> Note <p>Unlike the case of frame_rotation(), this method performs the 2-pi radian wrap around of the angle automatically.</p> Note <p>The phase is accumulated with a resolution of 16 bit. Therefore, N changes to the phase can result in a phase inaccuracy of about :math:<code>N \\cdot 2^{-16}</code>. To null out this accumulated error, it is recommended to use <code>reset_frame(el)</code> from time to time.</p> PARAMETER DESCRIPTION <code>angle</code> <p>The angle to add to the current phase (in \\(2\\pi\\) radians)</p> <p> TYPE: <code>Union[float,QUA variable of type real]</code> </p> <code>*elements</code> <p>a single element whose oscillator's phase will be shifted. multiple elements can be given, in which case all of their oscillators' phases will be shifted</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.reset_frame","title":"<code>qm.qua._dsl.reset_frame</code>","text":"<p>Resets the frame of the oscillator associated with an element to 0.</p> <p>Used to reset all of the frame updated made up to this statement.</p> PARAMETER DESCRIPTION <code>*elements</code> <p>a single element whose oscillator's phase will be reset. multiple elements can be given, in which case all of their oscillators' phases will be reset</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.assign","title":"<code>qm.qua._dsl.assign</code>","text":"<p>Set the value of a given QUA variable, or of a QUA array cell</p> PARAMETER DESCRIPTION <code>var</code> <p>A QUA variable or a QUA array cell for which to assign</p> <p> TYPE: <code>QUA variable</code> </p> <code>_exp</code> <p>An expression for which to set the variable</p> <p> TYPE: <code>QUA expression</code> </p> <p>Example::     <pre><code>with program() as prog:\nv1 = declare(fixed)\nassign(v1, 1.3)\nplay('pulse1' * amp(v1), 'element1')\n</code></pre></p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.switch_","title":"<code>qm.qua._dsl.switch_</code>","text":"<p>Part of the switch-case flow control statement in QUA.</p> <p>To be used with a context manager.</p> <p>The code block inside should be composed of only <code>case_()</code> and <code>default_()</code> statements, and there should be at least one of them.</p> <p>The expression given in the <code>switch_()</code> statement will be evaluated and compared to each of the values in the <code>case_()</code> statements. The QUA code block following the <code>case_()</code> statement which evaluated to true will be executed. If none of the statements evaluated to true, the QUA code block following the <code>default_()</code> statement (if given) will be executed.</p> PARAMETER DESCRIPTION <code>expression</code> <p>An expression to evaluate</p> <p> TYPE: <code>QuaExpressionType</code> </p> <code>unsafe</code> <p>If set to True, then switch-case would be more efficient and would produce less gaps. However, if an input which does not match a case is given, unexpected behavior will occur. Cannot be used with the <code>default_()</code> statement. Default is false, use with care.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Example <pre><code>x=declare(int)\nwith switch_(x):\nwith case_(1):\nplay('first_pulse', 'element')\nwith case_(2):\nplay('second_pulse', 'element')\nwith case_(3):\nplay('third_pulse', 'element')\nwith default_():\nplay('other_pulse', 'element')\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.case_","title":"<code>qm.qua._dsl.case_</code>","text":"<p>Part of the switch-case flow control statement in QUA.</p> <p>To be used with a context manager.</p> <p>Must be inside a <code>switch_()</code> statement.</p> <p>The expression given in the <code>switch_()</code> statement will be evaluated and compared to each of the values in the <code>case_()</code> statements. The QUA code block following the <code>case_()</code> statement which evaluated to true will be executed. If none of the statements evaluated to true, the QUA code block following the <code>default_()</code> statement (if given) will be executed.</p> PARAMETER DESCRIPTION <code>case_exp</code> <p>A value (or expression) to compare to the expression in the <code>switch_()</code> statement</p> <p> TYPE: <code>TypeOrExpression[AllPyTypes]</code> </p> Example <pre><code>x=declare(int)\nwith switch_(x):\nwith case_(1):\nplay('first_pulse', 'element')\nwith case_(2):\nplay('second_pulse', 'element')\nwith case_(3):\nplay('third_pulse', 'element')\nwith default_():\nplay('other_pulse', 'element')\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.default_","title":"<code>qm.qua._dsl.default_</code>","text":"<p>Part of the switch-case flow control statement in QUA.</p> <p>To be used with a context manager.</p> <p>Must be inside a <code>switch_()</code> statement, and there can only be one <code>default_()</code> statement.</p> <p>The expression given in the <code>switch_()</code> statement will be evaluated and compared to each of the values in the <code>case_()</code> statements. The QUA code block following the <code>case_()</code> statement which evaulated to true will be executed. If none of the statements evaluated to true, the QUA code block following the <code>default_()</code> statement (if given) will be executed.</p> Example <pre><code>x=declare(int)\nwith switch_(x):\nwith case_(1):\nplay('first_pulse', 'element')\nwith case_(2):\nplay('second_pulse', 'element')\nwith case_(3):\nplay('third_pulse', 'element')\nwith default_():\nplay('other_pulse', 'element')\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.if_","title":"<code>qm.qua._dsl.if_</code>","text":"<p>If flow control statement in QUA.</p> <p>To be used with a context manager.</p> <p>The QUA code block following the statement will be executed only if the expression given evaluates to true.</p> PARAMETER DESCRIPTION <code>expression</code> <p>A boolean expression to evaluate</p> <p> TYPE: <code>QuaExpressionType</code> </p> Example <pre><code>x=declare(int)\nwith if_(x&gt;0):\nplay('pulse', 'element')\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.elif_","title":"<code>qm.qua._dsl.elif_</code>","text":"<p>Else-If flow control statement in QUA.</p> <p>To be used with a context manager.</p> <p>Must appear after an <code>if_()</code> statement.</p> <p>The QUA code block following the statement will be executed only if the expressions in the preceding <code>if_()</code> and <code>elif_()</code> statements evaluates to false and if the expression given in this <code>elif_()</code> evaluates to true.</p> PARAMETER DESCRIPTION <code>expression</code> <p>A boolean expression to evaluate</p> <p> TYPE: <code>QuaExpressionType</code> </p> Example <pre><code>x=declare(int)\nwith if_(x&gt;2):\nplay('pulse', 'element')\nwith elif_(x&gt;-2):\nplay('other_pulse', 'element')\nwith else_():\nplay('third_pulse', 'element')\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.else_","title":"<code>qm.qua._dsl.else_</code>","text":"<p>Else flow control statement in QUA.</p> <p>To be used with a context manager.</p> <p>Must appear after an <code>if_()</code> statement.</p> <p>The QUA code block following the statement will be executed only if the expressions in the preceding <code>if_()</code> and <code>elif_()</code> statements evaluates to false.</p> Example <pre><code>x=declare(int)\nwith if_(x&gt;0):\nplay('pulse', 'element')\nwith else_():\nplay('other_pulse', 'element')\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.for_each_","title":"<code>qm.qua._dsl.for_each_</code>","text":"<p>Flow control: Iterate over array elements in QUA.</p> <p>It is possible to either loop over one variable, or over a tuple of variables, similar to the <code>zip</code> style iteration in python.</p> <p>To be used with a context manager.</p> PARAMETER DESCRIPTION <code>var</code> <p>The iteration variable</p> <p> TYPE: <code>Union[QUA variable, tuple of QUA variables]</code> </p> <code>values</code> <p>A list of values to iterate over or a QUA array.</p> <p> TYPE: <code>Union[list of literals, tuple of lists of literals, QUA array, tuple of QUA arrays]</code> </p> Example <pre><code>x=declare(fixed)\ny=declare(fixed)\nwith for_each_(x, [0.1, 0.4, 0.6]):\nplay('pulse' * amp(x), 'element')\nwith for_each_((x, y), ([0.1, 0.4, 0.6], [0.3, -0.2, 0.1])):\nplay('pulse1' * amp(x), 'element')\nplay('pulse2' * amp(y), 'element')\n</code></pre> Warning <p>This behavior is not exactly consistent with python <code>zip</code>. Instead of sending a list of tuple as values, the function expects a tuple of lists. The first list containing the values for the first variable, and so on.</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.while_","title":"<code>qm.qua._dsl.while_</code>","text":"<p>While loop flow control statement in QUA.</p> <p>To be used with a context manager.</p> PARAMETER DESCRIPTION <code>cond</code> <p>an expression which evaluates to a boolean variable, determines if to continue to next loop iteration</p> <p> TYPE: <code>QUA expression</code> DEFAULT: <code>None</code> </p> Example <pre><code>x = declare(fixed)\nassign(x, 0)\nwith while_(x&lt;=30):\nplay('pulse', 'element')\nassign(x, x+1)\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.for_","title":"<code>qm.qua._dsl.for_</code>","text":"<p>For loop flow control statement in QUA.</p> <p>To be used with a context manager.</p> PARAMETER DESCRIPTION <code>var</code> <p>QUA variable used as iteration variable</p> <p> TYPE: <code>QUA variable</code> DEFAULT: <code>None</code> </p> <code>init</code> <p>an expression which sets the initial value of the iteration variable</p> <p> TYPE: <code>QUA expression</code> DEFAULT: <code>None</code> </p> <code>cond</code> <p>an expression which evaluates to a boolean variable, determines if to continue to next loop iteration</p> <p> TYPE: <code>QUA expression</code> DEFAULT: <code>None</code> </p> <code>update</code> <p>an expression to add to <code>var</code> with each loop iteration</p> <p> TYPE: <code>QUA expression</code> DEFAULT: <code>None</code> </p> Example <pre><code>x = declare(fixed)\nwith for_(var=x, init=0, cond=x&lt;=1, update=x+0.1):\nplay('pulse', 'element')\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.infinite_loop_","title":"<code>qm.qua._dsl.infinite_loop_</code>","text":"<p>Infinite loop flow control statement in QUA.</p> <p>To be used with a context manager.</p> <p>Optimized for zero latency between iterations, provided that no more than a single element appears in the loop.</p> Note <p>In case multiple elements need to be used in an infinite loop, it is possible to add several loops in parallel (see example). Two infinite loops cannot share an element nor can they share variables.</p> Example <pre><code>with infinite_loop_():\nplay('pulse1', 'element1')\nwith infinite_loop_():\nplay('pulse2', 'element2')\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.L","title":"<code>qm.qua._dsl.L</code>","text":"<p>Creates an expression with a literal value</p> PARAMETER DESCRIPTION <code>value</code> <p>int, float or bool to wrap in a literal expression</p> <p> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.DeclarationType","title":"<code>qm.qua._dsl.DeclarationType</code>","text":"","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.declare","title":"<code>qm.qua._dsl.declare</code>","text":"<p>Declare a single QUA variable or QUA vector to be used in subsequent expressions and assignments.</p> <p>Declaration is performed by declaring a python variable with the return value of this function.</p> PARAMETER DESCRIPTION <code>t</code> <p>The type of QUA variable. Possible values: <code>int</code>, <code>fixed</code>, <code>bool</code>, where:</p> <p><code>int</code>     a signed 32-bit number <code>fixed</code>     a signed 4.28 fixed point number <code>bool</code>     either <code>True</code> or <code>False</code></p> <p> TYPE: <code>VariableDeclarationType</code> </p> <code>value</code> <p>An initial value for the variable or a list of initial values for a vector</p> <p> TYPE: <code>Optional[OneOrMore[AllPyTypes]]</code> DEFAULT: <code>None</code> </p> <code>size</code> <p>If declaring a vector without explicitly specifying a value, this parameter is used to specify the length of the array</p> <p> TYPE: <code>Optional[PyNumberType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>QuaVariableType</code> <p>The variable or vector</p> Warning <p>some QUA statements accept a variable with a valid range smaller than the full size of the generic QUA variable. For example, <code>amp()</code> accepts numbers between -2 and 2. In case the value stored in the variable is larger than the valid input range, unexpected results may occur.</p> Example <pre><code>a = declare(fixed, value=0.3)\nplay('pulse' * amp(a), 'element')\narray1 = declare(int, value=[1, 2, 3])\narray2 = declare(fixed, size=5)\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.declare_input_stream","title":"<code>qm.qua._dsl.declare_input_stream</code>","text":"<p>Declare a QUA variable or a QUA vector to be used as an input stream from the job to the QUA program.</p> <p>Declaration is performed by declaring a python variable with the return value of this function.</p> <p>Declaration is similar to the normal QUA variable declaration. See declare for available parameters.</p> <p>See Input streams for more information.</p> <p>-- Available from QOP 2.0 --</p> Example <pre><code>tau = declare_input_stream(int)\n...\nadvance_input_stream(tau)\nplay('operation', 'element', duration=tau)\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.advance_input_stream","title":"<code>qm.qua._dsl.advance_input_stream</code>","text":"<p>Advances the input stream pointer to the next available variable/vector.</p> <p>If there is no new data waiting in the stream, this command will wait until it is available.</p> <p>The variable/vector can then be used as a normal QUA variable.</p> <p>See Input streams for more information.</p> <p>-- Available from QOP 2.0 --</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.declare_stream","title":"<code>qm.qua._dsl.declare_stream</code>","text":"<p>Declare a QUA output stream to be used in subsequent statements To retrieve the result - it must be saved in the stream processing block.</p> <p>Declaration is performed by declaring a python variable with the return value of this function.</p> Note <p>if the stream is an ADC trace, declaring it with the syntax <code>declare_stream(adc_trace=True)</code> will add a buffer of length corresponding to the pulse length.</p> RETURNS DESCRIPTION <code>A</code> <p>class:<code>_ResultSource</code> object to be used in</p> <p> TYPE: <code>_ResultSource</code> </p> <code>_ResultSource</code> <p><code>stream_processing</code></p> Example <pre><code>a = declare_stream()\nmeasure('pulse', 'element', a)\nwith stream_processing():\na.save(\"tag\")\na.save_all(\"another tag\")\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.amp","title":"<code>qm.qua._dsl.amp</code>","text":"<p>To be used only within a play or measure command, as a multiplication to the <code>operation</code>.</p> <p>It is possible to scale the pulse's amplitude dynamically by using the following syntax:</p> <p><code>play('pulse_name' * amp(v), 'element')</code></p> <p>where <code>v</code> is QUA variable of type fixed. Range of v: -2 to \\(2 - 2^{-16}\\) in steps of \\(2^{-16}\\).</p> <p>Moreover, if the pulse is intended to a mixedInputs element and thus is defined with two waveforms, the two waveforms, described as a column vector, can be multiplied by a matrix:</p> <p><code>play('pulse_name' * amp(v_00, v_01, v_10, v_11), 'element'),</code></p> <p>where <code>v_ij</code>, i,j={0,1}, are QUA variables of type fixed. Note that <code>v_ij</code> should satisfy -2 &lt;= <code>v_ij</code> &lt;= \\(2 - 2{-16}\\).</p> <p>Note that scaling in this manner, rather than in the configuration, might result in a computational overhead. See QUA Best Practice Guide for more information.</p> PARAMETER DESCRIPTION <code>v1</code> <p>If only this variable is given, it is the scaler amplitude factor which multiples the <code>pulse</code> associated with the <code>operation</code>. If all variables are given, then it is the first element in the amplitude matrix which multiples the <code>pulse</code> associated with the <code>operation</code>.</p> <p> TYPE: <code>QuaNumberType</code> </p> <code>v2</code> <p>The second element in the amplitude matrix which multiples the <code>pulse</code> associated with the <code>operation</code>.</p> <p> TYPE: <code>Optional[QuaNumberType]</code> DEFAULT: <code>None</code> </p> <code>v3</code> <p>The third element in the amplitude matrix which multiples the <code>pulse</code> associated with the <code>operation</code>.</p> <p> TYPE: <code>Optional[QuaNumberType]</code> DEFAULT: <code>None</code> </p> <code>v4</code> <p>The forth element in the amplitude matrix which multiples the <code>pulse</code> associated with the <code>operation</code>.</p> <p> TYPE: <code>Optional[QuaNumberType]</code> DEFAULT: <code>None</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.ramp","title":"<code>qm.qua._dsl.ramp</code>","text":"<p>To be used only within a <code>play</code> command, instead of the <code>operation</code>.</p> <p>It\u2019s possible to generate a voltage ramp by using the <code>ramp(slope)</code> command. The slope argument is specified in units of <code>V/ns</code>. Usage of this feature is as follows:</p> <p><code>play(ramp(0.0001),'qe1',duration=1000)</code></p> <p>.. note:     The pulse duration must be specified if the ramp feature is used.</p> PARAMETER DESCRIPTION <code>v</code> <p>The slope in units of <code>V/ns</code></p> <p> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.strict_timing_","title":"<code>qm.qua._dsl.strict_timing_</code>","text":"<p>Any QUA command written within the strict timing block will be required to to play without gaps.</p> <p>See the documentation for further information and examples.</p> <p>To be used with a context manager.</p> <p>-- Available from QOP 2.0 --</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.RealAccumulationMethod","title":"<code>qm.qua._dsl.RealAccumulationMethod</code>","text":"<p>A base class for specifying the integration and demodulation processes in the measure statement. These are the options which can be used inside the measure command as part of the <code>demod</code> and <code>integration</code> processes.</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.RealAccumulationMethod.accumulated","title":"<code>accumulated</code>","text":"<p>Same as <code>sliced()</code>, however the accumulated result of the demodulation/integration is saved in each array cell. See Accumulated demodulation.</p> PARAMETER DESCRIPTION <code>iw</code> <p>integration weights</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>variable to which demod result is saved</p> <p> TYPE: <code>QUA array</code> </p> <code>samples_per_chunk</code> <p>The number of ADC samples to be used for each chunk is this number times 4.</p> <p> TYPE: <code>int</code> </p> <code>element_output</code> <p>(optional) the output of an element from which to get ADC results</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.RealAccumulationMethod.full","title":"<code>full</code>","text":"<p>Perform an ordinary demodulation/integration. See Full demodulation.</p> PARAMETER DESCRIPTION <code>iw</code> <p>integration weights</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>variable to which demod result is saved</p> <p> TYPE: <code>QUA variable</code> </p> <code>element_output</code> <p>(optional) the output of an element from which to get ADC results</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.RealAccumulationMethod.moving_window","title":"<code>moving_window</code>","text":"<p>Same as <code>sliced()</code>, however the several chunks are accumulated and saved to each array cell. See Moving window demodulation.</p> PARAMETER DESCRIPTION <code>iw</code> <p>integration weights</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>variable to which demod result is saved</p> <p> TYPE: <code>QUA array</code> </p> <code>samples_per_chunk</code> <p>The number of ADC samples to be used for each chunk is this number times 4.</p> <p> TYPE: <code>int</code> </p> <code>chunks_per_window</code> <p>The number of chunks to use in the moving window</p> <p> TYPE: <code>int</code> </p> <code>element_output</code> <p>(optional) the output of an element from which to get ADC results</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.RealAccumulationMethod.sliced","title":"<code>sliced</code>","text":"<p>Perform a demodulation/integration in which the demodulation/integration process is split into chunks and the value of each chunk is saved in an array cell. See Sliced demodulation.</p> PARAMETER DESCRIPTION <code>iw</code> <p>integration weights</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>variable to which demod result is saved</p> <p> TYPE: <code>QUA array</code> </p> <code>samples_per_chunk</code> <p>The number of ADC samples to be used for each chunk is this number times 4.</p> <p> TYPE: <code>int</code> </p> <code>element_output</code> <p>(optional) the output of an element from which to get ADC results</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.DualAccumulationMethod","title":"<code>qm.qua._dsl.DualAccumulationMethod</code>","text":"<p>A base class for specifying the dual integration and demodulation processes in the :func:<code>measure</code> statement. These are the options which can be used inside the measure command as part of the <code>dual_demod</code> and <code>dual_integration</code> processes.</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.DualAccumulationMethod.accumulated","title":"<code>accumulated</code>","text":"<p>This feature is currently not supported in QUA</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.DualAccumulationMethod.full","title":"<code>full</code>","text":"<p>Perform an ordinary dual demodulation/integration. See Dual demodulation.</p> PARAMETER DESCRIPTION <code>iw1</code> <p>integration weights to be applied to element_output1</p> <p> TYPE: <code>str</code> </p> <code>element_output1</code> <p>the output of an element from which to get ADC results</p> <p> TYPE: <code>str</code> </p> <code>iw2</code> <p>integration weights to be applied to element_output2</p> <p> TYPE: <code>str</code> </p> <code>element_output2</code> <p>the output of an element from which to get ADC results</p> <p> TYPE: <code>str</code> </p> <code>target</code> <p>variable to which demod result is saved</p> <p> TYPE: <code>QUA variable</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.DualAccumulationMethod.moving_window","title":"<code>moving_window</code>","text":"<p>This feature is currently not supported in QUA</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.DualAccumulationMethod.sliced","title":"<code>sliced</code>","text":"<p>This feature is currently not supported in QUA</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.TimeTagging","title":"<code>qm.qua._dsl.TimeTagging</code>","text":"<p>A base class for specifying the time tagging process in the measure statement. These are the options which can be used inside the measure command as part of the <code>time_tagging</code> process.</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.TimeTagging.analog","title":"<code>analog</code>","text":"<p>Performs time tagging. See Time tagging.</p> PARAMETER DESCRIPTION <code>target</code> <p>The QUA array into which the times of the detected pulses are saved (in ns)</p> <p> TYPE: <code>QUA array of type int</code> </p> <code>max_time</code> <p>The time in which pulses are detected (Must be larger than the pulse duration)</p> <p> TYPE: <code>QUA int</code> </p> <code>targetLen</code> <p>A QUA int which will get the number of pulses detected</p> <p> TYPE: <code>QUA int</code> DEFAULT: <code>None</code> </p> <code>element_output</code> <p>the output of an element from which to get the pulses</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.TimeTagging.digital","title":"<code>digital</code>","text":"<p>Performs time tagging from the attached OPD.  See Time tagging.</p> <p>-- Available with the OPD addon --</p> PARAMETER DESCRIPTION <code>target</code> <p>The QUA array into which the times of the detected pulses are saved (in ns)</p> <p> TYPE: <code>QUA array of type int</code> </p> <code>max_time</code> <p>The time in which pulses are detected (Must be larger than the pulse duration)</p> <p> TYPE: <code>QUA int</code> </p> <code>targetLen</code> <p>A QUA int which will get the number of pulses detected</p> <p> TYPE: <code>QUA int</code> DEFAULT: <code>None</code> </p> <code>element_output</code> <p>the output of an element from which to get the pulses</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.TimeTagging.high_res","title":"<code>high_res</code>","text":"<p>Performs high resolution time tagging. See Time tagging.</p> <p>-- Available from QOP 2.0 --</p> PARAMETER DESCRIPTION <code>target</code> <p>The QUA array into which the times of the detected pulses are saved (in ps)</p> <p> TYPE: <code>QUA array of type int</code> </p> <code>max_time</code> <p>The time in which pulses are detected (Must be larger than the pulse duration)</p> <p> TYPE: <code>QUA int</code> </p> <code>targetLen</code> <p>A QUA int which will get the number of pulses detected</p> <p> TYPE: <code>QUA int</code> DEFAULT: <code>None</code> </p> <code>element_output</code> <p>the output of an element from which to get the pulses</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.Counting","title":"<code>qm.qua._dsl.Counting</code>","text":"<p>A base class for specifying the counting process in the measure statement. These are the options which can be used inside the measure command as part of the <code>counting</code> process.</p> <p>-- Available with the OPD addon --</p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.Counting.digital","title":"<code>digital</code>","text":"<p>Performs counting from the attached OPD. See Time tagging.</p> <p>-- Available with the OPD addon --</p> PARAMETER DESCRIPTION <code>target</code> <p>A QUA int which will get the number of pulses detected</p> <p> TYPE: <code>QUA int</code> </p> <code>max_time</code> <p>The time in which pulses are detected (Must be larger than the pulse duration)</p> <p> TYPE: <code>QUA int</code> </p> <code>element_outputs</code> <p>the outputs of an element from which to get ADC results</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/dsl_main/#qm.qua._dsl.stream_processing","title":"<code>qm.qua._dsl.stream_processing</code>","text":"<p>A context manager for the creation of Stream processing pipelines</p> <p>Each pipeline defines an analysis process that is applied to every stream item. A pipeline must be terminated with a save/save_all terminal, and then can be retrieved with QmJob.result_handles.</p> <p>There are two save options: <code>save_all</code> will save every stream item, <code>save</code> will save only last item.</p> <p>A pipeline can be assigned to python variable, and then reused on other pipelines. It is ensured that the common part of the pipeline is processed only once.</p> Creating a results analysis <pre><code>with stream_processing():\na.save(\"tag\")\na.save_all(\"another tag\")\n</code></pre> Retrieving saved result <pre><code>QmJob.result_handles.get(\"tag\")\n</code></pre>","boost":2.5},{"location":"qm-qua-sdk/docs/API_references/qua/math/","title":"Math functions","text":"","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math","title":"<code>qm.qua.lib.Math</code>","text":"","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.abs","title":"<code>abs</code>  <code>staticmethod</code>","text":"<p>Computes the absolute value of x</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA variable</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.aelu","title":"<code>aelu</code>  <code>staticmethod</code>","text":"<p>Computes faster an approximated Exponential Linear Unit activation function of x   \\(\\mathrm{aELU}(x) \\sim \\mathrm{ELU}(x)\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.argmax","title":"<code>argmax</code>  <code>staticmethod</code>","text":"<p>Return the index of the maximum of an array</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA array</p> <p> </p> RETURNS DESCRIPTION <p>the index of maximum value of array, a QUA Integer</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.argmin","title":"<code>argmin</code>  <code>staticmethod</code>","text":"<p>Return the index of the minimum of an array</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA array</p> <p> </p> RETURNS DESCRIPTION <p>the index of minimum value of array, a QUA Integer</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.cos","title":"<code>cos</code>  <code>staticmethod</code>","text":"<p>Computes \\(\\mathrm{cos}(x)\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>the angle in radians</p> <p> TYPE: <code>QUA variable of type fixed</code> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.cos2pi","title":"<code>cos2pi</code>  <code>staticmethod</code>","text":"<p>Computes \\(\\mathrm{cos}(2 \\pi x)\\). This is more efficient than Math.cos(\\(2 \\pi x\\)). In addition, this function is immune to overflows: An overflow means that the argument gets a :math:<code>\\pm 16</code>, which does not change the result due to the periodcity of the cosine function.</p> PARAMETER DESCRIPTION <code>x</code> <p>the angle in radians</p> <p> TYPE: <code>QUA variable of type fixed</code> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.div","title":"<code>div</code>  <code>staticmethod</code>","text":"<p>Computes the division between two same-type variables \\(x/y\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA parameter</p> <p> </p> <code>y</code> <p>a QUA parameter not equal to 0</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.dot","title":"<code>dot</code>  <code>staticmethod</code>","text":"<p>Calculates a dot product of two QUA arrays of identical size.</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA array</p> <p> </p> <code>y</code> <p>a QUA array</p> <p> </p> RETURNS DESCRIPTION <p>The dot product of x and y, has same type as x and y</p> Example <pre><code>assign(c, dot(a, b))\n</code></pre>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.elu","title":"<code>elu</code>  <code>staticmethod</code>","text":"<p>Computes the Exponential Linear Unit activation function of x   \\(\\mathrm{ELU(x)} = \\mathrm{max}(0, x) + \\mathrm{min}(0, \\mathrm{exp}(x)-1)\\).</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.exp","title":"<code>exp</code>  <code>staticmethod</code>","text":"<p>Computes \\(e^{x}\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed smaller than ln(8)=2.0794415416</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.inv","title":"<code>inv</code>  <code>staticmethod</code>","text":"<p>Computes the inverse of x</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed which is x&lt;=-1/8 or 1/8&lt;x</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.inv_sqrt","title":"<code>inv_sqrt</code>  <code>staticmethod</code>","text":"<p>Computes the inverse square root of x</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed larger than 1/64</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.ln","title":"<code>ln</code>  <code>staticmethod</code>","text":"<p>Computes \\(\\mathrm{ln}(x)\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed larger than exp(-8)=0.0003354627</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.log","title":"<code>log</code>  <code>staticmethod</code>","text":"<p>Computes \\(\\mathrm{log}_{base}(x)\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed larger than pow2(-8)=0.00390625</p> <p> </p> <code>base</code> <p>a QUA fixed larger than pow2(1/8)=1.09051</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.log10","title":"<code>log10</code>  <code>staticmethod</code>","text":"<p>Computes \\(\\mathrm{log}_{10}(x)\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed larger than pow10(-8)=0.00000001</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.log2","title":"<code>log2</code>  <code>staticmethod</code>","text":"<p>Computes \\(\\mathrm{log}_{2}(x)\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed larger than pow2(-8)=0.00390625</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.lrelu","title":"<code>lrelu</code>  <code>staticmethod</code>","text":"<p>Computes the Leaky Rectified Linear Unit activation function of x   \\(\\mathrm{LReLU}(x)=\\mathrm{max}(0, x)+0.01*\\mathrm{min}(0, x)\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.max","title":"<code>max</code>  <code>staticmethod</code>","text":"<p>Computes the max of an array x</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA array</p> <p> </p> RETURNS DESCRIPTION <p>the max value of the array, has same type as x</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.min","title":"<code>min</code>  <code>staticmethod</code>","text":"<p>Computes the min of an array x</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA array</p> <p> </p> RETURNS DESCRIPTION <p>the min value of the array, has same type as x</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.msb","title":"<code>msb</code>  <code>staticmethod</code>","text":"<p>Finds the index of the most significant bit in the parameter x. Notes:</p> <ul> <li>Result is independent of sign, for example, +3 and -3 will return the same msb</li> <li>The returned value will be the closet log2, rounded down.</li> </ul> <p>This is given by \\(\\mathrm{floor}(\\mathrm{log}_2(|x|))\\).</p> <p>For example:</p> <ul> <li>msb(0.1) will return -4.</li> <li>msb(5) will return 2.</li> <li>For an integer, msb(0) will return 0.</li> <li>For a fixed point number, msb(0) will return -28.</li> </ul> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed or a QUA int</p> <p> </p> RETURNS DESCRIPTION <p>a QUA int</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.plrelu","title":"<code>plrelu</code>  <code>staticmethod</code>","text":"<p>Computes the Parametric Leaky Rectified Linear Unit activation function of x   \\(\\mathrm{PLReLU}(x, a) = \\mathrm{max}(0, x)+a*\\mathrm{min}(0, x)\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed</p> <p> </p> <code>a</code> <p>a QUA fixed</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.pow","title":"<code>pow</code>  <code>staticmethod</code>","text":"<p>Computes \\({base}^{x}\\). Does not support base=1, nor the case where both base=0 &amp; x=0.</p> PARAMETER DESCRIPTION <code>base</code> <p>a non-negative QUA fixed</p> <p> </p> <code>x</code> <p>a QUA fixed</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.pow2","title":"<code>pow2</code>  <code>staticmethod</code>","text":"<p>Computes \\(2^{x}\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed smaller than 3 (to avoid overflow)</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.relu","title":"<code>relu</code>  <code>staticmethod</code>","text":"<p>Computes the Rectified Linear Unit activation function of x   \\(\\mathrm{ReLU}(x) = \\mathrm{max}(0, x)\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.selu","title":"<code>selu</code>  <code>staticmethod</code>","text":"<p>Computes the Scaled Exponential Linear Unit activation function of x \\(\\mathrm{SELU}(x) = s*(\\mathrm{max}(0, x)+a*\\mathrm{min}(0, \\mathrm{exp}(x)-1))\\), \\(a=1.67326324\\), \\(s=1.05070098\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA fixed</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.sin","title":"<code>sin</code>  <code>staticmethod</code>","text":"<p>Computes \\(\\mathrm{sin}(x)\\)</p> PARAMETER DESCRIPTION <code>x</code> <p>the angle in radians</p> <p> TYPE: <code>QUA variable of type fixed</code> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.sin2pi","title":"<code>sin2pi</code>  <code>staticmethod</code>","text":"<p>Computes \\(\\mathrm{sin}(2 \\pi x)\\). This is more efficient than <code>Math.sin(2*np.pi*x)</code>. In addition, this function is immune to overflows: An overflow means that the argument gets a \\(\\pm 16\\), which does not change the result due to the periodicity of the sine function.</p> PARAMETER DESCRIPTION <code>x</code> <p>the angle in radians</p> <p> TYPE: <code>QUA variable of type fixed</code> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.sqrt","title":"<code>sqrt</code>  <code>staticmethod</code>","text":"<p>Computes the square root of x</p> PARAMETER DESCRIPTION <code>x</code> <p>a non-negative QUA fixed</p> <p> </p> RETURNS DESCRIPTION <p>a QUA fixed</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/math/#qm.qua.lib.Math.sum","title":"<code>sum</code>  <code>staticmethod</code>","text":"<p>Computes the sum of an array x</p> PARAMETER DESCRIPTION <code>x</code> <p>a QUA array</p> <p> </p> RETURNS DESCRIPTION <p>the sum of the array, has same type as x</p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/random/","title":"Random numbers","text":"","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/random/#qm.qua.lib.Random","title":"<code>qm.qua.lib.Random</code>","text":"<p>A class for generating pseudo-random numbers in QUA</p> PARAMETER DESCRIPTION <code>seed</code> <p>Optional. An integer seed for the pseudo-random number generator.</p> <p> DEFAULT: <code>None</code> </p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/random/#qm.qua.lib.Random.rand_fixed","title":"<code>rand_fixed</code>","text":"<p>Returns a pseudorandom fixed in range [0.0, 1.0)</p> Example <pre><code>a= Random()\nassign(b,a.rand_fixed())\n</code></pre>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/random/#qm.qua.lib.Random.rand_int","title":"<code>rand_int</code>","text":"<p>Returns a pseudorandom integer in range [0, max_int)</p> PARAMETER DESCRIPTION <code>max_int</code> <p>maximum value</p> <p> </p> Example <pre><code>a= Random()\nassign(b,a.rand_int(max_int))\n</code></pre>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/random/#qm.qua.lib.Random.set_seed","title":"<code>set_seed</code>","text":"<p>Set the seed for the pseudo-random number generator</p> PARAMETER DESCRIPTION <code>exp</code> <p>a QUA expression</p> <p> </p>","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/","title":"Result Stream","text":""},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qmqua_dsl_resultstream","title":"qm.qua._dsl._ResultStream","text":""},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream","title":"<code>qm.qua._dsl._ResultStream</code>","text":""},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.add","title":"<code>add</code>","text":"<p>Allows addition between streams. The addition is done element-wise. Can also be performed on buffers and other operators, but they must have the same dimensions.</p> Example <pre><code>i = declare(int)\nj = declare(int)\nk = declare(int, value=5)\nstream = declare_stream()\nstream2 = declare_stream()\nstream3 = declare_stream()\nwith for_(j, 0, j &lt; 30, j + 1):\nwith for_(i, 0, i &lt; 10, i + 1):\nsave(i, stream)\nsave(j, stream2)\nsave(k, stream3)\nwith stream_processing():\n(stream1 + stream2 + stream3).save_all(\"example1\")\n(stream1.buffer(10) + stream2.buffer(10) + stream3.buffer(10)).save_all(\"example2\")\n(stream1 + stream2 + stream3).buffer(10).average().save(\"example3\")\n</code></pre>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.average","title":"<code>average</code>","text":"<p>Perform a running average on a stream item. The Output of this operation is the running average of the values in the stream starting from the beginning of the QUA program.</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.boolean_to_int","title":"<code>boolean_to_int</code>","text":"<p>converts boolean to an integer number - 1 for true and 0 for false</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.buffer","title":"<code>buffer</code>","text":"<p>Gather items into vectors - creates an array of input stream items and outputs the array as one item. only outputs full buffers.</p> Note <p>The order of resulting dimensions is different when using a buffer with multiple inputs compared to using multiple buffers. The following two lines are equivalent: <pre><code>stream.buffer(n, l, k)\nstream.buffer(k).buffer(l).buffer(n)\n</code></pre></p> PARAMETER DESCRIPTION <code>*args</code> <p>number of items to gather, can either be a single number, which gives the results as a 1d array or multiple numbers for a multidimensional array.</p> <p> DEFAULT: <code>()</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.buffer_and_skip","title":"<code>buffer_and_skip</code>","text":"<p>Gather items into vectors - creates an array of input stream items and outputs the array as one item. Skips the number of given elements. Note that length and skip start from the same index, so the <code>buffer(n)</code> command is equivalent to <code>buffer_and_skip(n, n)</code>.</p> <p>Only outputs full buffers.</p> Example <pre><code># The stream input is [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\nwith stream_processing():\nstream.buffer(3).save_all(\"example1\")\nstream.buffer_and_skip(3, 3).save_all(\"example2\")\nstream.buffer_and_skip(3, 2).save_all(\"example3\")\nstream.buffer_and_skip(3, 5).save_all(\"example4\")\n# example1 -&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n# example2 -&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n# example3 -&gt; [[1, 2, 3], [3, 4, 5], [5, 6, 7], [7, 8, 9]]\n# example4 -&gt; [[1, 2, 3], [6, 7, 8]]\n</code></pre> PARAMETER DESCRIPTION <code>length</code> <p>number of items to gather</p> <p> TYPE: <code>PyNumberType</code> </p> <code>skip</code> <p>number of items to skip for each buffer, starting from the same index as length</p> <p> TYPE: <code>PyNumberType</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.convolution","title":"<code>convolution</code>","text":"<p>Computes discrete, linear convolution of one-dimensional constant vector and one-dimensional vector item of the input stream.</p> PARAMETER DESCRIPTION <code>constant_vector</code> <p>vector of numbers</p> <p> TYPE: <code>PyNumberArrayType</code> </p> <code>mode</code> <p>\"full\", \"same\" or \"valid\"</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.divide","title":"<code>divide</code>","text":"<p>Allows division between streams. The division is done element-wise. Can also be performed on buffers and other operators, but they must have the same dimensions.</p> Example <pre><code>i = declare(int)\nj = declare(int)\nk = declare(int, value=5)\nstream = declare_stream()\nstream2 = declare_stream()\nstream3 = declare_stream()\nwith for_(j, 0, j &lt; 30, j + 1):\nwith for_(i, 0, i &lt; 10, i + 1):\nsave(i, stream)\nsave(j, stream2)\nsave(k, stream3)\nwith stream_processing():\n(stream1 / stream2 / stream3).save_all(\"example1\")\n(stream1.buffer(10) / stream2.buffer(10) / stream3.buffer(10)).save_all(\"example2\")\n(stream1 / stream2 / stream3).buffer(10).average().save(\"example3\")\n</code></pre>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.dot_product","title":"<code>dot_product</code>","text":"<p>Computes dot product of the given vector and each item of the input stream</p> PARAMETER DESCRIPTION <code>vector</code> <p>constant vector of numbers</p> <p> TYPE: <code>PyNumberArrayType</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.fft","title":"<code>fft</code>","text":"<p>Computes one-dimensional discrete fourier transform for every item in the stream. Item can be a vector of numbers, in this case fft will assume all imaginary numbers are 0. Item can also be a vector of number pairs - in this case for each pair - the first will be real and second imaginary.</p> PARAMETER DESCRIPTION <code>output</code> <p>supported from QOP 1.30 and QOP 2.0, options are \"normal\", \"abs\" and \"angle\":</p> <ul> <li>\"normal\" - Same as default (none), returns a 2d array of     size Nx2, where N is the length of the original vector.     The first item in each pair is the real part, and the 2nd     is the imaginary part.</li> <li>\"abs\" - Returns a 1d array of size N with the abs of the fft.</li> <li>\"angle\" - Returns the angle between the imaginary and real     parts in radians.</li> </ul> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>_ResultStream</code> <p>stream object</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.flatten","title":"<code>flatten</code>","text":"<p>Deconstruct an array item - and send its elements one by one as items</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.histogram","title":"<code>histogram</code>","text":"<p>Compute the histogram of all items in stream</p> PARAMETER DESCRIPTION <code>bins</code> <p>vector or pairs. each pair indicates the edge of each bin. example: [[1,10],[11,20]] - two bins, one between 1 and 10, second between 11 and 20</p> <p> TYPE: <code>List[List[PyNumberType]]</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.map","title":"<code>map</code>","text":"<p>Transform the item by applying a function to it</p> PARAMETER DESCRIPTION <code>function</code> <p>a function to transform each item to a different item. For example, to compute an average between elements in a buffer you should write \".buffer(len).map(FUNCTIONS.average())\"</p> <p> TYPE: <code>CommandsType</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.multiply","title":"<code>multiply</code>","text":"<p>Allows multiplication between streams. The multiplication is done element-wise. Can also be performed on buffers and other operators, but they must have the same dimensions.</p> Example <pre><code>i = declare(int)\nj = declare(int)\nk = declare(int, value=5)\nstream = declare_stream()\nstream2 = declare_stream()\nstream3 = declare_stream()\nwith for_(j, 0, j &lt; 30, j + 1):\nwith for_(i, 0, i &lt; 10, i + 1):\nsave(i, stream)\nsave(j, stream2)\nsave(k, stream3)\nwith stream_processing():\n(stream1 * stream2 * stream3).save_all(\"example1\")\n(stream1.buffer(10) * stream2.buffer(10) * stream3.buffer(10)).save_all(\"example2\")\n(stream1 * stream2 * stream3).buffer(10).average().save(\"example3\")\n</code></pre>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.multiply_by","title":"<code>multiply_by</code>","text":"<p>Multiply the input stream item by a constant scalar or vector. The input item can be either scalar or vector.</p> PARAMETER DESCRIPTION <code>scalar_or_vector</code> <p>either a scalar number, or a vector of scalars.</p> <p> TYPE: <code>OneOrMore[PyNumberType]</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.save","title":"<code>save</code>","text":"<p>Save only the last item received in stream This will add to qm._results.JobResults a qm._results.MultipleNamedJobResult object.</p> PARAMETER DESCRIPTION <code>tag</code> <p>result name</p> <p> TYPE: <code>str</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.save_all","title":"<code>save_all</code>","text":"<p>Save all items received in stream. This will add to qm._results.JobResults a qm._results.SingleNamedJobResult object.</p> PARAMETER DESCRIPTION <code>tag</code> <p>result name</p> <p> TYPE: <code>str</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.skip","title":"<code>skip</code>","text":"<p>Suppress the first n items of the stream</p> PARAMETER DESCRIPTION <code>length</code> <p>number of items to skip</p> <p> TYPE: <code>PyNumberType</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.skip_last","title":"<code>skip_last</code>","text":"<p>Suppress the last n items of the stream</p> PARAMETER DESCRIPTION <code>length</code> <p>number of items to skip</p> <p> TYPE: <code>PyNumberType</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.subtract","title":"<code>subtract</code>","text":"<p>Allows subtraction between streams. The subtraction is done element-wise. Can also be performed on buffers and other operators, but they must have the same dimensions.</p> Example <pre><code>i = declare(int)\nj = declare(int)\nk = declare(int, value=5)\nstream = declare_stream()\nstream2 = declare_stream()\nstream3 = declare_stream()\nwith for_(j, 0, j &lt; 30, j + 1):\nwith for_(i, 0, i &lt; 10, i + 1):\nsave(i, stream)\nsave(j, stream2)\nsave(k, stream3)\nwith stream_processing():\n(stream1 - stream2 - stream3).save_all(\"example1\")\n(stream1.buffer(10) - stream2.buffer(10) - stream3.buffer(10)).save_all(\"example2\")\n(stream1 - stream2 - stream3).buffer(10).average().save(\"example3\")\n</code></pre>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.take","title":"<code>take</code>","text":"<p>Outputs only the first n items of the stream</p> PARAMETER DESCRIPTION <code>length</code> <p>number of items to take</p> <p> TYPE: <code>PyNumberType</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.tuple_convolution","title":"<code>tuple_convolution</code>","text":"<p>Computes discrete, linear convolution of two one-dimensional vectors that received as the one item from the input stream</p> PARAMETER DESCRIPTION <code>mode</code> <p>\"full\", \"same\" or \"valid\"</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.tuple_dot_product","title":"<code>tuple_dot_product</code>","text":"<p>Computes dot product of the given item of the input stream - that should include two vectors</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.tuple_multiply","title":"<code>tuple_multiply</code>","text":"<p>Computes multiplication of the given item of the input stream - that can be any combination of scalar and vectors.</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultStream.zip","title":"<code>zip</code>","text":"<p>Combine the emissions of two streams to one item that is a tuple of items of input streams</p> PARAMETER DESCRIPTION <code>other</code> <p>second stream to combine with self</p> <p> TYPE: <code>_ResultStream</code> </p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qmqua_dsl_functions","title":"qm.qua._dsl._Functions","text":""},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._Functions","title":"<code>qm.qua._dsl._Functions</code>","text":""},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._Functions.average","title":"<code>average</code>  <code>staticmethod</code>","text":"<p>Perform a running average on a stream item. The Output of this operation is the running average of the values in the stream starting from the beginning of the QUA program.</p> PARAMETER DESCRIPTION <code>axis</code> <p>optional Axis or axes along which to average.</p> <p> TYPE: <code>OneOrMore[PyNumberType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CommandsType</code> <p>stream object</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._Functions.boolean_to_int","title":"<code>boolean_to_int</code>  <code>staticmethod</code>","text":"<p>Converts boolean to integer number - 1 for true and 0 for false</p> <p>:return: stream object</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._Functions.convolution","title":"<code>convolution</code>  <code>staticmethod</code>","text":"<p>Computes discrete, linear convolution of one-dimensional constant vector and one-dimensional vector item of the input stream.</p> PARAMETER DESCRIPTION <code>constant_vector</code> <p>vector of numbers</p> <p> TYPE: <code>PyNumberArrayType</code> </p> <code>mode</code> <p>\"full\", \"same\" or \"valid\"</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CommandsType</code> <p>stream object</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._Functions.demod","title":"<code>demod</code>  <code>staticmethod</code>","text":"<p>Demodulates the acquired data from the indicated stream at the given frequency and integration weights. If operating on a stream of tuples, assumes that the 2nd item is the timestamps and uses them for the demodulation, reproducing the demodulation performed in real time. If operated on a single stream, assumes that the first item is at time zero and that the elements are separated by 1ns.</p> PARAMETER DESCRIPTION <code>frequency</code> <p>frequency for demodulation calculation</p> <p> TYPE: <code>PyNumberType</code> </p> <code>iw_cos</code> <p>cosine integration weight. Integration weight can be either a scalar for constant integration weight, or a python iterable for arbitrary integration weights.</p> <p> TYPE: <code>PyNumberType</code> </p> <code>iw_sin</code> <p>sine integration weight. Integration weight can be either a scalar for constant integration weight, or a python iterable for arbitrary integration weights.</p> <p> TYPE: <code>PyNumberType</code> </p> <code>integrate</code> <p>sum the demodulation result and returns a scalar if True (default), else the demodulated stream without summation is returned</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <p>stream object</p> Example <pre><code>with stream_processing():\nadc_stream.input1().with_timestamps().map(FUNCTIONS.demod(freq, 1.0, 0.0, integrate=False)).average().save('cos_env')\nadc_stream.input1().with_timestamps().map(FUNCTIONS.demod(freq, 1.0, 0.0)).average().save('cos_result')  # Default is integrate=True\n</code></pre> Note <p>The demodulation in the stream processing does not take in consideration any real-time modifications to the frame, phase or frequency of the element. If the program has any QUA command that changes them, the result of the stream processing demodulation will be invalid.</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._Functions.dot_product","title":"<code>dot_product</code>  <code>staticmethod</code>","text":"<p>Computes dot product of the given vector and an item of the input stream</p> PARAMETER DESCRIPTION <code>vector</code> <p>constant vector of numbers</p> <p> TYPE: <code>PyNumberArrayType</code> </p> RETURNS DESCRIPTION <code>CommandsType</code> <p>stream object</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._Functions.fft","title":"<code>fft</code>  <code>staticmethod</code>","text":"<p>Computes one-dimensional discrete fourier transform for every item in the stream. Item can be a vector of numbers, in this case fft will assume all imaginary numbers are 0. Item can also be a vector of number pairs - in this case for each pair - the first will be real and second imaginary.</p> PARAMETER DESCRIPTION <code>output</code> <p>supported from QOP 1.30 and QOP 2.0, options are \"normal\", \"abs\" and \"angle\":</p> <ul> <li>\"normal\" - Same as default (none), returns a 2d array of     size Nx2, where N is the length of the original vector.     The first item in each pair is the real part, and the 2nd     is the imaginary part.</li> <li>\"abs\" - Returns a 1d array of size N with the abs of the fft.</li> <li>\"angle\" - Returns the angle between the imaginary and real     parts in radians.</li> </ul> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CommandsType</code> <p>stream object</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._Functions.multiply_by","title":"<code>multiply_by</code>  <code>staticmethod</code>","text":"<p>Multiply the input stream item by a constant scalar or vector. the input item can be either scalar or vector.</p> PARAMETER DESCRIPTION <code>scalar_or_vector</code> <p>either a scalar number, or a vector of scalars.</p> <p> TYPE: <code>OneOrMore[PyNumberType]</code> </p> RETURNS DESCRIPTION <code>CommandsType</code> <p>stream object</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._Functions.tuple_convolution","title":"<code>tuple_convolution</code>  <code>staticmethod</code>","text":"<p>Computes discrete, linear convolution of two one-dimensional vectors of the input stream</p> PARAMETER DESCRIPTION <code>mode</code> <p>\"full\", \"same\" or \"valid\"</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CommandsType</code> <p>stream object</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._Functions.tuple_dot_product","title":"<code>tuple_dot_product</code>  <code>staticmethod</code>","text":"<p>Computes dot product between the two vectors of the input stream</p> RETURNS DESCRIPTION <code>CommandsType</code> <p>stream object</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._Functions.tuple_multiply","title":"<code>tuple_multiply</code>  <code>staticmethod</code>","text":"<p>Computes multiplication between the two elements of the input stream. Can be any combination of scalar and vectors.</p> RETURNS DESCRIPTION <code>CommandsType</code> <p>stream object</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qmqua_dsl_resultsource","title":"qm.qua._dsl._ResultSource","text":""},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultSource","title":"<code>qm.qua._dsl._ResultSource</code>","text":"<p>A python object representing a source of values that can be processed in a <code>stream_processing()</code> pipeline</p> <p>This interface is chainable, which means that calling most methods on this object will create a new streaming source</p> <p>See the base class _ResultStream for operations</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultSource.auto_reshape","title":"<code>auto_reshape</code>","text":"<p>Creates a buffer with dimensions according to the program structure in QUA.</p> <p>For example, when running the following program the result \"reshaped\" will have shape of (30,10):</p> Example <pre><code>i = declare(int)\nj = declare(int)\nstream = declare_stream()\nwith for_(i, 0, i &lt; 30, i + 1):\nwith for_(j, 0, j &lt; 10, j + 1):\nsave(i, stream)\nwith stream_processing():\nstream.auto_reshape().save_all(\"reshaped\")\n</code></pre>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultSource.input1","title":"<code>input1</code>","text":"<p>A stream of raw ADC data from input 1. Only relevant when saving data from measure statement.</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultSource.input2","title":"<code>input2</code>","text":"<p>A stream of raw ADC data from input 2. Only relevant when saving data from measure statement.</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultSource.timestamps","title":"<code>timestamps</code>","text":"<p>Get a stream with only the timestamps of the stream-items</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/result_stream/#qm.qua._dsl._ResultSource.with_timestamps","title":"<code>with_timestamps</code>","text":"<p>Get a stream with the relevant timestamp for each stream-item</p>"},{"location":"qm-qua-sdk/docs/API_references/qua/util/","title":"Utility","text":"","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/util/#qm.qua.lib.Util","title":"<code>qm.qua.lib.Util</code>","text":"","boost":2.0},{"location":"qm-qua-sdk/docs/API_references/qua/util/#qm.qua.lib.Util.cond","title":"<code>cond</code>  <code>staticmethod</code>","text":"<p>Quick conditional operation. This is equivalent to a ternary operator available in some languages: i.e. <code>a ? b : c</code>, meaning <code>b</code> if <code>a</code> is true, or <code>c</code> if <code>a</code> is false. There is less computation overhead (less latency) when running this operation relative to the if conditional.</p> Example <pre><code>assign(var, cond(a, b, c)) #where a is a boolean expression\n</code></pre>","boost":2.0},{"location":"qm-qua-sdk/docs/Guides/","title":"Index","text":"<p>This section provides in-depth information regarding the QOP powerful capabilities and features.</p>"},{"location":"qm-qua-sdk/docs/Guides/analog_input_stage/","title":"Analog Input Stage","text":"<p>The signals acquired by the OPX using the analog input channels are first passed through an analog input stage and then digitized. Here we discuss the voltage limits, gain and offset calibrations that can be applied to the signal to be digitized.</p>"},{"location":"qm-qua-sdk/docs/Guides/analog_input_stage/#acquiring-analog-signals-with-the-opx","title":"Acquiring analog signals with the OPX","text":"<p>The signal chain can be seen in Fig. 1. The signal source can be either AC or DC coupled.</p> <p>Note</p> <p>The OPX input has a common-mode voltage of 0.25V when measured with 50ohm.</p> <ul> <li> <p>DC coupled signal source</p> <p>If the signal source is DC coupled and has 50ohm DC resistance to ground, it can be directly connected to the analog input. This can be seen in Option 1 of Fig. 1</p> </li> <li> <p>AC coupled signal source</p> <p>If the signal source is AC coupled and does not have a 50ohm resistance to ground, a bias T is needed in order to bias the input amplifier. The required setup can be seen in option 2 of Fig. 1. In this case, the source will still need to have a 50ohm AC impedance throughout its bandwidth for proper operation.</p> </li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/analog_input_stage/#properties-of-the-analog-input-stage","title":"Properties of the analog input stage","text":"<p>The analog input has the following properties:</p> <ul> <li>Input impedance: 50ohms</li> <li>ADC resolution: 12 bits</li> <li>Input bandwidth: 400MHz</li> <li>Full voltage range: 1.0Vpp into 50ohm or 4dBm (nominal)</li> <li>Variable gain: -12dB to 20dB in steps of 1dB</li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/analog_input_stage/#setting-the-voltage-gain","title":"Setting the voltage gain","text":"<p>The voltage gain can be set by adding a <code>\"gain_db\"</code> field to the <code>\"analog_inputs\"</code> field of the controller in the config. Here we show an example with the relevant fields:</p> <pre><code>config = {\n'version': 1,\n'controllers': {\n'con1': {\n'analog_inputs': {\n1: {'offset': 0.0, 'gain_db': -1},\n2: {'offset': 0.0, 'gain_db': 1},\n}\n}\n},\n}\n</code></pre> <p>Note</p> <p>When changing the gain, the input DC offset needs to be recalibrated.</p>"},{"location":"qm-qua-sdk/docs/Guides/best_practices/","title":"QUA \"Best Practice\" Guide","text":"<p>This article showcases what we consider best practice when writing in QUA. That is both for user readability as well as for improved performance. We note cases where there is a clear tradeoff between the two.</p> <p>QUA is a new language that keeps evolving, and we expect this guide to evolve with it. We'll be happy for any comments or suggestions.</p>"},{"location":"qm-qua-sdk/docs/Guides/best_practices/#general","title":"General","text":"<ul> <li> <p>Pulse amplitude and duration should be set in the configuration whenever possible. Using the <code>* amp()</code> and   <code>duration</code> fields requires real-time computation that can introduce gaps. They should only be used when sweeping   the parameters, either dynamically in QUA or manually.   If you require two different amplitudes, define two different operations.</p> </li> <li> <p>Beware of accumulated errors when using sticky elements and when using frame rotations. Make sure to reset the   values using <code>ramp_to_zero()</code> and <code>reset_frame()</code>.</p> </li> <li> <p>Only define QUA variables for parameters you want to sweep or change in real-time. Otherwise, use Python variables.</p> </li> <li> <p>Always simulate your program to make sure that you are getting the correct behavior. If added gaps are problematic,   the simulator can also be used to check the exact timing of pulses.</p> </li> <li> <p>There are issues that can occur in real time and produce unexpected output from the OPX, for example:</p> </li> <li> <p>A division by zero</p> </li> <li>An overflow of a QUA variable</li> <li>Trying to access an array out of bounds</li> <li>Trying to play a pulse (or wait) for a duration \\&lt; 4 cycles</li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/best_practices/#loops","title":"Loops","text":"<ul> <li> <p>Iterating with <code>for_each_()</code> loops adds a small overhead compared to using <code>for_()</code> loops.   In addition, they require saving the entire array into the memory, resulting in a limited array length.</p> </li> <li> <p>Beware of fixed/floating point inaccuracies. In the following example, it is unclear whether 1.0 would be included   in the sweep or not: <code>with for_(a, 0, a &lt; 1.0, a + 0.1)</code>.   Recommended practice to avoid that:</p> </li> <li> <p>Define the sweep parameters and sweep array in advance:</p> <pre><code># For floating/fixed:\na_min = 0\na_max = 1.0\nda = 0.1\na_vec = np.arange(a_min, a_max + da/2, da)  # This includes a_max, use -da/2 to not include it\n# For integers:\nt_min = 10\nt_max = 100\ndt = 3\nt_vec = np.arange(t_min, t_max + 0.1, dt)  # This includes t_max, use t_max - 0.1 to not include it\n</code></pre> </li> <li> <p>When sweeping a fixed point number, use the same syntax <code>with for_(a, a_min, a &lt; a_max + da/2, a + da)</code>.</p> </li> <li> <p>When sweeping an integer, use <code>&lt;</code> or <code>&lt;=</code>: <code>with for_(t, t_min, t &lt;= t_max, t + dt)</code></p> </li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/best_practices/#macros","title":"Macros","text":"<ul> <li> <p>Use macros the same way you would use functions in python - To allow reuse of code   (DRY) and to simplify the main code readability.</p> </li> <li> <p>QUA variables are always global. This means that you can use variables without passing them as an input and that   any variable which is changed inside the macro, regardless of whether it was given as an input or not, will   also be changed outside of the macro.   This is sometimes known as <code>pass-by-reference</code> as opposed to <code>pass-by-value</code>. In other words, QUA variables should   be treated as pointers to the real, hidden, variables.</p> </li> <li> <p>In order make it a bit more clear, we recommend the following:</p> </li> <li> <p>If there are external QUA variables which are needed in the macro, they should be passed as variables to the     macro.</p> </li> <li>Any other QUA variable used by the macro should be declared inside the macro.</li> <li>If a QUA variable, given as an input to the macro, is to be changed and we do not want the change to happen externally,     then the variable should be assigned to a local variable.</li> <li>Any QUA variable, which is declared/changed inside the macro, and is needed in the external program, should be     returned by the macro.</li> </ul> <p>For example:</p> <pre><code>def some_macro(qubit_state, var_for_calculation)  # Two variables coming from the outside\ntemp = declare(fixed)  # Local variable only for this macro\nimportant_var = declare(bool, value=False)  # Local variable declared inside, but then passed back outside\n...\nassign(temp, temp * var_for_calculation)  # Notice we do not change var_for_calculation, but declare a local variable \"temp\"\nwith if_((temp &gt; 0.1) &amp; (qubit_state == 1)):\n...\nassign(important_var, True)\nassign(qubit_state, 0)\nreturn qubit_state, important_var  # We send back qubit_state and important_var\nwith program() as example_prog:\n...\nqubit1_state, b_happened = some_macro(qubit1_state, i)\n...\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/demod/","title":"Demodulation and Measurement","text":"<p>The demodulation operation, used in the <code>measure()</code> QUA statement, is central to dispersive readout techniques such as cQED and other quantum platforms such as spin qubits, Majorana based qubits and others. In this section we describe it in general, from the perspective of applying it for state estimation using the OPX. We then show how it is performed in practice on the OPX, focusing on timing an fixed point implementation features.</p>"},{"location":"qm-qua-sdk/docs/Guides/demod/#overview-of-the-demodulation-operation","title":"Overview of the demodulation operation","text":"<p>\"Modulation\" is the process of encoding a slowly varying waveform \\(s(t)\\) on a fast-oscillating carrier \\(\\cos(\\omega_{LO}t+\\phi)\\). The simplest type of Modulation is amplitude modulation, which mathematically is simply multiplying the carrier with the waveform we want to encode,</p> \\[ a(t) = s(t)\\cos(\\omega_{LO}t+\\phi). \\] <p>\"Demodulation\" is the inverse process, whereby we extract the waveform information \\(s(t)\\) by doing an operation on the modulated waveform \\(a(t)\\).</p> <p>How is \\(s(t)\\) extracted from \\(a(t)\\) in practice? One relatively simple way, that works when \\(s(t)\\) varies much more slowly than \\(1/\\omega_{LO}\\), is the following. We calculate the integrals</p> \\[\\begin{eqnarray} I = \\frac{2}{T}\\int_{t}^{t + T}a(\\tau)\\cos(\\omega_{LO}\\tau)d\\tau, \\\\ Q = -\\frac{2}{T}\\int_{t}^{t + T}a(\\tau)\\sin(\\omega_{LO}\\tau)d\\tau, \\label{eq:i_and_q} \\end{eqnarray}\\] <p>where \\(T\\) is an integer number of periods which is short relative to the variation rate of \\(s(t)\\) (we deal with the effect of non-integer \\(T\\) in the next section). Substituting \\(a(t)\\), we get:</p> \\[ I \\simeq s(t)\\cos(\\phi) \\\\ Q \\simeq s(t)\\sin(\\phi) \\] <p>This result shows that we can think about the demodulation process as a projection from the waveform space onto a 2D plane with coordinates \\(I\\) and \\(Q\\). We can easily extract \\(s(t)=\\sqrt{I^2 + Q^2}\\). If however we know the value of \\(\\phi\\), we can get it without doing numerically-heavy operations like square root by calculating:</p> \\[ s(t) \\simeq I\\cos(\\phi) + Q\\sin(\\phi), \\] <p>or, in a single integration:</p> \\[ s(t) \\simeq \\frac{2}{T}\\int_{t}^{t+T}a(\\tau)[\\cos(\\phi)\\cos(\\omega_{LO}\\tau) - \\sin(\\phi)\\sin(\\omega_{LO}\\tau)]d\\tau. \\label{eq_analog} \\] <p>The OPX essentially allows us to do this operation, as we show in the next section.</p> <p>A similar analysis shows that we can also extract a slowly varying phase \\(\\delta \\phi(t)\\) from the modulated waveform</p> \\[ a(t) = A\\cos(\\omega_{IF}t + \\phi_0 + \\delta\\phi(t)), \\] <p>and this is typically how state information is extracted from a demodulated readout resonator signal.</p> <p>in what follows we show how this operation can be achieved in real time and with very low latency in the OPX.</p>"},{"location":"qm-qua-sdk/docs/Guides/demod/#effect-of-non-integer-demodulation-periods","title":"Effect of non-integer demodulation periods","text":"<p>In the previous section we assumed that \\(T\\) is such that we integrate over an integer number of periods. This greatly simplifies the analysis reduces errors in the demod operation. However, it is not always possible to arrange matters in this way. What happens when it is not an integer? Let's look at eq. \\(\\eqref{eq:i_and_q}\\) in this case. To simplify we calculate \\(M=I+iQ\\):</p> \\[ M = \\frac{2}{T}\\int_{t}^{t + T}a(\\tau)e^{-i\\omega \\tau}d\\tau \\\\   \\simeq s(t)e^{-i\\phi} - s(t)\\frac{i e^{-2i(\\omega t+\\phi)}}{2\\omega T}\\left(1-e^{-2i\\omega T}\\right) \\] <p>Here we see a very important characteristic of non-integer demodulation periods:</p> <p>Note</p> <p>When the demodulation length is not a half-integer number of periods, an error which scales as \\(\\frac{1}{\\omega T}\\) is present. If, in addition, the demodulation is performed at different starting times (without resetting the phase), this error will oscillate in a pseudo-random manner and will appear as repeatable noise when performing multiple demodulations in the same QUA program.</p> <p>If you wish to make this error constant, use the {func}<code>~qm.qua._dsl.reset_phase</code> QUA statement before measurement!</p>"},{"location":"qm-qua-sdk/docs/Guides/demod/#application-of-demod-for-dispersive-readout","title":"Application of demod for dispersive readout","text":"<p>In the case of cQED, the carrier is generated by us in the OPX, and after upconversion to a readout resonator frequency, is modulated by the response of the resonator, which contains information about the state of the qubit. The goal of the demodulation operation is to extract the state of the qubit.</p>"},{"location":"qm-qua-sdk/docs/Guides/demod/#demodulation-in-the-opx","title":"Demodulation in the OPX","text":""},{"location":"qm-qua-sdk/docs/Guides/demod/#mathematical-definition","title":"Mathematical definition","text":"<p>Here we explain the mechanism for the basic demodulation operation, <code>demod.full()</code> (see {ref}<code>meas-state-ref</code> for more advanced options).</p> <p>We first discuss the hardware implementation of the demodulation operation, and then discuss the timing of the different operations.</p> <p>For a given digitized waveform \\(a[n]\\), the mathematically precise definition of the demodulation operation performed in the OPX is</p> \\[ d = 2^{-12} \\sum_{n=0}^{N}a[n] \\left(w_c[\\lfloor n / 4 \\rfloor]\\cos(\\omega_{IF}t_s n + \\phi) + w_s[\\lfloor n / 4 \\rfloor]\\sin(\\omega_{IF}t_s n + \\phi)\\right). \\label{eq_digital} \\] <p>here \\(w_{s}[n]\\) and \\(w_{c}[n]\\) are sine and cosine integration weights of length \\(N = \\text{len}(w_{c,s})\\), \\(n\\) is the sample index relative to the start of the demodulation operation (see Fig. 2), \\(\\phi\\) is an intrinsic delay related to the hardware, and the meaning of the various other symbols is defined in the legend in Fig. 1. The \\(2^{-12}\\) is a factor used to scale the result for the OPX fixed point accuracy</p> <p>Note</p> <p>If we assume constant weights \\(w_{c}[n] = 1\\), \\(w_{s}[n] = 0\\), and a constant signal \\(a[n] = a \\cos(\\omega_{IF}t_s n)\\), then the result of the demod operation will be: \\(d = a N \\frac{\\cos(\\phi)}{2} 2^{-12}\\)</p> <p>If we define \\(a[n] \\simeq A\\cos(\\omega_{IF}t_s n + \\phi_0 + \\delta\\phi(t))\\), the similarity with eq. \\(\\eqref{eq_analog}\\) is clear.</p> <p>It is possible to calculate with the OPX the demodulation integral with extremely low latency and high precision. However, because the OPX is designed primarily for lowest-latency operation, the calculation uses fixed point arithmetic, and so care is needed when choosing the integration weights so that overflow will not occur during the demodulation. We discuss this next.</p>"},{"location":"qm-qua-sdk/docs/Guides/demod/#fixed-point-format","title":"Fixed point format","text":"<p>Fig. 1: Block diagram of demodulation operation in OPX. Numerical range corresponding to each fixed point format is given in the table below.</p> <p>Warning</p> <p>It is very important to make sure this section is well understood when using the demodulation operation, otherwise overflow may occur that will lead to corrupt results.</p> <p>To avoid overflow, follow these guidelines: : 1. The integration weights are such that when multiply the raw ADC data, scaled to between     -0.5 and 0.5, the result is between -2 and 2. 1. The sum of the multiplication above is smaller than \\(2^{16} = 65536\\)</p> <p>In Fig. 1 we see a breakdown of the demodulation operation in the equation above into steps, where the fixed point format in each step is shown. The translation from fixed point format to number ranges is given in the table below the figure. At each step, the input must be as shown to avoid overflow.</p> <p>Note that the fixed point format of the integration weights is optimized to be compatible with the dynamic range of the ADC (12 bits), and the precision allows for very long demodulation sequences at the price of losing accuracy.</p> <p>The notation used here for the fixed point is as follows: m.f - 'm' is the number of integer bits, including one for sign. 'f' is the number of fractional bits.</p> number format range of allowed values 11.15 \\([-1024:1024-\\epsilon:\\epsilon], \\epsilon = 2^{-15} \\simeq 3\\cdot 10^{-5}\\) 0.12 \\([-0.5:0.5-\\epsilon:\\epsilon], \\epsilon = 2^{-12} \\simeq 2.5\\cdot 10^{-4}\\) 2.19 \\([-2:2-\\epsilon:\\epsilon], \\epsilon = 2^{-19} \\simeq 2\\cdot 10^{-6}\\) 16.16 \\([-32768:32768-\\epsilon:\\epsilon], \\epsilon = 2^{-16} \\simeq 1.5\\cdot 10^{-5}\\) 4.28 \\([-8:8-\\epsilon:\\epsilon], \\epsilon = 2^{-28} \\simeq 4\\cdot 10^{-9}\\)"},{"location":"qm-qua-sdk/docs/Guides/demod/#timing-of-the-measurement-operation","title":"Timing of the measurement operation","text":"<p>Fig. 2: Block diagram from the ADC input to the processing unit. Note that the raw adc saved into a stream goes through a different route.</p> <p></p> <p>Fig. 3: Timing diagram for the measurement operation</p> <p>Warning</p> <p>The phase of the readout pulse IF carrier is not necessarily equal to the phase of the IF tone used in the demodulation, and may also change between versions. Therefore the demodulation results may slightly change between versions.</p> <p>So far we've discussed the demodulation operation in an isolated way. However, it occurs as a part of a measurement command that involves sending a pulse to the readout resonator, waiting some time, and then demodulating with the integration weights and possibly recording the raw ADC data. The parameters related to these timing operations are defined in the config, using the parameters:</p> <ul> <li><code>time_of_flight</code></li> <li><code>smearing</code></li> <li>length of the readout pulse</li> <li>length of integration weights</li> <li>high values of the digital recording pulse</li> </ul> <p>In the figure above we see how these parameters determine the timing of the measurement operation. Each waveform is represented schematically by a trapezoid. The red signals correspond to internal OPX signals, and the blue to actual analog waveforms. The relative timing of the operations is not to scale.</p> <p>The green background in (d) corresponds to the window at which ADC data is taken and multiplied with the integration weights (see eq. \\(\\eqref{eq_digital}\\)), and defines the \\(n=0\\) in that equation.</p> <p>The yellow background in (g) corresponds to the additional window for ADC recording provided by the <code>smearing</code> parameter in the config.</p> <p>We can see from the figure that the <code>time_of_flight</code> parameter has two uses: First, it determines the time from the beginning of the readout pulse and until the beginning of the integration operation (d) and secondly, it sets the start of the ADC recording window, up to <code>smearing</code>, in (g). It is also important to note that the demod window length is set solely by the length of the integration weights vector. The length of the raw ADC data recording window is set by the length of the readout pulse as well as the smearing parameter.</p> <p>Note</p> <p>The minimal <code>time_of_flight</code> is 24 ns. When using {ref}<code>time-tagging&lt;Guides/features:time tagging&gt;</code> this minimal time is 36 ns.</p>"},{"location":"qm-qua-sdk/docs/Guides/demod/#dual-demodulation","title":"Dual Demodulation","text":"<p>In addition to supporting demodulation of a single input signal, the OPX also supports demodulation of the two adc signals simultaneously. Using this feature, we can demodulate a complex signal given as an IQ pair, using a single demodulation operation. The syntax of a dual demodulation operation is as follows:</p> <pre><code>measure('meas_pulse', 'qe', strm, dual_demod.full('integ_w1', 'out1', 'integ_w2', 'out2', demod_res))\n</code></pre> <p>Note that all the outputs used in the demodulation process must be defined in the quantum element, e.g., 'out1' and 'out2' are both defined in 'qe' in the above example. Note also that 'integ_w1' and 'integ_w2' each contain two sets of weights, 'cosine' and 'sine'. The mathematical definition of the dual demodulation is</p> \\[\\begin{eqnarray} \\mathrm{variable} &amp;= \\sum_i s_{1i} \\left[ w_{c1}^i \\cos(\\omega_{IF} t_i + \\phi_F) + w_{s1}^i\\sin(\\omega_{IF} t_i + \\phi_F)\\right] \\nonumber \\\\               &amp;+ s_{2i} \\left[ w_{c2}^i \\cos(\\omega_{IF} t_i + \\phi_F) + w_{s2}^i\\sin(\\omega_{IF} t_i + \\phi_F)\\right] \\end{eqnarray}\\] <p>where \\(s_1\\) and \\(s_2\\) are the ADC streams of 'out1' and 'out2', accordingly, and \\(w_{c1}, w_{s1}, w_{c2}\\) and \\(w_{s2}\\) are the integration weights.</p> <p>Note</p> <p>Only full dual demodulation is currently supported. Running any vector demodulation, e.g., sliced, will result in an error.</p> <p>To motivate the use of this feature, we will now demonstrate IQ demodulation via dual demodulation. First, recall that an IQ signal passes through the following linear system to convert it to an intermediate frequency \\(\\omega_{IF}\\)</p> \\[ \\begin{pmatrix} \\tilde{I_i} \\\\ \\tilde{Q_i} \\end{pmatrix} = \\begin{pmatrix} \\cos(\\omega_{IF}t+\\phi_F) &amp; -\\sin(\\omega_{IF}t+\\phi_F)\\\\ \\sin(\\omega_{IF}t+\\phi_F) &amp; \\cos(\\omega_{IF}t+\\phi_F) \\end{pmatrix} \\begin{pmatrix} I_i \\\\ Q_i \\end{pmatrix}. \\] <p>After the up-conversion to \\(\\omega_{IF}\\), the complex signal enters an IQ mixer which outputs the fully modulated signal</p> \\[ \\text{signal} = \\tilde{I}\\cos(\\omega_{LO}t) + \\tilde{Q}\\sin(\\omega_{LO}t). \\] <p>This signal can also be realized as the real part of a complex signal</p> \\[ \\text{signal} = \\Re\\{(I+iQ)e^{i\\omega_{IF}}e^{i\\omega_{LO}}\\} = \\Re\\{(I+iQ)e^{i\\omega_{RF}}\\}, \\] <p>where \\(\\omega_{RF}=\\omega_{LO}+\\omega_{IF}\\) is the total signal frequency.</p> <p>Now, we wish to find the values of \\(I\\) and \\(Q\\), assuming for the sake of simplicity that the channel between the system output and system input is a simple loopback which does not change the signal, except for some arbitrary phase \\(\\phi_D\\).</p> <p>The incoming signal now passes through a down-conversion mixer which outputs two signals that enter the two ADCs</p> \\[\\begin{eqnarray} ADC1 &amp;=&amp; (\\tilde{I}\\cos(\\omega_{LO}t+\\phi_D) + \\tilde{Q}\\sin(\\omega_{LO}t+\\phi_D))\\cos(\\omega_{LO}t) \\\\       &amp;=&amp; \\frac{1}{2}(\\tilde{I}\\cos(\\phi_D) + \\tilde{I}\\cos(2\\omega_{LO}t+\\phi_D) + \\tilde{Q}\\sin(2\\omega_{LO}t + \\phi_D) - \\tilde{Q}\\sin(\\phi_D)). \\\\  ADC2 &amp;=&amp; (\\tilde{I}\\cos(\\omega_{LO}t+\\phi_D) + \\tilde{Q}\\sin(\\omega_{LO}t+\\phi_D))\\sin(\\omega_{LO}t) \\\\  &amp;=&amp; \\frac{1}{2}(\\tilde{Q}\\cos(\\phi_D) - \\tilde{Q}\\cos(2\\omega_{LO}t+\\phi_D) + \\tilde{I}\\sin(2\\omega_{LO}t + \\phi_D) + \\tilde{Q}\\sin(\\phi_D)). \\\\ \\end{eqnarray}\\] <p>Note</p> <p>The IQ mixers used for up and down conversions may emit signals with a \\(-\\frac{\\pi}{2}\\) phase difference instead of a \\(\\frac{\\pi}{2}\\) difference. i.e., an up conversion mixer will emit \\(\\text{signal}=\\tilde{I}\\cos(\\omega_{LO}t)-\\tilde{Q}\\sin(\\omega_{LO}t)\\).</p> <p>Next, recall that the ADCs are fit with a low-pass filter (LPF) that nullifies any frequencies above 500 MHz, ensuring no aliasing occurs in the sampling process. Specifically, the LPF cancels out all the high-frequency components of the mixers' output, leaving us with</p> \\[\\begin{eqnarray} ADC1 &amp;= \\frac{1}{2}(\\tilde{I}\\cos(\\phi_D) - \\tilde{Q}\\sin(\\phi_D)) \\\\ ADC2 &amp;= \\frac{1}{2}(\\tilde{Q}\\cos(\\phi_D) + \\tilde{I}\\sin(\\phi_D))  \\\\ \\end{eqnarray}\\] <p>Consequently, performing demodulation and estimating \\(I\\) and \\(Q\\) is done by passing the ADC output, given in IQ form (through two ports), through the inverse system in which we modulated our original complex signal</p> \\[ \\begin{pmatrix} \\cos(\\omega_{IF}t+\\phi_F) &amp; \\sin(\\omega_{IF}t+\\phi_F)\\\\ -\\sin(\\omega_{IF}t+\\phi_F) &amp; \\cos(\\omega_{IF}t+\\phi_F) \\end{pmatrix} \\begin{pmatrix} \\frac{1}{2}(\\tilde{I_i}\\cos(\\phi_D) - \\tilde{Q_i}\\sin(\\phi_D)) \\\\ \\frac{1}{2}(\\tilde{Q_i}\\cos(\\phi_D) + \\tilde{I_i}\\sin(\\phi_D)) \\end{pmatrix}. \\] <p>To rid ourselves of the dependency in the unknown input phase \\(\\phi_D\\), we perform a weighted sum, much like summing over multiple periods in single input demodulation. This operation can be done (separately for I and Q) in one dual demodulation operation by choosing the integration weights according to the inverse system. For example, if we wish to estimate the <code>I</code> component we simply choose \\(w_{c1} = 1, w_{s1} = 0, w_{c2} = 0, w_{s2} = 1\\). If we wish to estimate the 'Q' component, we will choose \\(w_{c1} = 0, w_{s1} = -1, w_{c2} = 1, w_{s2} = 0\\). Note that the sign of the sine weights, \\(w_{s1}, w_{s2}\\) may vary due to mixer configuration, time of flight, etc. Moreover, the integration weights may be better tuned according to the application and include matched filtering for non-constant pulses, mixer correction, etc.</p> <p>To further illustrate, we supply here a short QUA code with relevant configuration to perform IQ measurement using 2 dual demodulation statements -</p> <pre><code>w_plus = [(1.0, pulse_len)]\nw_minus = [(-1.0, pulse_len)]\nw_zero = [(0.0, pulse_len)]\nconfig['integration_weights']['cos']['cosine'] = w_plus\nconfig['integration_weights']['cos']['sine'] = w_zero\nconfig['integration_weights']['sin']['cosine'] = w_zero\nconfig['integration_weights']['sin']['sine'] = w_plus\nconfig['integration_weights']['minus_sin']['cosine'] = w_zero\nconfig['integration_weights']['minus_sin']['sine'] = w_minus\nwith program() as prog:\nI = declare(fixed)\nQ = declare(fixed)\nmeasure('readout', 'resonator', None,\ndual_demod.full('cos', 'out1', 'sin', 'out2', I),\ndual_demod.full('minus_sin', 'out1', 'cos', 'out2', Q))\nsave(I, 'I')\nsave(Q, 'Q')\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/demod/#rotating-the-iq-plane","title":"Rotating the IQ plane","text":"<p>There are cases in which we would want to rotate the IQ plane. For example, let us say that we have these IQ blobs of a qubit in the ground and excited state:</p> <p></p> <p>We can see that in its current form, the information about the state is encoded partly in I and partly in Q. The center of the blobs is at an angle <code>a</code>. If we rotate the IQ plane by an angle of \\(b = \\frac{\\pi}{2} - a\\) then all of the information will be encoded in the I quadrature, as can be seen here:</p> <p></p> <p>In order to perform the rotation, we would need to multiply the integration weights by a rotation matrix. This is illustrated in the example below:</p> <pre><code>w_plus_cos = [(np.cos(b), pulse_len)]\nw_minus_cos = [(-np.cos(b), pulse_len)]\nw_plus_sin = [(np.sin(b), pulse_len)]\nw_minus_sin = [(-np.sin(b), pulse_len)]\nconfig['integration_weights']['cos']['cosine'] = w_plus_cos\nconfig['integration_weights']['cos']['sine'] = w_minus_sin\nconfig['integration_weights']['sin']['cosine'] = w_plus_sin\nconfig['integration_weights']['sin']['sine'] = w_plus_cos\nconfig['integration_weights']['minus_sin']['cosine'] = w_minus_sin\nconfig['integration_weights']['minus_sin']['sine'] = w_minus_cos\nwith program() as prog:\nI = declare(fixed)\nQ = declare(fixed)\nmeasure('readout', 'resonator', None,\ndual_demod.full('cos', 'out1', 'sin', 'out2', I),\ndual_demod.full('minus_sin', 'out1', 'cos', 'out2', Q))\nsave(I, 'I')\nsave(Q, 'Q')\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/error/","title":"Messages and Errors","text":"<p>The following section describe how to manage the outputted level of messages to the console, as well as common runtime errors.</p>"},{"location":"qm-qua-sdk/docs/Guides/error/#messages-control","title":"Messages control","text":"<p>As part of the normal program flow, there are messages which are outputted into the python console. There are four different level of messages:</p> <ol> <li>Debug - Debug messages, off by default.</li> <li>Info - Normal OPX status, mainly when executing a program.</li> <li>Warnings - Important warnings, such as client version does not match server version.</li> <li>Errors - Error messages, usually compilation errors.</li> </ol> <p>It is possible to change the level which is outputted by using the following commands:</p> <pre><code>from qm.logging_utils import set_logging_level\nset_logging_level(level)\n</code></pre> <p>Where level can be either 'DEBUG', 'INFO', 'WARNING' or 'ERROR'.</p> <p>The commands above will work starting from . For earlier versions, please use:</p> <pre><code>from qm.logger import logger\nlogger.setLevel(level)\n</code></pre> <p>Note</p> <p>We do not recommend setting the level to 'ERROR', as important warning messages might be missed.</p> <p>Note</p> <p>The logger.setLevel command need to be called before opening the QuantumMachineManager</p> <p>Note</p> <p>It is possible to disable the output of the logger into the stdout by adding an environment variable named <code>QM_DISABLE_STREAMOUTPUT</code> to the OS</p>"},{"location":"qm-qua-sdk/docs/Guides/error/#runtime-errors","title":"Runtime Errors","text":"<p>When running a QUA program, run-time errors may occur. In this section we address all common error types and explain how they are handled. We also explain how to send error logs to QM for support and debugging purposes.</p> <p>Runtime errors can be indicated in one of two ways:</p> <ol> <li>When fetching results, if a runtime error occurred, a warning message will be printed</li> <li>by calling <code>QmJob.execution_report()</code> and querying its output.</li> </ol> <p>Below we outline different runtime error types and what do they mean.</p>"},{"location":"qm-qua-sdk/docs/Guides/error/#analog-output-overflow","title":"Analog output overflow","text":"<p>Indicates if the value played to an analog output at any sample is outside the range -0.5 to \\(0.5 - 2^{-16}\\), which causes an output overflow.</p> <p>Note</p> <p>It is possible for an overflow to occur with no indication. Therefore when in doubt, it always smart to double check using a scope or a simulation.</p>"},{"location":"qm-qua-sdk/docs/Guides/external_clock/","title":"External Clock","text":"<p>When we want to synchronize two or more OPX modules to one clock or use a clock other than the internal one, we may use an external clock source. Here we discuss the different ways to connect, distribute and configure external clock as well as its characteristics and limitations.</p>"},{"location":"qm-qua-sdk/docs/Guides/external_clock/#qop-external-clock-input-characteristics","title":"QOP External Clock Input Characteristics","text":"<p>The QOP can receive an external clock at three frequencies: 10, 100, and 1000MHz (1GHz). The clock input impedance must be 50\u03a9. The 10 or 100 MHz clock must have its peak-to-peak voltage be between 0.35 to 2.3 V (-5 to 11 dBm). The 1000 MHz clock must have its peak-to-peak voltage be between 0.45 to 1.25 V (-3 to 6 dBm).</p> <p>Note</p> <p>The external clock input is AC coupled</p>"},{"location":"qm-qua-sdk/docs/Guides/external_clock/#opt-external-clock-characteristics","title":"OPT External Clock Characteristics","text":"<p>The OPT distributes clocks across up to six systems. In addition, multiple OPTs can be chained to distribute clocks to more systems. It distributes a 1 GHz clock across devices. In the , it also synchronizes the connected systems.</p> <p>Let's define what they are and what are the optimal ranges of the for the OPT:</p> <ul> <li>Jitter is the timing variations of a set of signal edges from their ideal values. Jitters in clock signals are typically caused by noise or other disturbances in the system. Contributing factors include thermal noise, power supply variations, loading conditions, device noise, and interference from nearby circuits. The OPT output jitter is less than 100fs.</li> <li>Skew is a phenomenon in digital circuits where the same clock signal arrives at different components at different times due to gate or wire signal propagation delay. The instantaneous difference between the readings of any two clocks is called their skew. Skew can be caused by many different things, such as wire-interconnect length, temperature variations, variation in intermediate devices, capacitive coupling, material imperfections, and differences in input capacitance on the clock inputs of devices using the clock. As the clock rate of a circuit increases, timing becomes more critical, and less variation can be tolerated for the circuit to function correctly. The OPT skew between clocks is smaller than 20ps.</li> </ul> <p></p> <p>OPT Clock Output</p> Symbol Max Units Jitter 100 fs Skew 20 ps"},{"location":"qm-qua-sdk/docs/Guides/external_clock/#opx-connectivity","title":"OPX Connectivity","text":"<p>Note</p> <p>This is for a single OPX, for multiple OPXes, please connect your external clock to the OPT.</p> <p>Connect your clock output to the 'External Clock' port on the back panel of the OPX:</p> <p></p> <p>Some OPX back panels are slightly different, the connectivity then is as follows:</p> <p></p> <p>Important</p> <p>Some early back panels might have different labels. However, the correct labels are the ones shown on this page.</p>"},{"location":"qm-qua-sdk/docs/Guides/external_clock/#opx-connectivity_1","title":"OPX+ Connectivity","text":"<p>Note</p> <p>This is for a single OPX+, for multiple OPX+es, please connect your external clock to the OPT.</p> <p>Connect your clock output to the 'External Clock' port on the back panel of the OPX+:</p> <p></p>"},{"location":"qm-qua-sdk/docs/Guides/external_clock/#opt-connectivity","title":"OPT Connectivity","text":"<p>Connect your clock output to the 'Clk In' port on the back panel of the OPT.</p> <p></p>"},{"location":"qm-qua-sdk/docs/Guides/external_clock/#opx-clock-configuration","title":"OPX+ Clock Configuration","text":"<p>Access your OPX admin panel through the browser. On the settings page, you can see radio buttons to choose between internal and external clock.</p> <p></p> <p>After the frequency was chosen, click apply and wait for the system to restart with the new clock.</p> <p></p> <p>Important</p> <p>Changing the clock frequency will result in a system reboot</p>"},{"location":"qm-qua-sdk/docs/Guides/external_clock/#opx-clock-configuration_1","title":"OPX Clock Configuration","text":"<p>Log in to your OPX through the QMApp. On the main window you will see all the OPXes in that cluster. Press on the settings icon to go into the clock settings.</p> <p></p> <p>Pick a clock frequency and press apply. Now you can either restart the OPX for the change to occur immediately or restart later and continue working with the current clock configuration.</p> <p></p> <p>Important</p> <p>Changing clock frequency will result in a system reboot</p>"},{"location":"qm-qua-sdk/docs/Guides/external_trigger/","title":"External Triggering","text":"<p>Operations in QUA can be triggered by an external trigger in the form of a rising voltage received in the OPX trigger port on the back panel. The trigger can be used to control the timing of events in the program from an external source.</p>"},{"location":"qm-qua-sdk/docs/Guides/external_trigger/#basic-usage","title":"Basic Usage","text":"<p>The usage in QUA is via the <code>wait_for_trigger()</code> function. Basic usage of this feature is performed as follows:</p> <pre><code>wait_for_trigger(element)\n</code></pre> <p>For example, if we want to play a pulse on <code>qe1</code> after a trigger input, we can write:</p> <pre><code>wait_for_trigger('qe1')\nplay('qe1_pulse','qe1')\n</code></pre> <p>We can also specify a constant pulse to be played while the element is waiting for trigger.</p> <pre><code>wait_for_trigger('qe1', 'wait_pulse')\n</code></pre> <p>The pulse 'wait_pulse' will be played continuously until the arrival of the trigger signal.</p> <p>Note</p> <p>The external trigger port is sampled at a frequency of 250 MHz. Therefore, the temporal resolution is 4 ns.</p>"},{"location":"qm-qua-sdk/docs/Guides/external_trigger/#triggering-multiple-elements","title":"Triggering Multiple Elements","text":"<p>When we want to trigger multiple elements in the same controller, (i.e., same trigger signal), we can simply write multiple <code>wait_for_trigger()</code> commands. For example:</p> <pre><code>wait_for_trigger('qe1', 'wait_pulse')\nwait_for_trigger('qe2', 'wait_pulse')\n</code></pre> <p>Alternatively, and in case we don't want to play a wait pulse, we can use the <code>align()</code> command. For example:</p> <pre><code>wait_for_trigger('qe1')\nalign('qe1', 'qe2', 'qe3')\nplay('qe1_pulse','qe1')\nplay('qe2_pulse','qe2')\nplay('qe3_pulse','qe3')\n</code></pre> <p>In the example above, the three play commends will be executed together after the trigger. Note that any of the three elements can be placed in the <code>wait_for_trigger</code> command.</p> <p>If we want to pause the entire program until the trigger arrives, we can place an empty align.</p> <pre><code>wait_for_trigger('qe1')\nalign()\n</code></pre> <p>The program will be paused at this point until the trigger signal arrives.</p>"},{"location":"qm-qua-sdk/docs/Guides/external_trigger/#trigger-in-multiple-opxs","title":"Trigger in Multiple OPX's","text":"<p>In a system with \\(N\\) OPX's, there are essentially \\(N\\) trigger ports that can accommodate \\(N\\) separate trigger signals. However, each trigger signal can only trigger elements that are configured in the same OPX, i.e., where the elements has it's inputs. If we want a trigger signal to trigger elements in multiple controllers we can either use the align method. Alternatively, a digital output of one OPX can be used to trigger another OPX by directly connecting it to the other's trigger port.</p>"},{"location":"qm-qua-sdk/docs/Guides/external_trigger/#connectivity-in-the-opx","title":"Connectivity in the OPX","text":"<p>  The trigger in the OPX is connected as follows:</p> <p></p> <p>Some OPX back panels are slightly different, the connectivity is as follows:</p> <p></p> <p>Important</p> <p>The maximum allowed voltage is 1.8V. The threshold voltage level is 1.15V</p>"},{"location":"qm-qua-sdk/docs/Guides/external_trigger/#connectivity-in-the-opx_1","title":"Connectivity in the OPX+","text":"<p>  The trigger in the OPX+ (Version &gt; QOP200) is connected as follows and can accept up to 3.3V LVTTL.:</p> <p></p> <p>Important</p> <p>In OPX+ version 2.20, the external trigger is connected to the right-most AUX2 port. (labeled AUX3, in old back panels) In this version, the maximum allowed voltage is 1.8V and the threshold voltage level is 1.15V</p>"},{"location":"qm-qua-sdk/docs/Guides/features/","title":"QUA Language Features","text":"<p>This document describes QUA language features that go beyond the simple use-case described in the QUA overview section.</p> <p>For easier navigation we recommend using the table of contents to the left.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#measure-statement-features","title":"Measure statement features","text":"<p>The <code>measure()</code> command is a central command in QUA. It allows for the acquisition of ADC data corresponding to a readout pulse, its storage and processing. The raw ADC data can be processed in several ways, as explained below.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#demodulation","title":"Demodulation","text":"\\[ \\text{demod}(b,e)=2^{-12}\\sum_{i=b}^{e}\\left(W_{c}^{i}\\cos\\left(2\\pi f_{IF}t_{i}\\right)+W_{s}^{i}\\sin\\left(2\\pi f_{IF}t_{i}\\right)\\right)S_{i} \\] <p>where \\(W^{4k+p}_{s,c}=\\tilde{W}^{k}_{s,c} \\forall p\\in\\{0,1,2,3\\}\\)</p> <p>Note</p> <p>The \\(2^{-12}\\) is a factor used to scale the result for the OPX fixed point accuracy</p> <p>Types of demodulations:</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#full-demodulation","title":"Full demodulation","text":"<p>This is regular demodulation.</p> \\[ d_{full}=\\text{demod}(0,n-1) \\] <p>where \\(n\\) is the number of the total adc samples. The result is a fixed point value.</p> <p>Syntax:</p> <pre><code>measure([pulse], [element], [stream],\ndemod.full([integration_weights],[output_variable],[analog_output]),...)\n</code></pre> <p>Examples:</p> <pre><code>measure(\"readout\", \"RR\", None, demod.full(\"cos\", I, \"out1\"))\nmeasure(\"readout\", \"RR\", None, demod.full(\"cos\", I, \"out1\"), demod.full(\"sin\", Q, \"out1\"))\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#sliced-demodulation","title":"Sliced demodulation","text":"<p>The demodulation is sliced into chunks according to the formula below. Save the result in an array.</p> \\[ d_{sliced}\\left[i\\right]=\\text{demod}(i\\cdot 4\\cdot C,(i+1)\\cdot 4\\cdot C) \\] <p>where \\(C\\) is the chunk size in units of 4 ns.</p> <p>Illustration:</p> <p></p> <p>Syntax:</p> <pre><code>measure([pulse], [element], [stream],\ndemod.sliced([integration_weights],[output_array],[chunk_size],[analog_output]),...)\n</code></pre> <p>Examples:</p> <pre><code>A = declare(fixed, size=10)\nB = declare(fixed, size=4)\nC = declare(fixed, size=4)\nmeasure(\"readout\", \"RR\", None,\ndemod.sliced(\"cos\", A, 6, \"out1\")\n)  # The integration weights are, constant, of length 10*4*6 = 240\nmeasure(\"readout\", \"RR\", None,\ndemod.sliced(\"arb_integW\", B, 11, \"out1\"),\ndemod.sliced(\"sin\", C, 11, \"out1\")\n)  # Integration weights are length 4*4*11 = 176\n</code></pre> <p>Note</p> <ol> <li>chunk size is in units of 4ns.</li> <li>For arbitrary integration weights, chunk size must be bigger than or equal to 7</li> <li>Duration of integration weights must be 4 * <code>chunk_size</code> * <code>array_size</code></li> </ol>"},{"location":"qm-qua-sdk/docs/Guides/features/#accumulated-demodulation","title":"Accumulated demodulation","text":"\\[ d_{accumulated}\\left[i\\right]=\\sum_{j=0}^{i}\\text{demod}(j\\cdot 4\\cdot C,(j+1)\\cdot 4\\cdot C) \\] <p>where \\(C\\) is the chunk size in units of 4 ns.</p> <p>Illustration:</p> <p></p> <p>Syntax:</p> <pre><code>measure([pulse], [element], [stream],\ndemod.accumulated([integration_weights],[output_array],[chunk_size],[analog_output]),...)\n</code></pre> <p>Examples:</p> <pre><code>A = declare(fixed, size=10)\nB = declare(fixed, size=4)\nC = declare(fixed, size=4)\nmeasure(\"readout\", \"RR\", None, demod.accumulated(\"integW1\", A, 7, \"out1\"))\nmeasure(\"readout\", \"RR\", None,\ndemod.accumulated(\"arb_integW\", A, 11, \"out1\"),\ndemod.accumulated(\"sin\", A, 11, \"out1\")\n)\n</code></pre> <p>Note</p> <ol> <li>chunk size is in units of 4ns.</li> <li>For arbitrary integration weights, chunk size must be bigger than or equal to 7</li> <li>Duration of integration weights must be 4 * chunk_size * array_size</li> </ol>"},{"location":"qm-qua-sdk/docs/Guides/features/#moving-window-demodulation","title":"Moving window demodulation","text":"\\[ d_{movingWindow}\\left[i\\right]=\\sum_{j=max(i-W+1,0)}^{i}\\text{demod}(j\\cdot 4\\cdot C,(j+1)\\cdot 4\\cdot C) \\] <p>where \\(C\\) is the chunk size in units of 4 ns and \\(W\\) is the chunks_per_window.</p> <p>Illustration:</p> <p></p> <p>Syntax:</p> <pre><code>measure([pulse], [element], [stream], demod.moving_window([integration_weights],\n[output_array],\n[chunk_size],\n[chunks_per_window],\n[analog_output]),...)\n</code></pre> <p>Examples:</p> <pre><code>A = declare(fixed, size=10)\nB = declare(fixed, size=4)\nC = declare(fixed, size=4)\nmeasure(\"readout\", \"RR\", None, demod.moving_window(\"cos\", A, 5, 3, \"out1\"))\nmeasure(\"readout\", \"RR\", None,\ndemod.moving_window(\"arb_integW\", B, 7, 2, \"out1\"), demod.moving_window(\"sin\", C, 7, 2, \"out1\"))\n</code></pre> <p>!!! Note:</p> <pre><code>1. chunk size is in units of 4ns.\n2. For arbitrary integration weights, chunk size must be bigger than or equal to 7\n3. Duration of integration weights must be 4 * chunk_size * array_size\n4. Chunk size must be less or equal to array_size\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#integration","title":"Integration","text":"<p>The same as demodulation but at zero frequency, namely:</p> \\[ \\text{Integ}(b,e)=2^{-12}\\sum_{i=b}^{e}W_{c}^{i}S_{i} \\] <p>where \\(W^{4k+p}_{c}=\\tilde{W}^{k}_{c} \\forall p\\in\\{0,1,2,3\\}\\)</p> <p>Note</p> <p>The \\(2^{-12}\\) is a factor used to scale the result for the OPX fixed point accuracy</p> <p>Types of integrations:</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#full","title":"Full","text":"<p>syntax:</p> <pre><code>measure([pulse], [element], [stream],\nintegration.full([integration_weights],[output_variable],[analog_output]),...)\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#sliced","title":"Sliced","text":"<p>Syntax:</p> <pre><code>measure([pulse], [element], [stream],\nintegration.sliced([integration_weights],[output_array],[chunk_size],[analog_output]),...)\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#accumulated","title":"Accumulated","text":"<p>Syntax:</p> <pre><code>measure([pulse], [element], [stream],\nintegration.accumulated([integration_weights],[output_array],[chunk_size],[analog_output]),...)\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#moving-window","title":"Moving window","text":"<p>Syntax:</p> <pre><code>measure([pulse], [element], [stream],\nintegration.moving_window([integration_weights],[output_array],[chunk_size],[chunks_per_window],[analog_output]),...)\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#time-tagging","title":"Time tagging","text":"<p>The time-tagging feature populates a vector of time stamps that are associated with voltage edges typically generated by a single photon counting module (SPCM).</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#time-tagging-parameters","title":"Time-tagging parameters","text":"<p>A time-tag is generated when the voltage in the OPX analog input meets two conditions, one for the signal and one for the signal's derivative. The time tagger logic is as follows:</p> <ul> <li>A tag will be registered in the ADC sample where both conditions are met simultaneously.</li> <li>As long as both conditions are true, no new tags are registered.</li> <li>Once one of the conditions turns false, the tagger is \"armed\" again and a new tag can be registered.</li> <li>The next tag will be registered in the next ADC sample, where both conditions are true again.</li> </ul> <p>The time tagging parameters are set in a measuring element configuration.</p> <p>There are two conditions on the signal. One for the value and one for the derivative which are defined by the parameters <code>signalThreshold</code> and <code>signalPolarity</code>, and follow the following equation:</p> <p>For <code>signalPolarity</code> set to <code>'Above'</code>:</p> \\[ V(t) &gt; signalThreshold \\] <p>For <code>signalPolarity</code> set to <code>'Below'</code>:</p> \\[ V(t) &lt; signalThreshold \\] <p>Where \\(V(t)\\) is the measured voltage at time \\(t\\). Similarly, the condition on the signal derivative follows the same logic:</p> <p>For <code>derivativePolarity</code> set to <code>'Above'</code>:</p> \\[ \\dot{V(t)} &gt; derivativeThreshold \\] <p>For <code>derivativePolarity</code> set to <code>'Below'</code>:</p> \\[ \\dot{V(t)} &lt; derivativeThreshold \\] <p>For example, in the configuration block below, the element <code>spcm</code> has the time tagging parameters defined in the <code>outputPulseParameters</code> block.</p> <pre><code>'spcm': {\n\"singleInput\": {\n\"port\": ('con1', 1)\n},\n'operations': {\n'measure': 'measure_pulse'\n},\n\"outputs\": {\n'out1': ('con1', 1)\n},\n'time_of_flight': 180,\n'smearing': 0,\n'outputPulseParameters': {   # Time tagging parameters\n'signalThreshold': -500,\n'signalPolarity': 'Below',\n'derivativeThreshold': -2048,\n'derivativePolarity': 'Above'\n}\n},\n</code></pre> <p>Note that the condition on the derivative is chosen such that it will always be true. In that way, a time tag will be registered upon crossing the signal's threshold.</p> <p>The example above showcases a common usage of the time tagger as a voltage edge detector which would detect a falling edge through \\(~244 mV\\) (\\(-500/2048=-0.244\\)).</p> <p>For a gaussian input as shown below, the parameters above would detect the falling edge at \\(t=210 ns\\). If the <code>signalPolarity</code> would be changed to <code>Above</code>, the rising edge would be detected at \\(t=270 ns\\).</p> <p></p> <p>Note</p> <p>For most use-cases, we recommend setting the the <code>derivativeThreshold</code> and <code>derivativePolarity</code> as in the example above.</p> <p>Note</p> <p>Due to backwards compatibility, the parameter's values can also be <code>Ascending</code> for <code>Above</code> and  <code>Descending</code> for <code>Below</code></p> <p>Note</p> <p>If the <code>'outputPulseParameters'</code> dictionary is left empty, the default values are used. The user must supply all values, or none. The default values are as follows:</p> <pre><code>'outputPulseParameters': {\n'signalThreshold': 800,\n'signalPolarity': 'Below',\n'derivativeThreshold': 300,\n'derivativePolarity': 'Below'\n}\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#time-tagging-modes-usage","title":"Time-tagging modes &amp; usage","text":""},{"location":"qm-qua-sdk/docs/Guides/features/#basic-time-tagging","title":"Basic time-tagging","text":"<p>Basic time tagging has a resolution of 1ns with a dead time of 2ns. Time-tagging is done in a measure statement, with the following syntax:</p> <pre><code>counts = declare(int)\ntimes = declare(int, size=10)\nmeasure([pulse], [element], [stream], time_tagging.analog(times, [duration], counts)\n</code></pre> <ul> <li><code>times</code> is a vector of integers into which the times of the detected pulses are saved (in ns).</li> <li><code>max_time</code> gives the maximum time window, in ns, during which the statement waits for tag arrival.</li> <li><code>counts</code> is a variable that is populated with the number of tags which arrived during the measurement.</li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/features/#high-resolution-time-tagging","title":"High resolution time-tagging","text":"<p>  High resolution time tagging has a resolution \\&lt;50ps with a dead time of 84ns. Time-tagging is done in a measure statement, with the following syntax:</p> <pre><code>counts = declare(int)\ntimes = declare(int, size=10)\nmeasure([pulse], [element], [stream], time_tagging.high_res(times, [duration], counts)\n</code></pre> <ul> <li><code>times</code> is a vector of integers into which the times of the detected pulses are saved (in ps).</li> <li><code>max_time</code> gives the maximum time window, in ns, during which the statement waits for tag arrival.</li> <li><code>counts</code> is a variable that is populated with the number of tags which arrived during the measurement.</li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/features/#flow-control","title":"Flow control","text":""},{"location":"qm-qua-sdk/docs/Guides/features/#branching","title":"Branching","text":""},{"location":"qm-qua-sdk/docs/Guides/features/#if-elif-else","title":"If-Elif-Else","text":"<p>The simplest way to use branching is using the <code>if_</code> statement. Usage of the <code>if_</code> conditional is demonstrated in the code block below. Here, <code>op1</code> is played if <code>a</code> is larger than 1, <code>op2</code> is played if it's between -1 and 1, and <code>op3</code> is played if it is below -1. <code>a</code> is a <code>fixed</code> QUA variable in this case, which can be the result of a measurement or a classical computation.</p> <pre><code>with if_(a&gt;1):\nplay('op1', 'qe')\nwith if_(a&gt;=-1):\nplay('op2', 'qe')\nwith else_():\nplay('op3', 'qe')\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#switch-case","title":"Switch-Case","text":"<p>It is also possible to use a switch-case, as shown in the example below. Here, <code>op1</code> will be played if <code>a=1</code>, <code>op2</code> will be played if <code>a=2</code>, and <code>default_op</code> will be played otherwise. <code>a</code> is an <code>int</code> QUA variable in this case, which can be the result of a measurement or a classical computation.</p> <pre><code>with switch_(a):\nwith case_(1):\nplay('op1','qe')\nwith case_(2):\nplay('op2','qe')\nwith default_():\nplay('default_op','qe')\n</code></pre> <p>In the example below, the switch case is inside a QUA <code>for_</code> loop, which means that at each iteration of the loop, a different operation will be played.</p> <pre><code>with for_(j, 0, j &lt; 16, j + 1):\n...\nwith switch_(j):\nwith case_(1):\nplay('op1', 'qe')\nwith case_(2):\nplay('op2', 'qe')\nwith case_(3):\nplay('op3', 'qe')\n...\n...\n</code></pre> <p>This can be further simplified by wrapping the code with a Python <code>for</code> loop:</p> <pre><code>with for_(j, 0, j &lt; 16, j + 1):\n...\nwith switch_(j):\nfor i in range(16):\nwith case_(i):\nplay(f'op{i}', 'qe')\n...\n</code></pre> <p>There is an optional flag, <code>unsafe</code> that can be used to decrease the gaps that might be created when using switch-case inside a loop, such as in the example above. However, this flag cannot be used with <code>with default_():</code>, and in addition, if a value in the <code>switch</code> does not match any of the values in the <code>case</code>, unexpected behavior can occur.</p> <p>The usage can be seen in the following example:</p> <pre><code>with for_(j, 0, j &lt; 16, j + 1):\n...\nwith switch_(j, unsafe=True):\nfor i in range(16):\nwith case_(i):\nplay(f'op{i}', 'qe')\n...\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#conditional-play","title":"Conditional Play","text":"<p>It is also possible to add a condition directly in the <code>play</code> command. The pulse would only be played if the condition is evaluated to <code>True</code>. This would result in a quicker evaluation of the condition, compared to using an <code>if_</code>, and should be used when feedback latency is critical.</p> <pre><code>play('op', 'qe', condition=a &gt; 0)\n</code></pre> <p>Note</p> <p>If there is a digital pulse associated with the operation, it will always be played, regardless of the condition.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#ternary-operator","title":"Ternary Operator","text":"<p>The ternary operation can be used to quickly evaluate a condition to decide between two parameters, this would result in a quicker evaluation of the condition, compared to using an <code>if_</code>. In the example below, the duration of the pulse will be <code>c</code> if <code>a &gt; 0</code> otherwise it would be <code>d</code>. <code>c</code> and <code>d</code> can be either QUA variables, or constants.</p> <pre><code>assign(b, Util.cond(a &gt; 0, c, d))\nplay('op', 'qe', duration=Util.cond(a &gt; 0, c, d))\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#loops","title":"Loops","text":""},{"location":"qm-qua-sdk/docs/Guides/features/#for","title":"For","text":"<p>The QUA <code>for_</code> loop is similar to a python loop, having a <code>(var, start, end_cond, step)</code> structure. The following block of code plays a pulse five times, running over a QUA variable <code>t</code>, and uses it for the pulse duration.</p> <pre><code>t = declare(int)\nwith for_(t, 10, t &lt; 15, t+1):\nplay('pulse', 'qe', duration=t)\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#for_each","title":"For_Each","text":"<p>The QUA <code>for_each_</code> loop scans the variable through a predefined vector. This is a bit less efficient compared to the <code>for_</code> loop above, but can scan arbitrary points.</p> <pre><code>t_vec = [10, 15, 30]\nt = declare(int)\nwith for_each_(t, t_vec):\nplay('pulse', 'qe', duration=t)\n</code></pre> <p>It is possible to loop over a tuple of variables, similar to the <code>zip</code> style iteration in python:</p> <pre><code>t_vec = [10, 15, 30]\na_vec = [0.25, 1.0, 0.5]\nt = declare(int)\na = declare(fixed)\nwith for_each_((t, a), (t_vec, a_vec)):\nplay('pulse' * amp(a), 'qe', duration=t)\n</code></pre> <p>In both cases, 't_vec' and 'a_vec' can also be QUA arrays</p> <p>Note</p> <p><code>for_each_</code> loops are more resource intensive and unlike <code>for_</code> loops, have a maximum size.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#while","title":"While","text":"<p>The <code>while</code> loop is executed for as long as the condition is <code>True</code>. The following block of code plays a pulse 5 times.</p> <pre><code>N = declare(int,value=0)\nwith while_(N &lt; 5):\nplay('pulse','qe')\nassign(N, N + 1)\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#pause-resume-and-io-variables","title":"Pause, Resume and IO variables","text":"<p>QUA programs can be paused by using the <code>pause</code> QUA command. When a <code>pause</code> command is reached, the OPX completely halts the execution of the program until a <code>resume</code> command is sent using the QM <code>Job</code> API. This could be used to control an external device, such as an LO source. When the program is paused, data can be sent between the client PC and the real-time program using 2 available IO variables (Input/Output variables).</p> <p>The following examples shows basic communications between the client and QUA program using this <code>pause</code> and <code>resume</code> technique.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#setting-an-io-variable","title":"Setting an IO variable","text":"<p>In this QUA program, a <code>pause</code> precedes the <code>play</code> command, which plays a pulse with an amplitude dynamically set by an IO variable.</p> <pre><code>with program() as prog:\nN = declare(int)\na = declare(fixed)\nwith for_(N, 0, N &lt; 100, N + 1):\npause()\nassign(a, IO1)\nplay('pulse'*amp(a), 'qe')\n</code></pre> <p>When the <code>pause</code> command is encountered, the execution waits for a <code>resume</code> command, with usage as shown below:</p> <pre><code>job = qm.execute(prog)\ncurrent_vals = np.linspace(1e-3, 5e-3, 100)\nfor val in current_vals:\nwhile not job.is_paused():\ntime.sleep(0.001)\nqm.set_io1(val)\njob.resume()\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#reading-an-io-variable","title":"Reading an IO variable","text":"<p>IO values can also be used to extract information of a running program. For example, update to the LO frequency to some value calculated in real-time, in the OPX. The following example demonstrate such use case with an IO variable:</p> <pre><code>with program() as prog:\nrt_lo = declare(fixed)\n... # 1st part of the program including calculation for rt_lo\nassign(IO2, rt_lo)\npause()\n... # 2nd part of the program\n</code></pre> <p>In Python we can have a code block that iteratively checks the IO value and act upon that, for example:</p> <pre><code>job = qm.execute(prog)\nwhile not job.is_paused():\ntime.sleep(0.001)\nLO = get_io2_value()\n# do something with new LO\njob.resume()\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#relevant-apis","title":"Relevant APIs","text":"<p>See the following APIs for using IO variables:</p> <ul> <li><code>set_io1_value()</code></li> <li><code>set_io2_value()</code></li> <li><code>set_io_values()</code></li> <li><code>get_io1_value()</code></li> <li><code>get_io2_value()</code></li> <li><code>get_io_values()</code></li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/features/#input-streams","title":"Input streams","text":"<p>  Input streams allows passing data from the client computer to a running job in the OPX+ with minimal latency. To use one, you must first declare it in the QUA program using the [qm.qua._dsl.declare_input_stream[] command. The declaration is similar to the declaration of a normal QUA variable. You need to define its type (int, fixed, bool) it's name, and optionality, its size or values. Once declared, you can use it as you would use any other QUA variable, with the exception that you have two new available commands:</p> <ol> <li>Outside the QUA program, in Python, you can use <code>insert_input_stream()</code> from the job API to pass    data into the QUA program. Note that you can pass multiple values and later access them one by one in QUA.</li> <li>Inside the QUA program, you can use <code>advance_input_stream()</code> function to access the next available    data. If there is no available data, this command will pause the OPX and wait until data is available.</li> </ol> <p>Note</p> <p>The data inserted using <code>insert_input_stream()</code> must match the size of the input stream.</p> <p>For example:</p> <pre><code>with program() as example_input_stream:\ntruth_table = declare_input_stream(bool, name='truth_table_input_stream', size=10)\ntau = declare_input_stream(int, name='tau_input_stream')\n...\nwith while_(some_qua_cond):\nadvance_input_stream(tau)\nadvance_input_stream(truth_table)\nplay('operation', 'element0', duration=tau, condition=truth_table[0])\nplay('operation', 'element1', duration=tau, condition=truth_table[1])\nplay('operation', 'element2', duration=tau, condition=truth_table[2])\n...\n...\n...\njob = qm.execute(example_input_stream)\n...\nwhile some_cond:\nqubit_states = read_from_external_device()\ncalc_tau = calculate_tau()\njob.insert_input_stream('truth_table_input_stream', qubit_states)\njob.insert_input_stream('tau_input_stream', calc_tau)\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#sticky-element","title":"Sticky Element","text":"<p>A quantum element can be defined as sticky by adding the <code>hold_offset</code> key to its configuration. Once defined in this way, the last value played at the end of a pulse will be held until the next pulse begins. Then the values of the currently playing pulse will be added to the previously held value. A sticky element always ramps back to its DC offset value when the element has reached its final instruction of the program. This ramp can also be explicitly initiated by the <code>ramp_to_zero</code> function.</p> <p>Note</p> <p>The amplitude of sticky pulses is accumulated with a resolution of 16 bit. Therefore, N changes to the sticky pulse amplitude can result in an amplitude inaccuracy of about \\(N \\cdot 2^{-16}\\). To null out this accumulated error, it is recommended to use <code>ramp_to_zero()</code> from time to time.</p> <p>Alternatively, defining the amplitude of pulses of sticky elements to be in 16-bit resolution will prevent accumulated errors. When using <code>*amp()</code>, the last waveform sample multiplied by the scale factor should be in 16-bit resolution.</p> <p>An easy way to round in QUA would be to use bit-shifting</p> <pre><code>a = declare(fixed)\nassign(a, (a &gt;&gt; 12) &lt;&lt; 12)  # after this line, a will be rounded to 16-bit\n</code></pre> <p>The sticky element behavior is simply shown in the following example. We first define the quantum element as follows:</p> <pre><code>\"qe1\": {\n\"singleInput\": {\n\"port\": (\"con1\", 1)\n},\n'intermediate_frequency':0,\n'hold_offset':{'duration': 200},\n'operations': {\n'pulse': \"pulse\",\n},\n},\n\"qe2\": {\n\"singleInput\": {\n\"port\": (\"con1\", 1)\n},\n'intermediate_frequency':0,\n'operations': {\n'pulse': \"pulse\",\n},\n}\n</code></pre> <p>Note the <code>{'duration': 200}</code> which sets the ramp to zero duration, in clock cycles. We also define a second quantum element <code>qe2</code> which is not sticky.</p> <p>We can then run a simple program playing the same constant pulse twice, for the two different quantum elements:</p> <pre><code>with program() as prog:\nplay('pulse','qe1')\nwait(100,'qe1')\nplay('pulse','qe1')\nwait(100,'qe2')\nplay('pulse','qe2')\nwait(100,'qe2')\nplay('pulse','qe2')\n</code></pre> <p>The resulting pulse sequence is shown below, where the sticky element is in blue and the non-sticky element is in orange.</p> <p></p> <p>The duration of each pulse is 1000 samples, with the sticky element in blue maintaining its final value between its first and second play commands. Furthermore, the second pulse on the sticky element is added to the last pulse sample. At the end of the program, the blue trace is ramped to zero within 200 clock cycles, as defined in the configuration.</p> <p>Note</p> <p>The example above is for an element without an intermediate frequency. In case of an element with an intermediate frequency, the output will be a sine wave with the last amplitude.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#voltage-easing","title":"Voltage easing","text":"<p>A ramp to zero can be initiated on a sticky pulse at any point by calling the <code>ramp_to_zero(qe,duration)</code> function. The duration parameter is optional and can be used to override the configuration value. The waveform below was generated by running this program:</p> <pre><code>with program() as prog:\nplay('pulse','qe1')\nramp_to_zero('qe1',100)\nplay('pulse','qe1')\n</code></pre> <p></p> <p>Note the first pulse eases to zero at a double rate compared to the second one.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#ramp-pulse","title":"Ramp pulse","text":"<p>It's possible to generate a voltage ramp by using the <code>ramp(slope)</code> command. The <code>slope</code> argument is specified in units of <code>V/ns</code>. Usage of this feature is as follows:</p> <pre><code>play(ramp(0.0001),'qe1',duration=1000)\n</code></pre> <p>Note</p> <p>The pulse duration must be specified if the ramp feature is used.</p> <p>The <code>slope</code> can either be a literal (as shown above) or a QUA variable or expression. For example, consider the following snippet.</p> <pre><code>d=1000\nmax_v=0.35\nn=1000\nwith program() as myFirstProgram:\na = declare(fixed)\nwith for_(a, max_v/d/10, a &lt;= max_v/d, a +max_v/d/n):\nplay(ramp(a/2), 'qe1', duration=d)\nplay(ramp(-a/2), 'qe1', duration=d)\n</code></pre> <p>The quantum element <code>qe1</code> is defined as a sticky pulse and the resulting waveform is therefore triangular in each loop step as is shown in the image below.</p> <p>!!</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#frequency-chirp","title":"Frequency chirp","text":"<p>This feature allows to perform a linear sweep of the element's intermediate frequency in time. Chirp parameters can be updated in run-time, inside a QUA program.</p> <p>Basic usage of this feature is performed as follows:</p> <pre><code>play('pulse', 'qe', chirp=(rate, units))\n</code></pre> <p>Because the supported chirp rate spans many orders of magnitude, from mHz/sec to GHz/sec, it is defined by both a <code>rate</code> numeric variable and a <code>units</code> string. Supported units are (exactly) one of the following: 'Hz/nsec', 'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or their equivalent rates per-second: 'GHz/sec', 'MHz/sec', 'KHz/sec', 'Hz/sec', 'mHz/sec'. The rate itself is an integer, which can either be a QUA variable or a python literal.</p> <p>A spectrogram of a positive chirp rate followed by a negative rate is shown below. The chirp duration is defined by the duration of the used pulse.</p> <pre><code>with program() as prog:\n    chirp_rate = declare(int, value=25000)\n    play(\"pulse\", \"qe\", chirp=(chirp_rate , 'Hz/nsec'))\n    play(\"pulse\", \"qe\", chirp=(-25000, 'Hz/nsec'))\n</code></pre> <p></p> <p>It is possible to directly define a piecewise linear chirp by providing a list of rates as shown below. This is a convenient method to approximate non-linear chirp rates. In this case each chirp section will have the same duration, equal to the total pulse duration divided by the number of sections.</p> <pre><code>with program() as prog:\n    a = declare(int, value=[25000, 0, 50000, -30000, 80000])\n    play(\"pulse\", \"qe\", chirp=(a, 'Hz/nsec'))\n# equivalent program:\nwith program() as prog:\n    play(\"pulse\", \"qe\", chirp=([25000, 0, 50000, -30000, 80000], 'Hz/nsec'))\n</code></pre> <p></p>"},{"location":"qm-qua-sdk/docs/Guides/features/#non-uniform-chirp-sections","title":"Non-uniform chirp sections","text":"<p>A list of linear chirp rates can be specified at uniform intervals in time as shown above. You can also have non-uniform sections by passing a second list, giving the clock cycle number where the next chirp rate is set to start. This is shown in the example below:</p> <pre><code>rates = [199, 550, -997, 1396]\ntimes =[0, 15196, 25397, 56925]\nwith program() as prog:\nplay('pulse', 'qe', chirp=(rates,times, 'Hz/nsec'))\n</code></pre> <p></p>"},{"location":"qm-qua-sdk/docs/Guides/features/#mathematical-formulation-of-the-chirp","title":"Mathematical formulation of the chirp","text":"<p>The frequency in every piecewise linear section is given by:</p> \\[ f(t) = f_0 + \\alpha t \\] <p>Where \\(\\alpha\\) is the chirp rate, \\(t\\) is the time and \\(f_0\\) is the initial frequency.</p> <p>The accumulated phase is given by:</p> \\[ \\phi(t) = 2\\pi\\sum_{i=0}^{t}(f_0 + \\alpha t) = 2\\pi(f_0 t + \\frac{1}{2}\\alpha(t+1)t) \\] <p>Note that this discrete implementation of the chirp differs by one time-step from the continuous frequency chirp which yields</p> \\[ f(t) = 2\\pi (f_0t + \\frac{t^2}{2}\\alpha) \\]"},{"location":"qm-qua-sdk/docs/Guides/features/#continuous-chirp","title":"Continuous chirp","text":"<p>Note</p> <p>  The continuous chirp feature only exists in the OPX+</p> <p>It is possible to have the frequency chirp continue even after the pulse has stopped playing. This will cause the frequency to continue increasing in the background and continue during the next play commands. To use, add to the <code>play</code> command the kwargs <code>continue_chirp=True</code>, such as in the following example:</p> <pre><code>with program() as prog:\nplay(\"pulse\", \"qe\", chirp=(-25000, 'Hz/nsec'), continue_chirp=True)\nwait(100, \"qe\")  # Chirping continues in the background\nplay(\"pulse2\", \"qe\")  # Chirping continues, but stops after this pulse ends\nplay(\"pulse\", \"qe\", chirp=(-25000, 'Hz/nsec'), continue_chirp=True)\nplay(\"pulse2\", \"qe\", continue_chirp=True)  # Chirping continues\nplay(\"pulse3\", \"qe\", chirp=(25000, 'Hz/nsec'))  # Chirping changes to the value given and will stop after this pulse ends\n</code></pre> <p>This could be useful when combined with sticky elements, in which case the pulse will continue playing.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#crosstalk-matrix","title":"Crosstalk Matrix","text":"<p>Note</p> <p>  The crosstalk matrix only exists in the OPX+</p> <p>It is possible to add crosstalk terms between any ports in the same controller of the OPX. Adding a crosstalk term means that anything that comes out from a given port of the OPX will also come out of other ports of the OPX, with the given amplitude factor. The crosstalk is being applied before the Filters, which means that any filters applied on a port will only affect that specific port. This could be useful to correct for electronic crosstalk that exists between different control lines.</p> <p>Important</p> <p> Adding a crosstalk term to any port will delay all analog pulses coming out from all ports. The delay will be 8 cycles (32 ns). Starting from , it is possible to add the compilation flag <code>disable-crosstalk-matrix-ports-alignment</code> to only delay the ports which participate in the crosstalk matrix.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#usage-examples","title":"Usage Examples","text":"<p>The crosstalk terms can be configured at the OPX configuration file, with a different terms applied to each analog output in each controller. To configure, add a <code>crosstalk</code> term in the <code>analog_outputs</code> field:</p> <pre><code>'controllers': {\n'con1': {\n'analog_outputs': {\n1: {'offset': 0.0},\n2: {'offset': 0.0, 'crosstalk': {1: 0.2}},\n3: {'offset': 0.0, 'crosstalk': {1: -0.1}},\n},\n</code></pre> <p>In the example above, any pulse played to output number 1 would also come out from ports 2 &amp; 3 with an amplitude factor of 0.2 and -0.1 respectively, as seen in the following example:</p> <p>!!</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#pulse-memory-compression","title":"Pulse Memory Compression","text":"<p>In order to optimize memory allocation the QUA compiler takes into account the frequency content of each pulse. Each waveform's FFT is used to calculate the cutoff frequency f_cut under which 99.9% of the waveform's energy lies. Each waveform then receives a score based on its cutoff frequency <code>f_cut</code> and the waveform's length. The memory is then allocated to each waveform based on this score. The compiler also calculates the error between the original and interpolated waveforms and issues an error if it is larger than 1e-4:</p> <p>The user can add to the waveform the parameter <code>maxAllowedError</code>:</p> <pre><code># Setting the 'maxAllowedError' parameter to 1e-2 instead of the default\n'waveforms': {\n'wf1': {\n'type': 'arbitrary',\n'samples': [0.49, 0.47, 0.44, ...],\n'maxAllowedError': 1e-2\n},\n},\n</code></pre> <p>That will override the default value (1e-4) allowing the user to tweak memory allocation. Alternatively, the user can simply control the sampling ratio of the pulse:</p> <pre><code># Setting the 'maxAllowedError' parameter to 1e-2 instead of the default 1e-3\n'waveforms': {\n'wf1': {\n'type': 'arbitrary',\n'samples': [0.49, 0.47, 0.44, ...],\n'sampling_rate': 0.5e9\n},\n},\n</code></pre> <p>The <code>sampling_rate</code> parameter specifies the sampling rate in units of Samples/sec.</p> <p>Any time a pulse is compressed, the compiler will output a warning and the compression factor:</p> <pre><code>WARNING - Waveform wf_long was compressed with rate 0.6548853220189729 and error of 1.6128764990241962E-13\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#dynamic-pulse-duration","title":"Dynamic pulse duration","text":"<p>The duration of the pulse can stretched (but, in the case of an arbitrary waveform, not compressed) using the 'duration' parameter:</p> <pre><code># Stretching the pulse length\nplay(pulse, element, duration = 100)\n# One can also use a variable or an expression\nplay(pulse, element, duration = 2*t+100)\n</code></pre> <ul> <li>'duration' is given in clock cycles units.</li> <li>The stretched pulse is calculated from the original pulse using a 3rd order Lagrange interpolator on a 4 points running window.</li> </ul> <p>The 'duration' parameter can accept a general mathematical expression composed of operators (+, -, *, /), numbers, QUA variables and QUA functions (such as cos and sin).</p> <p>Warning</p> <p>When playing an arbitrary waveform, if the value of the duration parameter is set to below the original pulse length, corrupted output may occur.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#truncate-pulses","title":"Truncate pulses","text":"<p>Part of a pulse can be played by using the 'truncate' parameter:</p> <pre><code># Truncating the pulse length\nplay(pulse, element, truncate = 10)\n# One can also use a variable or an expression\nplay(pulse, element, truncate = 2*t+10)\n# It is possible to both stretch the pulse and truncate it\nplay(pulse, element, duration = 40, truncate = 10)\n</code></pre> <ul> <li>'truncate' is given in clock cycles units, with the minimum being 4 cycles.</li> <li>'truncate=n' will cause the first n cycles of the pulse to be played, this could be useful, for example, for exploring the dynamics of a qubit while a pulse is being played.</li> <li>If a pulse is given a dynamic duration, it will first be stretched to the given duration and then truncated.</li> </ul> <p>The 'truncate' parameter can accept a general mathematical expression composed of operators (+, -, *, /), numbers, QUA variables and QUA functions (such as cos and sin).</p> <p>Warning</p> <p>If the 'truncate' parameter is longer than the pulse duration, it'll cause unexpected results.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#dynamic-port-allocation","title":"Dynamic port allocation","text":"<p>It is possible to define an element with multiple inputs. At runtime, you can select to which port you want to play.</p> <p>To define such an element in the config, use the <code>singleInputCollection</code> dictionary item:</p> <pre><code>'aom_selector': {  # An example element that can play to either port 1 or 2\n\"singleInputCollection\": {\n\"inputs\": {\n\"row\": ('con1', 1),\n\"column\": ('con1', 2),\n}\n},\n'intermediate_frequency': 100e6,\n'hold_offset': {'duration': 200},\n'operations': {\n'pulse': \"pulse\",\n},\n},\n</code></pre> <p>At run time, use the <code>target</code> parameter of the <code>play()</code> command:</p> <pre><code>play('pulse', 'aom_selector', target='row')\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#multiple-inputs","title":"Multiple inputs","text":"<p>When playing a pulse, it is possible to output it from multiple ports simultaneously. This is done using the <code>multipleInputs</code> dictionary item:</p> <pre><code>'qubit': {\n'multipleInputs': # An example elemnt that will play from ports 1 and 2 simultaneously\n{\n'inputs': {\n'input1': ('con1', 1),\n'input2': ('con1', 2)}\n},\n'operations: {\n'const': 'const_pulse',\n},\n},\n</code></pre> <p>Using the <code>play</code> command:</p> <pre><code>with program() as prog:\nplay('const', 'qubit')\n</code></pre> <p>The pulse will then play to both port 1 and port 2 simultaneously, as seen in the figure below:</p> <p></p>"},{"location":"qm-qua-sdk/docs/Guides/features/#analog-delay","title":"Analog Delay","text":"<p>We can add a delay to the analog ports of up to 16 microseconds, in units of ns.</p> <p>To do so, simply specify the desired delay in the port's configuration. For example</p> <pre><code>'analog_outputs': {\n1: {'offset': 0.0, 'delay': 110},\n2: {'offset': 0.0, 'delay': 21},\n}\n</code></pre> <p>Here we specify a 110 ns delay for all signals coming out of port 1 and a 21 delay on all signals coming out of port 2.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#threads","title":"Threads","text":"<p>The maximum number of quantum elements that can be used simultaneously is limited by the number of processing threads in the hardware. A single-input quantum element requires one thread and a mixed input (IQ) element uses two threads, one for each channel. The OPX has \\(N_{threads}=10\\) threads and the OPX+ has \\(N_{threads}=18\\). By default, threads are not shared between different quantum elements. However, two (or more) quantum elements which are never played together can share a thread, as explained below. Sharing threads allow the user to define more quantum elements and write more complex programs.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#automatic-thread-allocation","title":"Automatic Thread Allocation","text":"<p>It is possible to add a flag when executing a QUA program that will enable the Automatic Thread Allocation. In order to enable it, use:</p> <pre><code>qm.execute(..., flags=['auto-element-thread'])\n</code></pre> <p>When the flag is set, the QUA compiler will automatically try to figure out which elements are never played together and these elements will share a thread. Since the code can be complicated and not deterministic, the compiler uses the <code>align</code> statement to know which quantum elements are playing in parallel and which are not. For example:</p> <pre><code>with program() as prog1:\na = declare(fixed)\nplay(\"marker\", \"qeDig\")\nplay(\"pulse\", \"qe2\")\nalign(\"qe2\", \"qeDig\")\nplay(\"marker\", \"qeDig\")\nwith for_(a, 0.2, a &lt; 0.9, a + 0.1):\nplay(\"pulse\" * amp(a), \"qe1\")\n</code></pre> <p>It seems that \"qeDig\" plays in parallel with both \"qe1\" and \"qe2\", but \"qe1\" and \"qe2\" never play in parallel. This means that \"qe2\" and \"qe1\" can share the same thread.</p> <p>Because the <code>align</code> statement is being used for the Automatic Thread Allocation, it is important to use it whenever possible.</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#manual-thread-allocation","title":"Manual Thread Allocation","text":"<p>It is also possible to manually assign the threads to the quantum elements, when defining them, in the following manner:</p> <pre><code>config = {\n...\n'elements': {\n'qe1': {\n\"thread\": \"a\",\n...\n},\n'qe2': {\n\"thread\": \"a\",\n...\n},\n'qe3': {\n\"thread\": \"b\",\n...\n},\n'qe4': {\n...\n},\n}\n...\n}\n</code></pre> <p>In the example above, \"qe2\" and \"qe1\" are assigned to thread \"a\" and can never run at the same time. \"qe3\" is being assigned to thread \"b\". Any quantum element which does not have a thread directly specified will have its own thread.</p> <p>Note</p> <p>If \"qe1\" has a two inputs (i.e. an IQ pair) it will actually be assigned two threads. If \"qe2\" has a single input, it will use one of the threads which is used by \"qe1\".</p> <p>If \"qe2\" and \"qe1\" will given a play command, they will be played one after the other and not at the same time. For example:</p> <pre><code>with program() as prog:\nplay(\"pulse1\", \"qe1\")\nplay(\"pulse2\", \"qe2\")\nplay(\"pulse3\", \"qe3\")\n</code></pre> <p>In the example above, \"qe1\" will be played first and only when it is done \"qe2\" will be played. Because \"qe3\" is on another thread, it will start immediately with \"qe1\".</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#oscillators","title":"Oscillators","text":"<p>In addition to limited threads, there is also a limited number of internal oscillators. The OPX has \\(N_{osc}=10\\) and the OPX+ has \\(N_{osc}=18\\). This limits the number of quantum elements with an intermediate frequency. However, it is possible to share oscillators between different elements. For information on how to define shared oscillators, see the configuration page.</p> <p>Sharing oscillators between elements shares their frequency, their frame and their mixer correction matrix. This means that any operation that affects these on any of the elements, would affect them all. In the following example, <code>qe1</code>, <code>qe2</code> and <code>qe3</code> share an oscillator:</p> <pre><code>with program() as prog:\nupdate_frequency(\"qe1\", 50e6)\nplay('const', 'qe2')  # Plays a 50 MHz pulse\nupdate_frequency(\"qe1\", 100e6)\nplay('const', 'qe2')  # Plays a 100 MHz pulse\nframe_rotation_2pi(\"qe3\", 0.5)\nplay('const', 'qe2')  # Plays a 100 MHz pulse, but with the frame rotated by pi\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/features/#precompile-jobs","title":"Precompile Jobs","text":"<p>It is possible to separate the compilation and the execution parts of running a job, which is useful when a job is repeated many times and the compilation run time is not negligible. To precompile a job, use the <code>compile</code> function:</p> <pre><code>program_id = qm.compile(program)\n</code></pre> <p>This will return a <code>program_id</code>, which can later be directly added to the <code>JobQueue</code>:</p> <pre><code>qm.queue.add_compiled(program_id)\n</code></pre> <p>This can be done many times with a program which has been compiled once.</p> <p>In addition, it is possible to change an analog waveform between runs using the <code>overrides</code> argument of the <code>add_compiled</code> function:</p> <pre><code>qm.queue.add_compiled(program_id, overrides={\n'waveforms': {\n'my_arbitrary_waveform': [0.02] * 1000,\n'my_constant_waveform': 0.2\n}\n})\n</code></pre> <p>An arbitrary waveform has to be declared as overridable in advance in the configuration file. For the example above:</p> <pre><code>'my_arbitrary_waveform': {\n'type': 'arbitrary',\n'is_overridable': True,\n'samples': [0.05] * 1000\n}\n</code></pre> <p>Note</p> <p>The number of samples in the new waveform has to be the same as in the old waveform. It is currently not possible to change the bandwidth of an overridable arbitrary waveform. Therefore the <code>samplingRate</code> and <code>maxAllowedError</code> properties are not supported when \"<code>is_overridable</code>: True\".</p>"},{"location":"qm-qua-sdk/docs/Guides/features/#compilation-options","title":"Compilation options","text":"<p>There are a few optional features and modification in the compilation process from QUA to the OPX low-level code. These options can be activated by passing a list of flags to the execution, compile or simulation commands as shown below:</p> <pre><code>qm.execute(prog, flags=['flag1', 'flag2'])  # execution\nqm.compile(prog, flags=['flag1', 'flag2'])  # compilation\nqmm.simulate(config, prog, SimulationConfig(duration), flags=['flag1', 'flag2']) # simulation\n</code></pre> <p>The following is a short list of optional flags and their description:</p> <ul> <li>'auto-element-thread' - Used when thread sharing is required. The compiler will automatically determine which elements can share a thread and allocate the resources accordingly. See further information here.</li> <li>'disable-filtered-ports-alignment' - Starting from version  on OPX+, this flag will disable the temporal alignment between analog ports that are filtered with a digital output filter and those that are not. This will reduce latency for unfiltered ports when using the filters. In addition, this flag will disable the automatic adjustment of the time-of-flight and digital delays parameters in the configuration. Read more about the latency in the output filter guide.</li> <li>'disable-crosstalk-matrix-ports-alignment' - Starting from version  on OPX+, this flag will disable the temporal alignment between analog ports that participate in the crosstalk matrix and those that are not. This will reduce latency for these ports when using the crosstalk matrix. In addition, this flag will disable the automatic adjustment of the time-of-flight and digital delays parameters in the configuration. Read more about the latency in the output filter guide.</li> <li>'skip-loop-unrolling' -  Disables an optimization over loop iterations. This gives faster compilation time at the cost of more program memory use and possibly more gaps.</li> <li>'skip-loop-rolling' - Disables another optimization over loop iterations. This gives faster compilation time at the cost of more program memory use.</li> <li>'not-strict-timing' -  Gaps within a <code>strict_timing_()</code> block will not block execution by raising warnings instead of errors. Read more about the strict timing feature here.</li> </ul> <p>For example, in the following code, we use the automatic thread allocation:</p> <pre><code>qm.execute(prog, flags=['auto-element-thread'])  # execution\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/multi-users/","title":"Job Queue and Multiple Users","text":"<p>The Quantum Orchestration Platform offers the ability for multiple users to work simultaneously. There are two possibilities for multiple users who wish to use the OPX together - Working with multiple quantum machine (hereafter, <code>qm</code>) instances or using the job queue.</p> <p>Important</p> <p>The subject is also relevant for a single user who wishes to work with multiple programs simultaneously.</p> <p>The following guide will describe the relevant considerations for when and how to use each method.</p>"},{"location":"qm-qua-sdk/docs/Guides/multi-users/#multiple-qms","title":"Multiple QMs","text":"<p>Working in the multi-<code>qm</code> method is advisable for multiple users who don't work on the same quantum system but would like to share the QOP. For example, it can be helpful when several setups are connected to the same QOP.</p> <p>In that case, each setup will have its unique configuration, and define its own <code>qm</code>.</p> <p>Once the multiple <code>qms</code> are open, the users can simultaneously and seamlessly execute programs on their <code>qm</code>, as long as there are enough resources. That means, for example, that the total number of threads in use across all programs can't exceed the total number of threads in the system.</p> <p>To use multiple <code>qms</code> simultaneously, each <code>qm</code> needs to have a unique configuration and they should not share ports. By default, opening a <code>qm</code> closes any existing <code>qms</code>. This has to be changed in order for multiple users to be able to work together. For example:</p> <pre><code>qmm = QuantumMachinesManager()\nconfig_1 = {...}\nconfig_2 = {...}\nqm1 = qmm.open_qm(config1, close_other_machines=False)\nqm2 = qmm.open_qm(config2, close_other_machines=False)\n</code></pre> <p>We can then send programs for execution on both <code>qms</code> regularly. At the end of the script, it is advisable to close the <code>qms</code>, using:</p> <pre><code>qm1.close()\nqm2.close()\n</code></pre> <p>Note</p> <p>If the users work on different client computers, each script will open its own <code>qm</code>.</p>"},{"location":"qm-qua-sdk/docs/Guides/multi-users/#multi-qms-with-shared-ports","title":"Multi-QMs with shared ports","text":"<p>In , multiple <code>qms</code> are allowed to share ports. The port sharing must be explicitly defined in both configurations. Sharing ports between <code>qms</code> allows two users (or two experiments) to access the resources, which could be useful for multiplexing or for monitoring. To enable port sharing, you need to add <code>\"shareable\": True</code> in the port's dictionary. For example:</p> <pre><code>'analog_outputs': {\n1: {'offset': 0.1, \"shareable\": True},\n},\n'analog_inputs': {\n1: {'offset': 0, \"shareable\": True},\n2: {'offset': 0},\n</code></pre> <p>Note</p> <p>Port sharing is possible between any number of multiple <code>qms</code>.</p> <p>Warning</p> <p>Sharing ports mean that one <code>qm</code> could interfere with the experiment running in another <code>qm</code> in multiple ways:</p> <ol> <li>Direct interference - For example, both <code>qms</code> applying operations on the same qubit.</li> <li>If both <code>qms</code> are playing at the same time, overflows might occur even if each <code>qm</code> by itself doesn't cause an overflow.</li> <li>A <code>qm</code> saving too much data (mostly ADC traces at a fast rate), could crash the QOP.</li> </ol>"},{"location":"qm-qua-sdk/docs/Guides/multi-users/#job-queue","title":"Job Queue","text":"<p>The queue system enables users to send multiple jobs to the orchestration platform, which are then run in turn. It provides tools to add and remove jobs from the queue as well as receive additional information such as the identity of the initiating user and the job start time.</p> <p>If several users wish to work with the same qm, then the job queue is the preferred method. For example, it can be useful when there's a single setup and several users would like to execute different programs on it, using a single configuration.</p> <p>Tip</p> <p>In addition, the job queue can be used to send pre-compiled programs to the <code>QOP</code>, enabling fast execution of repeated programs.</p>"},{"location":"qm-qua-sdk/docs/Guides/multi-users/#multiple-users-interaction-with-the-queue","title":"Multiple Users Interaction with the Queue","text":"<p>In the scenario of multiple users who wish to work with the job queue, one user will open a <code>qm</code> locally, and the rest will use it by getting a local instance from the <code>qmm</code>. For example, user #1 works on his script and opens a <code>qm</code>:</p> <pre><code>qmm = QuantumMachinesManager()\nqm = qmm.open_qm(config)\n&gt;&gt;&gt; qm.id\n&gt;&gt;&gt; 'qm-1658058752694'\n</code></pre> <p>Then, another user will work on his script, and access the \"active\" <code>qm</code>:</p> <pre><code>qmm = QuantumMachinesManager()\nqm_list =  qmm.list_open_quantum_machines()\nqm = qmm.get_qm(qmm_list[0])\n&gt;&gt;&gt; qm.id\n&gt;&gt;&gt; 'qm-1658058752694'\n</code></pre> <p>Both users now have a local instance of the same <code>qm</code> and can use the queue to send jobs.</p>"},{"location":"qm-qua-sdk/docs/Guides/multi-users/#adding-to-queue","title":"Adding to Queue","text":"<p>The queue is accessed by member functions of <code>QuantumMachine()</code>. The following adds a job to the queue:</p> <pre><code># Adding to the queue\nqm.queue.add(program)  # adds at the end of the queue\nqm.queue.add_to_start(program)  # adds at the start of the queue\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/multi-users/#inspecting-the-queue","title":"Inspecting the Queue","text":"<p>You can observe the queue and get the number of currently pending jobs as follows:</p> <pre><code>qm.queue.count  # number of items in the queue.\nlen(qm.queue) # same as count\n</code></pre> <p>The queue can be queried by either <code>job_id</code> or by position in queue. The queue is composed of instances of the <code>QmPendingJob()</code> object, so queries return such instances.</p> <p>Important note: The queue is 1-based</p> <pre><code>qm.queue.pending_jobs  # returns the list of jobs ids in the queue by the order they are in it (a list of QmPendingJob)\nqm.queue.get_at(position)  # returns a QmPendingJob object\nqm.queue[position] # the QmPendingJob at position\nqm.queue.get(job_id) # returns a QmPendingJob object\nqm.queue.get_by_user_id(user_id) # returns a QmPendingJob object\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/multi-users/#interacting-with-a-pending-job-object","title":"Interacting with a Pending Job Object","text":"<p>A pending job object allows access to its run state and other information. This, for example allows to perform a blocking wait until the job completes:</p> <pre><code>pending_job = qm.queue.get_at(2)\npending_job.user_added  # user who executed\npending_job.position_in_queue() # return the current position in the queue\npending_job.time_added  # when the job was added to the queue\npending_job.wait_for_execution()  # waits until the job is executed (or aborted) and returns a QmJob.\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/multi-users/#removing-pending-jobs-from-queue","title":"Removing Pending Jobs from Queue","text":"<p>Jobs can be removed from the queue by <code>job_id</code>, position or <code>user_id</code>. Note that any user can remove any job from the queue. There is no facility to protect jobs from accidental removal. Also note that removing a job by position in queue can be unpredictable as the position of jobs change with time and so calling the remove by position function may remove a different job to that intended.</p> <pre><code>pending_job = qm.queue[2]\npending_job.cancel()  # remove from the queue\n# Or\nqm.queue.remove_by_id(job_id)  # removes by the job_id\nqm.queue.remove_by_position(position)  # removes by the position in the queue. Might be dangerous because position can change during the request\nqm.queue.remove_by_user_id(user_id)  # removes all jobs that belong to the user\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/multi-users/#job-queue-api","title":"Job Queue API","text":"<p>See the job queue API for a full list of commands.</p>"},{"location":"qm-qua-sdk/docs/Guides/output_filter/","title":"Output filter","text":"<p>Note</p> <p>The output filters exist for both the OPX and the OPX+, but they behave differently. Some sections on this page are marked with  or , please make sure to check the one corresponding to your QOP</p>"},{"location":"qm-qua-sdk/docs/Guides/output_filter/#output-filter","title":"Output Filter","text":"<p>Each analog output port of the OPX/OPX+ is outfitted with a digital filter, which is applied before the DAC. This feature allows mitigation of the channel response between the DAC and the pulse destination. Using the output filter, we can attend to the unwanted effects of the different electrical components of the setup, e.g., mixers, amplifiers, bias-tees, etc., and do so without altering our waveforms. Furthermore, multiple waveforms can be played continuously with the filter operating on them as a single pulse. Once the filter is calibrated, we are free to design pulses without considering the channel setup, allowing for a more convenient workflow and seamless transfer of pulses between setups.</p> <p>Important</p> <p> Adding a filter to any port will delay all analog pulses coming out from all ports. The delay will be 12 cycles (48 ns) if only FIR filters are used. If IIR filters are used, the delay would be 13 cycles (52 ns). See more on the Delay Consequences below.</p> <p>Important</p> <p> Adding a filter to any port will delay all analog pulses coming out from all ports. The delay will be 11 cycles (44 ns) if only feed-forward taps are used. If feedback taps are used, the delay would be 12 cycles (48 ns) for a single tap, 15 cycles (60 ns) for two taps and 18 cycles (72 ns) for three taps. See Delay Consequences below for more details.</p>"},{"location":"qm-qua-sdk/docs/Guides/output_filter/#overview-of-the-filter-operation","title":"Overview of the Filter Operation","text":"<p>A general digital filter with input \\(x[n]\\) and output \\(y[n]\\) implements the following equation</p> \\[ y[n] = \\sum_{m=1}^M a_m y[n-m] + \\sum_{k=0}^K b_k x[n-k]. \\] <p>Where \\(\\{a_m\\}_{m=1}^M\\) is the set of feedback taps of the filter, and \\(\\{b_k\\}_{k=0}^K\\) is the set of feedforward taps. The number of feedback taps, \\(M\\), corresponds to the number of poles of the system; similarly, the maximum delay of the input \\(x[n]\\), \\(K\\), corresponds to the number of zeros of the system.</p> <p>In our case, \\(x[n]\\) and \\(y[n]\\) are the waveform and the output of the OPX, respectively, at timestamp <code>n</code>.</p> <p>Note</p> <p>In the field of Digital Signal Processing (DSP), a tap is simply a filter coefficient.</p> <p>In the frequency domain, the output/input relation is given by the filter's transfer function.</p> \\[ H(e^{j\\theta}) = \\frac{Y(e^{j\\theta})}{X(e^{j\\theta})} = \\frac{\\sum_{k=0}^K b_k e^{-jk\\theta}}{1 - \\sum_{m=1}^M a_m e^{-jm\\theta}} \\] <p>By meticulously choosing the filter taps, we can set the frequency response to compensate for undesirable effects of the channel. The choice of taps is left to the user to allow maximum flexibility.</p> <p>Note</p> <p>A filter consisting of only feed-forward taps is called a finite impulse response (FIR) filter. If feedback taps are used, the filter is called an infinite impulse response (IIR) filter.</p> <p>Note</p> <p>The feedforward taps can be multiplied by some arbitrary gain, reducing the magnitude of \\(H(\\theta)\\), while retaining its shape. This allows a simple method for gain reduction, which can later be compensated using an analog amplifier.</p> <p>Note</p> <p>It is possible to delay the output by <code>x</code> ns by increasing the indices of the feedforward taps by <code>x</code> \\(b_k \\rightarrow b_{k+x}\\).</p> <p>It is also possible to use the filters to add delays much smaller than 1ns, check the GitHub Repository for examples.</p>"},{"location":"qm-qua-sdk/docs/Guides/output_filter/#implementation-in-the-opx","title":"Implementation in the OPX","text":"Implementation in the OPX <p>The OPX output filter consists of one FIR filter with a varying length, as will be elaborated later, and one IIR filter with up to two taps. The signal flow is as shown in the image below:</p> <p></p> <p>The filter taps can be configured at the OPX configuration file, with a different configuration applied to each analog output in each controller. To configure, set <code>feedforward</code> and <code>feedback</code> under <code>filter</code> in the <code>analog_outputs</code> field:</p> <pre><code>'controllers': {\n'con1': {\n'analog_outputs': {\n1: {'offset': 0, \"filter\": {'feedforward': signal.windows.hann(25) * 0.1, 'feedback':[0.5, -0.3]}},\n},\n</code></pre> <p>To disable a filter, we simply omit it from the configuration or set it to an empty list in the following way:</p> <pre><code>'controllers': {\n'con1': {\n'analog_outputs': {\n1: {'offset': 0, \"filter\": {'feedforward': [], 'feedback':[]}},\n},\n</code></pre> <p>By setting the taps, the filter is automatically configured to one of the following modes:</p> <ul> <li>Bypass mode --- disables the filter and sets its output to be its input.</li> <li>FIR mode --- supports \\(M = 0\\) and \\(K = 39\\).</li> <li>IIR mode --- supports \\(M = 2\\) and \\(K = 24\\).</li> </ul> <p>The filter's output range is limited to its input range, which is [-0.5, 0.5). If the output exceeds this range, it is clipped to the nearest allowed value according to its sign.</p> <p>In order to avoid this saturation, we impose the following limitations on the values of the filter taps:</p> <ul> <li>all feedforward taps are limited to the range [-1,1]</li> <li>the first feedback tap is limited to the range (-2,2)</li> <li>the second feedback tap is limited to the range (-1,1)</li> </ul> <p>Additionally, we recommended the following guidelines:</p> <ul> <li>Set the feedback taps such that the received filter is stable. A simple method to verify this is to check that the roots    of the polynomial \\(p(z) = z^M + \\sum_{m=1}^M a_m z^{M-m}\\) are inside the unit circle, i.e., have a magnitude of less than \\(1\\).</li> <li>Set the absolute gain of the feedforward taps, defined to be \\(\\sum_{k=0}^K |b_k|\\), to be below \\(1\\).</li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/output_filter/#implementation-in-the-opx_1","title":"Implementation in the OPX+","text":"Implementation in the OPX+ <p>The OPX+ output filter consists of one FIR filter with varying length, as will be elaborated later, and 3 IIR filters, each with a single feedback tap. The filters are cascaded sequentially as shown in the following diagram, such that the output of one filter is the input of the next one. Note that the filters are applied after the Crosstalk Matrix.</p> <p></p> <p>The filter taps can be configured at the OPX configuration file, with a different configuration applied to each analog output in each controller. To configure, set <code>feedforward</code> and <code>feedback</code> under <code>filter</code> in the <code>analog_outputs</code> field:</p> <pre><code>'controllers': {\n'con1': {\n'analog_outputs': {\n1: {'offset': 0, \"filter\": {'feedforward': signal.windows.hann(25) * 0.1, 'feedback':[0.5, -0.3]}},\n},\n</code></pre> <p>To disable a filter, we simply omit it from the configuration or set it to an empty list in the following way:</p> <pre><code>'controllers': {\n'con1': {\n'analog_outputs': {\n1: {'offset': 0, \"filter\": {'feedforward': [], 'feedback':[]}},\n},\n</code></pre> <p>By setting the taps, the filter is automatically configured to one of the following modes:</p> <ul> <li>Bypass mode --- disables the filter and sets its output to be its input.</li> <li>FIR mode --- supports \\(M = 0\\) and \\(K = 43\\).</li> <li>IIR mode --- supports \\(M = 1, K=36\\), \\(M=2, K = 29\\) and \\(M=3, K = 22\\).</li> </ul> <p>Note</p> <p>The relation between the configured feedback taps and the aforementioned coefficients is given by convolution.</p> <p>The filter's output range is limited to its input range, which is [-0.5, 0.5). If the output exceeds this range, it is clipped to the nearest allowed value according to its sign.</p> <p>In order to avoid this saturation, we impose the following limitations on the values of the filter taps:</p> <ul> <li>all feedforward taps are limited to the range (-2,2)</li> <li>all feedback taps are limited to the range (-1,1)</li> </ul> <p>Additionally, we recommended that the absolute gain of the feedforward taps, defined to be \\(\\sum_{k=0}^K |b_k|\\), be below \\(1\\).</p>"},{"location":"qm-qua-sdk/docs/Guides/output_filter/#delay-consequences","title":"Delay Consequences","text":"<p>As emphasized above, adding a filter to any port will delay all analog pulses coming out from all ports and will also delay feedback operations.</p> <p>For advance use-cases, it is possible to remove the filter-related latencies from analog ports that are not filtered. This will disable the temporal alignment between the filtered and the non-filtered ports. When using the compilation flag <code>disable-filtered-ports-alignment</code>, the ports which are filtered will be delayed relative to the non-filtered ports according to each port's filter configuration.</p> <p>The delay values are:</p> <ul> <li> - 12 cycles (48 ns) if only FIR filters are used and 13 cycles (52 ns) if IIR filters are used.</li> <li> - 11 cycles (44 ns) if only FIR filters are used, 12 cycles (48 ns) if a single IIR filter is used, 15 cycles (60 ns) if two IIR filters are used and 18 cycles (72 ns) if all three IIR filters are used.</li> </ul> <p>We emphasize a few important consequences:</p> <ul> <li>The delayed readout pulse results in a longer time-of-flight. By default, The delay will be automatically and implicitly added to the time of flight value in the configuration. This compensation will re-ensure maximal overlap between the incoming readout pulse and the ADC acquiring window. Using 'disable-filtered-ports-alignment' flag will disable the automatic adjustment.</li> <li>In order to keep the digital pulses in sync with the analog pulses, the digital delay parameter is automatically updated accordingly. Using 'disable-filtered-ports-alignment' flag will disable the automatic adjustment.</li> <li>The delay associated with the IIR filters will be the full value stated above even when the FIR filter is not configured.</li> <li>When performing demodulation, the delayed readout pulse will change the global phase of the demodulated signal. This can be compensated by rotating the integration weights by \\(\\phi=-2\\pi*f_{IF}*\\Delta t\\), where \\(f_{IF}\\) is the intermediate frequency of the qubit and \\(\\Delta t\\) is the delay time. More information about rotating the IQ plane can be found here.</li> </ul> <p>In addition, the filters will also introduce a slight group delay to that port. This can be compensated by applying the appropriate filters on other ports. Scripts for finding filter taps can be found in our GitHub Repository.</p>"},{"location":"qm-qua-sdk/docs/Guides/phase_and_frame/","title":"Phase and Frame in QUA","text":"<p>This page will discuss the concepts of frame and phase, how they affect the OPX's output, and the API that relates to them, namely, the <code>reset_frame()</code> and <code>reset_phase()</code> commands.</p> <p>Every time we use the <code>play()</code> command on a specific element, the output pulse will have a total phase calculated from two separate contributions:</p> <ul> <li>The global phase associated with the rotating frame of the element, based on its intermediate frequency (IF) and time passed from the beginning of the sequence \\(t\\), \\(\\phi_G = \\omega_{IF}\\cdot t\\).</li> <li>The frame phase, \\(\\phi_F\\), which is the phase within the rotating frame. By default, \\(\\phi_F=0\\) but we can control it using the command <code>frame_rotation_2pi()</code> (It is also possible to use <code>frame_rotation()</code>, but not recommended).</li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/phase_and_frame/#global-phase","title":"Global Phase","text":"<p>Unless we actively change the global phase, \\(\\phi_G\\), pulses from different elements with the same intermediate frequency, will be phase matched with the same global phase. This is true, both if the intermediate frequency was defined in the configuration, or was updated during the sequence, using <code>update_frequency()</code>.</p> <p>There are a few ways in which the global phase associated with an element can be changed. Using the command <code>reset_phase()</code> we effectively define a constant phase \\(\\tilde{\\phi} = \\tilde{\\omega}_{IF}\\cdot \\tilde{t}\\), where \\(\\tilde{\\omega}_{IF}\\) is the intermediate frequency of the element, and \\(\\tilde{t}\\) is the time in which the command <code>reset_phase()</code> was applied. From that point forward the phase \\(\\tilde{\\phi}\\) is subtracted from the global phase of the element.</p> <p>Note</p> <p>This means that the global phase after the <code>reset_phase()</code> command will be \\(\\phi_G = \\omega_{IF}\\cdot t-\\tilde{\\omega}_{IF}\\cdot \\tilde{t}\\), where \\(\\tilde{\\omega}_{IF}\\) and \\(\\tilde{t}\\) are defined according to the last <code>reset_phase()</code> command used in the sequence. It is not possible to set \\(\\tilde{t}\\) back to zero after the <code>reset_phase()</code> command is used.</p> <p>Another command that will change the global phase is <code>update_frequency()</code>. When using the flag <code>keep_phase=True</code>, the phase of the pulse will be continuous through the frequency change, as can be seen in figure 1 indicated by the first dashed black line. The phase continuity results in a change to the global phase, \\(\\phi_G\\).   This change, however, is not tracked similarly to the phase change caused by <code>reset_phase()</code>, so if we update to the frequency with the flag <code>keep_phase=False</code> afterward, the global phase will be reevaluated from the beginning of the sequence (or the last phase reset), as can be seen in figure 1 indicated by the second dashed black line.</p> <p>Note</p> <p>Phase behavior of update_frequency</p> <p>By default <code>keep_phase=False</code>, in this case the phase of the signal \\(\\omega_{IF}t\\) after the frequency has been updated will change according to the rule:</p> \\[ \\omega_1 t_0 \\rightarrow \\omega_2 (t_0+\\Delta t) \\] <p>where \\(\\omega_1\\), \\(\\omega_2\\) are the frequencies before and after the transition, \\(\\Delta t\\) is the sampling rate and \\(\\rightarrow\\) signifies a transition from the sample \\(t_0\\) to the next.</p> <p>To maintain a continuous phase through the transition, use <code>keep_phase=True</code>. This will update the phase according to the rule:</p> \\[ \\omega_1 t_0 \\rightarrow \\omega_1 t_0 + \\omega_2 \\Delta t. \\] <p></p> <p>Fig. 1: The phase behavior when using update_frequency(), with the flag keep_phase = True and keep_phase = False. The black dashed line indicates when update_frequency() was used. The blue signal is the reference signal, and all operations are performed on the orange signal.</p>"},{"location":"qm-qua-sdk/docs/Guides/phase_and_frame/#frame-phase","title":"Frame Phase","text":"<p>The frame phase is constant in relation to the element's global phase, i.e., the phase in the rotating frame. At the beginning of a sequence, the frame phase is defined as \\(\\phi_F=0\\), and using the commands <code>frame_rotation()</code> and <code>frame_rotation_2pi()</code>, we can control \\(\\phi_F\\). The frame phase is separate from the global phase and is not affected by the element's intermediate frequency. Using the command <code>reset_frame()</code> we set the frame phase back to zero, \\(\\phi_F=0\\).</p> <p>Note</p> <p>Resetting the global phase will not reset the frame phase. So if we want to reset the total phase of an element to zero, we need to use both <code>reset_phase()</code> and <code>reset_frame()</code>.</p> <p></p> <p>Fig. 2: Simulation of the OPX+ output showing, a frame_rotation_2pi(0.5, element) - first dashed line, a reset_frame(element) - second dashed line, and reset_phase(element) - third dashed line. The blue signal is the reference signal, and all operations are performed on the orange signal.</p>"},{"location":"qm-qua-sdk/docs/Guides/phase_and_frame/#further-examples","title":"Further Examples","text":"<p>QUA code examples illustrating these concepts can be found in our GitHub Repository</p>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/","title":"Classical Computations in QUA","text":"<p>This section describes standard syntax rules for classical computations in QUA.</p>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#arithmetic-expressions","title":"Arithmetic Expressions","text":"<p>Multiplication, addition and subtraction of fixed point variables is supported.</p> <p>Note</p> <p>division incurs a computational overhead of approximately 400ns per operation.</p> Operator Symbol Example multiplication * a * b division / a / b addition + a + b subtraction - a - b <pre><code>with program() as prog:\na = declare(fixed)\nb = declare(int)\nc = declare(fixed, value=0.3)\nd = declare(fixed, value=-0.02)\ne = declare(int, value=3)\nf = declare(int, value=5)\nassign(a, c*d-d+c*0.25)\nassign(b, e+f*123*e-e)\nassign(c, d/c)\nsave(a, \"a\")\nsave(b, \"b\")\nsave(c, \"c\")\n</code></pre> <p>The evaluation of each operator takes only a few clock cycles. For example, the addition (+) and subtraction (-) operations each take 1 clock cycle to evaluate, i.e. 4ns. However, the compiler parallelizes operations, resulting in a much reduced effective calculation time which will often be zero.</p>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#bitwise-operations","title":"Bitwise Operations","text":"<p>Left/right bitshifts and bitwise AND, OR, and XOR are supported.</p> Operator Symbol Usage Example left bitshift &lt;&lt; a &lt;&lt; b 6\\&lt;\\&lt;5 = 192 right bitshift &gt;&gt; a &gt;&gt; b 6&gt;&gt;1 = 3 bitwise AND &amp; a &amp; b 6&amp;5 = 4 bitwise OR | a | b 6|5 = 7 bitwise XOR ^ a ^ b 6^5 = 3 <p>Note</p> <p>The bitwise NOT operation (~a) is not supported.</p>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#boolean-operations","title":"Boolean Operations","text":"<p>Boolean operations can be used, but using the operators below ('&amp;', '|', etc) and not with the Pythonic operators ('AND', 'OR', etc)</p> <p>Warning</p> <p>Attempting to use Pythonic operators on QUA variables, or attempting to evaluate QUA variables directly (for example, in a Pythonic '<code>if</code>' statement), would result in an error.</p> Operator Symbol Example AND &amp; a &amp; b OR | a | b XOR ^ a ^ b NOT ~ ~a <p>Compounded boolean expressions are supported.</p> <p>Note</p> <p>It is necessary to wrap the atomic boolean expressions in parenthesis as seen in the example below, due to Python operator precedence rules.</p> <p>Example:</p> <pre><code>with if_( (~( a &gt; b )) | ( c &gt; d) ):\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#arrays","title":"Arrays","text":"<p>QUA arrays are defined and accessed as follows.</p> <ol> <li>Declare a new array:</li> </ol> <p>syntax:</p> <p><code>declare(fixed/int/bool, size=N)</code></p> <p><code>declare(fixed/int/bool, value=[\u2026])</code></p> <p>Examples:</p> <pre><code>v1 = declare(int, size=3)\nv2 = declare(int, value=[1,2,3])\n</code></pre> <p>Note</p> <p>Specifying both the <code>size</code> and the <code>value</code> parameters is not supported.</p> <ol> <li>Access cell in array</li> </ol> <pre><code># syntax and examples\nassign(v1[0], 5)\nassign(b, v1[i]+6)\nassign(v1[i+5], v[i+4])\nsave(v1[2], \"v1_2\")\n</code></pre> <ol> <li>Get array length</li> </ol> <pre><code># syntax and examples\nlength = declare(int)\nassign(length, v1.length())\n</code></pre> <p>Use examples:</p> <pre><code>with program() as arrays_use:\nv1 = declare(int, value = [1, 2, 4, 8, 16])\nv2 = declare(int, size = 5) # will be initialized with zeros\nv3 = declare(fixed, size = 30)  # will be initialized with zeros\ni = declare(int)\nassign(v3[0], 16)\nwith for_(i, 0, i &lt; v2.length(), i + 1):\nassign(v2[i], i*2)\nwith for_(i, 0, i &lt; v1.length(), i + 1):\nassign(v2[i], v2[i] + v3[i])\nwith for_(i, 0, i &lt; v1.length(), i + 1):\nsave(v1[i], \"v1\")\nsave(v2[i], \"v2\")\nwith for_(i, 0, i &lt; v3.length(), i + 1):\nsave(v3[i], \"v3\")\n</code></pre> <p>Note</p> <p>Array length is fixed and cannot be changed after declaration.</p> <p>Note</p> <p>No validation is performed for reading/writing out of bounds. This will be added in a future version.</p>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#computational-library-functions","title":"Computational library functions","text":"<p>QUA allows the user the real time evaluation of several mathematical operators and functions. Besides the standard mathematical operators (+, -, *, /) the user can access various libraries including</p> <ul> <li>Math - trigonometric functions, array reduction functions etc.</li> <li>Random - pseudo-random number generation.</li> <li>Cast - allows casting between QUA variable types.</li> <li>Utility - Miscellaneous operators, including a hardware optimized conditional expression.</li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#math","title":"Math","text":"<p>For a full description, please see the Math library reference page.</p>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#trigonometric-functions","title":"Trigonometric functions","text":"<ul> <li><code>Math.cos(x)</code> : Take the cosine of a fixed in radians</li> <li><code>Math.sin(x)</code> : Take the sine of a fixed in radians</li> <li><code>Math.cos2pi(x)</code> : Take the cosine of a fixed in 2pi radians</li> <li><code>Math.sin2pi(x)</code> : Take the cosine of a fixed in 2pi radians</li> </ul> <p>cos2pi(x) and sin2pi(x) are equivalent to cos(2*pi*x) and sin(2*pi*x) but saves a few clock cycles as the extra multiplication stage required to calculate 2*pi are removed by simply having 2*pi stored in memory. Moreover, these function are immune to overflows. So whenever working with radians we suggest using the former. The usage is straightforward, for example:</p> <pre><code>amplitude = declare(fixed)\ntime = declare(int)frequency = declare(int)\nassign(amplitude, 1)assign(frequency, 1e6)\nwith for_(time, 0, time&lt;100, time+1):\nplay('pulse_1' * amp(amplitude*Math.cos2pi(frequency*time)), 'element_1')\n</code></pre> <p>This program will play <code>pulse_1</code> for 100 iterations, where for each iteration the amplitude will be modulated by the envelope function <code>cos(2pi *frequency *time)</code>. For evaluation of non-real time mathematical expressions one can always use standard python libraries such as numpy.</p>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#array-reduction","title":"Array reduction","text":"<p>QUA provides several function to reduce arrays. These functions run much more efficiently (with less latency) when compared to a manual implementing in QUA as they use hardware optimizations.</p> <ul> <li><code>Math.sum(x)</code> : sums an array. The result is of the same type as the input array.</li> <li><code>Math.max(x)</code>, <code>Math.min(x)</code> : max,min an array. The result is of the same type as the input array.</li> <li><code>Math.argmin(x)</code>/<code>Math.argmax(x)</code>: returns the index of the max/min</li> <li><code>Math.dot(x,y)</code>: returns the dot product of two QUA arrays of the same size</li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#others","title":"Others","text":"<ul> <li><code>Math.abs(x)</code> : absolute value of a QUA variable</li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#random-number-generator","title":"Random number generator","text":"<p>For a full description, please see the Random library reference page.</p> <p>This class generates a pseudo-random number using a the LCG algorithm with the following parameters: a = 137939405, c = 12345, m = 2**28.</p> <p>The class constructor optionally takes a seed number and can generate <code>int</code> or <code>fixed</code> values.</p> <p>Note</p> <p>Unless specified explicitly, the seed is selected in python using the RNG module. The seed choice occurs when the program object is created, which means that if we execute a QUA program object several times, the QUA random numbers sequence will be the same for all executions.</p> <pre><code>with program() as prog:\nr = Random()\na = declare(int)\nb = declare(fixed)\nassign(a, r.rand_int(100)) # a will be a number between 0 and 99\nassign(b, r.rand_fixed()) # b will be a number between 0.0 and 1.0\n# you can set the seed:\nr.set_seed(123213)\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#cast","title":"Cast","text":"<p>For a full description, please see the Casting library reference page.</p> <ul> <li><code>Cast.mul_fixed_by_int(x,y)</code>: Multiplies a fixed x by an int y, returning a fixed</li> <li><code>Cast.mul_int_by_fixed(x,y)</code>:  Multiplies an int x by a fixed y, returning an int</li> <li><code>Cast.to_int(x)</code>: Casts a variable to int. Supports int, fixed or bool</li> <li><code>Cast.to_fixed(x)</code>:  Casts a variable to fixed. Supports int, fixed or bool</li> <li><code>Cast.to_bool(x)</code>:  Casts a variable to bool. Supports int, fixed or bool</li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/qua_ref/#util","title":"Util","text":"<p>For a full description, please see the Utility library reference page.</p> <ul> <li><code>Util.cond(a,b,c)</code> : Quick conditional operation.</li> </ul> <p>This is equivalent to a ternary operator available in some languages: i.e. a ? b : c, meaning 'b' if 'a' is true, or 'c' if 'a' is false. There is less computation overhead (less latency) when running this operation relative to the <code>if_</code> conditional</p> <pre><code>assign(b, Util.cond(a &gt; b, c, d))\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/simulator/","title":"OPX Simulator","text":"<p>The simulator is a useful tool to predict and verify the exact output of the OPX for a given QUA program. It also supports feeding input to measurement commands via a simulated loopback interface.</p> <p>The simulator returns the samples that will be played to the analog and digital ports.</p>"},{"location":"qm-qua-sdk/docs/Guides/simulator/#usage","title":"Usage","text":"<p>By calling the <code>simulate()</code> function from the QuantumMachinesManager object (<code>qmm</code>). This function should receive the configuration and program that are desired for simulation, and a <code>SimulationConfig()</code> object, whose API is specified in the following section.</p> <p>For examples, to simulate a program for 10 us (2500 cycles) we would use:</p> <pre><code>simulated_job = qmm.simulate(config, prog, SimulationConfig(2500))\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/simulator/#loopbackinterface","title":"LoopbackInterface","text":"<p>It is possible to simulate a connection from an output of an OPX to one of the two inputs. This is done by using the <code>LoopbackInterface()</code> which is passed to the <code>simulate()</code> method of the <code>qmm</code> object. For example, the following code generates a virtual connection from output 1 to input 2 of controller 1.</p> <pre><code>qmm.simulate(config, prog, SimulationConfig(duration, simulation_interface=LoopbackInterface([(\"con1\", 1, \"con1\", 2)]))\n</code></pre> <p>A list of two such tuples can be passed to the <code>LoopbackInterface()</code> per simulated controller (as there are two inputs to the OPX).</p> <p>Moreover, it is possible to also simulate signal propagation delay and noise using the <code>noisePower</code> and <code>latency</code> keywords in the <code>LoopbackInterface()</code></p> <ul> <li><code>noisePower</code> adds gaussian noise with zero mean and a variance (in units [\\(V^2\\)]) set by this parameter.</li> <li><code>latency</code>  adds a signal propagation delay in [ns] set by this parameter</li> </ul> <p>For example, the following adds noise with variance 1 \\(V^2\\) and 100 ns latency. All tuples in the loopback interface will have the same noise figure and same latency.</p> <pre><code>qmm.simulate(config, prog, SimulationConfig(duration, simulation_interface=LoopbackInterface([(\"con1\", 1, \"con1\", 2)], noisePower=1, latency=100))\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/simulator/#raw-adc-interface","title":"Raw ADC interface","text":"<p>It is possible to explicitly specify the signal passed into the OPX in the simulation. This is quite similar to the LoopbackInterface described above and supports the same options.</p> <p>For example, the code snippet below plays a 1 microsecond signal to input 1 of the device called \"con1\".</p> <pre><code>signal = np.linspace(0, 0.2, 1000).tolist()\nqmm.simulate(config, prog, SimulationConfig(duration, simulation_interface=RawInterface([(\"con1\",1,signal)], noisePower=1, latency=100))\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/simulator/#api","title":"API","text":"<p>See the simulator API page in the API reference section for more details.</p>"},{"location":"qm-qua-sdk/docs/Guides/simulator/#examples","title":"Examples","text":"<p>The following are 3 example of simulating simple QUA programs. The configuration is currently not provided.</p> <pre><code>    from qm.QuantumMachinesManager import QuantumMachinesManager\nfrom qm import SimulationConfig\nfrom qm import LoopbackInterface\nfrom qm.qua import *\nimport matplotlib.pyplot as plt\nqmm = QuantumMachinesManager()\n##\n# ## Example 1 - No inputs\nwith program() as prog1:\na = declare(fixed)\nc = declare(fixed, value=0.4)\nwith for_(a, 0.2, a &lt; 0.9, a + 0.1):\nplay(\"const\" * amp(a), \"qe1\")\nsave(c, \"c\")\n# simulate program\njob = qmm.simulate(config, prog1, SimulationConfig(\nduration=500,                    # duration of simulation in units of 4ns\n))\n# get DAC and digital samples\nsamples = job.get_simulated_samples()\n# plot all ports:\nsamples.con1.plot()\n# get results\nres = job.result_handles\nc = res.c.fetch_all()\nprint(c)\n##\n# ## Example 2 - Loopback inputs\nlen_a = len(np.arange(0.1,0.45,0.1))\nlen_f = len(np.arange(50e6,60e6,1e6))\nwith program() as prog2:\nI = declare(fixed)\nQ = declare(fixed)\nI_stream = declare_stream()\nQ_stream = declare_stream()\nadc_stream = declare_stream(adc_trace=True)\nf = declare(int)\na = declare(fixed)\nwith for_(a, 0.1, a &lt; 0.45, a + 0.1):\nwith for_(f, 50e6, f &lt; 61e6, f + 1e6):\nupdate_frequency(\"qe1\", f)\nmeasure(\"readout\"*amp(a), \"qe1\", adc_stream, demod.full('cos', I), demod.full('sin', Q))\nsave(I, I_stream)\nsave(Q, Q_stream)\nwait(100)\nwith stream_processing():\nI_stream.buffer(len_f).buffer(len_a).save('I')\nQ_stream.buffer(len_f).buffer(len_a).save('Q')\nadc_stream.input1().save_all('adc')\n# # simulate program\nsimulated_job = qmm.simulate(config, prog2, SimulationConfig(\nduration=40000,\nsimulation_interface=LoopbackInterface([(\"con1\", 1, \"con1\", 1)])    # loopback from output 1 to input 1\n))\n# get results\nres = simulated_job.result_handles\nadc = res.get('adc').fetch_all()['value'][0]  # fetch first measurement\nI = res.get('I').fetch_all()\nQ = res.get('Q').fetch_all()\nplt.figure()\nplt.plot(adc)\nplt.xlabel(\"Time [ns]\")\nplt.ylabel(\"ADC\")\nplt.figure()\nplt.plot(I, Q, '.')\nplt.xlabel(\"I\")\nplt.xlabel(\"Q\")\n##\n# ## Example 3:\nwith program() as prog3:\nd = declare(int)\nwith for_(d, 10, d &lt;= 100, d + 10):\nplay(\"const\", \"qe1\")\nplay(\"const\", \"qe2\", duration=d)\nwait(50)\n# simulate program\njob = qmm.simulate(config, prog3, SimulationConfig(\nduration=1700,                  # duration of simulation in units of 4ns\n))\n# get DAC and digital samples\nsamples = job.get_simulated_samples()\n# plot analog ports 1 and 3:\nsamples.con1.plot(analog_ports={'1', '3'}, digital_ports={})\n# another way:\n# plt.figure()\n# plt.plot(samples.con1.analog[\"1\"], \"-\")\n# plt.plot(samples.con1.analog[\"3\"], \"--\")\n# plt.legend((\"analog 1\", \"analog 3\"))\n# plt.xlabel(\"Time [ns]\")\n# plt.ylabel(\"Signal [V]\")\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/stream_proc/","title":"Stream Processing","text":"","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#overview","title":"Overview","text":"<p>When saving data from a QUA program, it is first saved on the OPX on-board memory. From there, it's transferred to the server and eventually to the user PC. Stream processing provides the capability to process data as it is being transferred to the QM server. This both reduces the amount of data that has to be saved on the user PC, as well as the post-processing computation time.</p> <p></p> <p>Consider, as a simple example, a case where we would like to characterize the success rate of preparing a qubit in the \\(|1 \\rangle\\) state. We want to play the pulse, read-out the qubit's state and decide whether it is a \\(|1\\rangle\\) or a \\(|0\\rangle\\). We then repeat this a large number of times, say \\(1 \\times 10^5\\). Collecting the results of all \\(10^5\\) experiments is not so interesting. Instead, we can  only collect the final average of the set of experiments or how this average develops as data is accumulated.</p> <p>A running average is a straightforward example, but many other manipulations are possible. The \"stream processing\" allows for arithmetic operations and data reshaping to occur on server, in parallel to OPX experimental runs.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#basic-syntax-and-examples","title":"Basic Syntax and Examples","text":"<p>To use the server processing feature, a stream must be defined. A stream consists of a stream variable, a pipeline and a terminal. The processed stream items can be accessed on the client PC, where they are referred to as results, by creating result handles on the client PC. In what follows, we introduce each of these components and explain how they are used.</p> <p>To initiate a stream, we declare a stream variable, using the following syntax inside a QUA program:</p> <pre><code>my_stream = declare_stream()\n</code></pre> <p>To pass a variable to a stream, we use the <code>save()</code> statement or the <code>measure()</code> statement. This creates a data transfer path through which stream items are processed and then saved to either a permanent or overriding storage (see Glossary for more details).</p> <p>To illustrate how pipelines and terminals are created and used, we show below a full QUA program which saves data to a stream, manipulates it and stores the results to terminals. In addition you can take a look at a few examples in our GitHub library</p> <pre><code>with program() as prog:\nmy_stream1 = declare_stream(adc_trace=True)\nmy_stream2 = declare_stream()\na = declare(fixed)\nassign(a, 0.3)\nsave(a, my_stream2)\nmeasure('my_pulse', 'qe', my_stream1)\nwith stream_processing():\nmy_stream1.input1().with_timestamps().save('adc_results')\nmy_stream2.save_all('a_results')\n</code></pre> <p>Here two streams are created. The first, <code>my_stream1</code>, is used to stream raw ADC samples. The second, <code>my_stream2</code>, is used to stream the value of the QUA variable <code>a</code>.</p> <p>The pipelines and terminals are defined under the <code>with stream_processing()</code> context. Pipelines initiate with a stream variable and terminate with a <code>save()</code> or <code>save_all()</code> function, which acts as a terminal. In this example the pipelines are simple: The first selects only the data from analog input1 and adds timestamps to it. The second is immediately terminated.</p> <p>The terminal used for the pipeline initiated with <code>my_stream1</code> is a Save terminal. This is a memory-less terminal that holds only the last value transferred - this can result in data loss if data is not fetched quickly enough from the client PC. The terminal is given the tag <code>'adc_results'</code>, which can later referenced using a result handle. The terminal for <code>my_stream2</code> is a <code>save_all</code> terminal which does store all the results (up to a memory limitation, see Server PC storage and data limitations). The tag for this terminal is <code>'a_results'</code>.</p> <p>To access the results on the client PC side, we create a Result handle. This allows us to retrieve (\"fetch\") the stream items on the client PC side, or to perform other query or storage operations on it. To continue our example:</p> <pre><code>job = qm.execute(prog)\nres = job.result_handles\nmy_stream_res = res.adc_results.fetch_all()['value']\n</code></pre> <p>This example collects all results which were contained in the stream using the <code>fetch_all()</code> method. Alternatively, we can only get the most recent result by calling the <code>fetch()</code> method. Note that both these method are called on a result handle. This structure and its usage are described below.</p> <p>Note</p> <p>It is still possible to use the syntax from previous versions for creating a stream that is only terminated using <code>save_all()</code>. The following examples are equivalent:</p> <pre><code>with program() as prog:\nmy_stream = declare_stream()\na = declare(fixed)\nassign(a, 0.3)\nsave(a, my_stream)\nwith stream_processing():\nmy_stream.save_all('a_results')\n</code></pre> <pre><code>with program() as prog:\na = declare(fixed)\nassign(a, 0.3)\nsave(a, 'a_results')\n</code></pre> <p>Warning</p> <p>Saving values to the same stream from different OPXs is not supported.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#streaming-raw-adc-results","title":"Streaming raw ADC results","text":"<p>The following is a simple example of a program that acquires a single raw ADC trace:</p> <pre><code>with program() as prog:\nadc_stream = declare_stream(adc_trace=True)\nmeasure('my_pulse', 'qe', adc_stream)\nwith stream_processing():\nadc_stream.input1().save('raw_adc')\n</code></pre> <p>By setting <code>adc_trace=True</code> we specify that data should be grouped into individual ADC traces and not passed on a sample-by-sample manner, such that each trace will be of size <code>(1, measurement_duration)</code>. Next, to populate the stream with results, we specify the relevant stream in the <code>measure</code> statement. Finally, in the <code>stream_processing</code> context, the pipeline specifies that we acquire data from analog input 1, and save it with the tag <code>raw_adc</code> which we can later refer to in the client PC.</p> <p>Note</p> <p>Setting <code>adc_trace=True</code> is equivalent to writing <code>stream.buffer(pulse_len + 2*smearing)</code>. See details on buffer below and here on smearing</p> <p>To record a raw ADC stream, it is required to play a digital marker that is associated with the measurement element. Only samples that arrive while the digital trigger is on will be recorded in the stream pipeline. This means it is possible to \"gate\" the raw ADC stream by using different sequences of digital waveforms in the readout operation used for the <code>measure()</code> command.</p> <p></p> <p>Fig. 1: The raw ADC stream. The blue line is the raw ADC stream when the digital trigger is on for the entire measurement. The orange dots are the raw ADC samples when the digital trigger is switched on/off every eight samples.</p> <p>Note</p> <p>The digital waveform only affects the raw ADC streams. It does not change the data used when processing the measurement using integration, demodulation etc.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#results-handles","title":"Results handles","text":"<p>The stream items stored in the save/save all terminals on the server PC can be fetched to the client PC using the <code>results_handles</code> property of the <code>QmJob()</code> object. The fields of the <code>result_handles</code> property contain references to the stream terminals, and their names are the same as the tags given to the terminals. A handle to a specific terminal with tag <code>\"my_result\"</code>, for example, is accessed with <code>my_result = job.results_handles.get(\"my_result\")</code>. A shorthand notation for this is <code>my_result = job.results_handles.my_result</code>.</p> <p>We can query both the state of a single result handle or that of the collection of all results handles. For example, one can query the processing state using the <code>is_processing()</code> method, or the <code>wait_for_all_values()</code> method to suspend python execution until either a timeout has occurred or saving has completed. In case the handle references results from a save terminal, we can also wait for a specific number of results to arrive using the <code>wait_for_values(count)</code> method. The number of stream items referenced by a specific result handle can be obtained by calling <code>count_so_far()</code> on that handle, or equivalently by calling <code>len(my_result)</code>.</p> <p>Saving results in numpy format to a local variable is done using the <code>fetch</code> and <code>fetch_all</code> methods as specified below. We can also save results to the file system by calling <code>save_to_store(path)</code>.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#fetch-and-fetch_all","title":"fetch and fetch_all","text":"<p>To transfer the results from the server PC to the client PC, <code>fetch</code> and <code>fetch_all</code> commands are called on a result handle, for example:</p> <pre><code>my_stream_res=res.my_stream.fetch_all()\n</code></pre> <p>where <code>my_stream</code> is the tag result tag given to the save/save_all terminal.</p> <p><code>fetch</code> collects the most recent result in the stream and <code>fetch_all</code> collects all saved data. In the case a save terminal is used, fetch all is equivalent to fetch.</p> <p>It is also possible to collect only a portion of the collected data by passing <code>fetch</code> a slice object. For example, say your result stream contains [0,1,2,3,4,5,6,7,8,9]. fetch(0) returns 0, fetch(4) returns 4 and fetch(slice(2,5) returns [2,3,4,5]. Any valid python slice object can be used.</p> <p>Warning</p> <p>When fetching the data while using <code>pause()</code> - <code>resume()</code> with a <code>save()</code> command there is no guarantee that the data you fetch at a given moment is the data point from the current iteration. There can be some delay from the moment the data is acquired until it is available for fetching. Moreover, the streams are a-synchronous. For example, the availability of the result I[j] might be a few moments before Q[j]. If you fetch the data before the data is available at the Q stream, you will end up with a mixed data point I[j],Q[j-1]. That means that it is better to use the <code>save_all()</code> command and fetch the desired data.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#combining-streams-using-the-zip-operator","title":"Combining streams using the <code>zip</code> operator","text":"<p>Streams can be zipped together into tuples of results. This is similar to creating a buffer but combines data from two separate streams rather than reshaping a single one. In this case, the zipped resulting stream will have a shape dictated by the number of zipped tuples. Each element of this tuple is a named field <code>value_i</code> where i the named field number (the index of the zipped stream).</p> <pre><code>A_stream.zip(B_stream).save_all(\"zipped_tuple\")\n...\nzipped = job.result_handles.zipped_tuple.fetch_all()\n</code></pre> <p><code>zipped</code> has a shaped based on the number of items <code>n</code>. It has two named fields: <code>value_0</code> and <code>value_1</code>.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#data-restructuring-with-buffer","title":"Data restructuring with buffer()","text":"<p>The buffer method allows reshaping of the incoming stream items. For example</p> <pre><code>my_stream.buffer(2).save_all('output_name')\n</code></pre> <p>Will result in a stream of number pairs. And</p> <pre><code>my_stream.buffer(2,2).save('output_name')\n</code></pre> <p>Will result in a stream of 2 by 2 matrices. This is useful inside a doubly nested for loop as we can loop over a pair of independent variables and save the resulting dependent variable with the correct structure. We can then perform additional processing. For example, we can perform a running average over the resulting matrix in the following way:</p> <pre><code>my_stream.buffer(2,2).average().save()\n</code></pre> <p>This allows us to collect the resulting matrix and observe how the average evolved with the subsequent runs in real-time.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#buffer-limitations","title":"Buffer limitations","text":"<p>It is not possible to process more than 100e6 buffered variables at the same time. This is true for total number of variable streamed at the same time.</p> <p>For example in the following snippet of code, the first line can be processed by itself, adding the second line will drive the system behind its limitations:</p> <pre><code>my_stream1.buffer(int(100e6)).save()\nmy_stream2.buffer(int(3e5)).save()\n</code></pre> <p>Note</p> <p>streaming a buffered variable with time stamps is akin to streaming double the amount of variable. When using <code>with_timestamps</code>, each variable should be calculated as two variables when considering this limitation.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#mapping-operations-over-streams-with-the-map-function","title":"Mapping operations over streams with the <code>map</code> function","text":"<p>The <code>map</code> function allows you to perform an operation on each element in a stream. It becomes especially useful when combined with the <code>buffer</code> function because then operations can be performed on each filled buffer. For example, one can generate a buffer of size 3, and average over the samples in each triplet of numbers in the buffer. This is done as follows:</p> <pre><code>A_stream.buffer(3).map(FUNCTIONS.average()).save_all('averaged_stream')\n</code></pre> <p>There are multiple FUNCTIONS that can be used in this way. For example, <code>FUNCTIONS.dot_product()</code>, <code>FUNCTIONS.multiply_by(scalar_or_vector)</code>. Both these have shortcut operators so you can simply use <code>.multiply_by</code> as an operator in a stream pipline.  However, not all function have a shortcut and it's useful to learn what the options are. Some of these functions are: <code>demod</code>, <code>boolean_to_int</code>,`fft`,`tuple_convolution`, <code>convolution</code>,`tuple_multiply` but there are others. You can use Python's introspection to see what is available.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#average-on-axis","title":"Average on axis","text":"<p>When working with two dimensional buffers, one can specify over which axis to average. For example, in the following three dimensional buffer, averaging is done on the first (zero-eth) axis with the following syntax:</p> <pre><code>A_stream.buffer(axis2_size).buffer(axis1_size).buffer(axis0_size).map(FUNCTIONS.average(0)).save_all(f\"avg_axis0\")\n</code></pre> <p>A list of axis can also be passed, in which case averaging is done on all passed axes. This matches behavior in numpy for example.</p> <pre><code>A_stream[i].buffer(axis2_size).buffer(axis1_size).buffer(axis0_size).map(FUNCTIONS.average([0, 1, 2])).save_all(f\"avg_axis012\")\n</code></pre>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#flat-data-structure-option","title":"Flat data structure option","text":"<p>The data structure returned by calling <code>fetch_all</code> is a numpy structured array. In simple cases, where buffering is not used, the shape of this array is exactly given by the number of saved items. If time stamps are also included, there is a single column of values and a second column with timestamps. If, however the data is buffered or manipulated in some way, the number of items in the output array will be the number of filled (or partially filled) buffers. For example, consider the following buffered stream</p> <pre><code>stream.buffer(10).buffer(5).save_all()\n</code></pre> <p>If we had 300 items entering the steam, the shape of the output stream numpy array is: 6 (10*5*6  = 300). Each numpy array item has shape 10 X 6, but because the inner dimensions are \"hidden\" this is not indexable in the way you might expect.</p> <p>To modify this behavior, an option to \"flatten\" the result array has been added. This is called by passing the following parameter to <code>fetch_all</code>:</p> <pre><code>job.result_handles.samples.fetch_all(flat_struct=True)\n</code></pre> <p>In this case, the result shape will have the shape (6,5,10) and indexing can be performed as is usual in numpy array.</p> <p>If the <code>flat_struct</code> flag is used on zipped streams, each named field will have a shape as described for a single stream.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#stream-processing-arithmetics","title":"Stream Processing Arithmetics","text":"<p>It is possible to use the server to perform arithmetic operations on a single stream or between different streams. A complete list of the possible operations can be found in <code>_ResultStream()</code>. In general, an operation can be performed between a stream to itself, two different streams or a stream and a scalar. The operation is done element-wise, so both streams need to be buffered identically. In the case of an operation between a stream and a scalar, the operations must be done before buffering the stream.</p> <p>Note</p> <p>It is possible to do multiplication between a buffered stream and a vector using the <code>multiply_by()</code> function. The vector length must be identical to the stream buffer.</p> <p>Some simple syntax examples:</p> <pre><code>(stream + 1).save(\"example\")  # Adding 1 to each element in the stream\n(stream_1 + stream_2).buffer(5).save(\"example\")  # Adding element-wise stream1 to stream2 and buffering the result\n(stream_1.buffer(5) + stream_2.buffer(5)).save(\"example\")  # First buffering the streams and then adding them to each other\n((stream1+1)*3+(stream2+1)/2).buffer(5).average().save_all(\"example\")  # A combination of stream and scalar arithmetics\n</code></pre> <p>Notice that lines two and three in the above examples will results in identical outputs.</p> <p>Warning</p> <p>An operation between two streams that have different total length will only occur a number of times equal to the shortest stream in their order within the pipeline, regardless of the location of the <code>save()</code> command in the QUA program. For example if <code>stream1</code> has n items, and <code>stream2</code> has m items, where m \\&lt; n. The result of <code>(stream1+stream2).save_all()</code> would be an array of length m, with the values of the first m elements in <code>stream1</code> added element-wise to <code>stream2</code>.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#examples","title":"Examples","text":"<p>A simple example that shows the utility of stream arithmetic is the ability to calculate the variance of a measured variable during the measurement. In the figure below, we see the results of generating a random integer between 0 to 9 repeatedly, and streaming two streams as written below:</p> <pre><code>stream.average().save_all(\"average\")\n((stream*stream).average()-(stream.average()*stream.average())).save_all(\"variance\")\n</code></pre> <p>where the first line stream the running average (in blue in the figure), and the second line calculate the variance and stream the results (in orange in the figure).</p> <p></p> <p>Fig. 2: Running average stream (blue) and the variance stream(orange) of a randomly generated number on the OPX+. The horizontal lines mark the theoretical average (blue) and variance (orange).</p> <p>In the following example, we see the use of the histogram. By using the Time Tagging, we get an array of time stamps indicating at which point in the measurement we counted a pulse (simulating a photon). By repeating the time tagging measurement, we can stream the results in a histogram telling us how many pulses we counted in each time bin.</p> <pre><code>times_st.histogram([[i, i + (resolution - 1)] for i in range(0, meas_len, resolution)]).save(\"times_hist\")\n</code></pre> <p>The above code line shows how to use the histogram in the stream processing where <code>meas_len</code> is the measurement length, and <code>resolution</code> is the required histogram bin size.</p> <p></p> <p>Fig. 3: A histogram of the number of counts as a function of measurement time. The time bin resolution is 20ns.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#legacy-save","title":"Legacy Save","text":"<p>Prior to saving into explicitly declared streams, QUA's save mechanism was directly to a tag : <code>save(var,'tag')</code> where <code>'tag'</code> is a string identifier. When using this legacy saving mechanism the output can be retrieved without change, as below:</p> <pre><code>fetch_all_data = job.result_handles.get(\"A\").fetch_all()\n</code></pre> <p>This retrieves both values and timestamps. Alternatively, if only values (or only timestamps) are needed, we have introduced the following notation:</p> <pre><code>fetch_only_values= job.result_handles.get(\"A\").fetch_all(flat_struct=True)\nfetch_only_timestamps= job.result_handles.get(\"A_timestamps\").fetch_all(flat_struct=True)\n</code></pre> <p>This provides only values (or only timestamps) and is slightly more performant than the previous option. In future versions <code>flat_struct=True</code> the default option.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#server-pc-storage-and-data-limitations","title":"Server PC storage and data limitations","text":"<p>A <code>save_all</code> terminal will store in the all of the stream items created during the execution of a QUA program as results in the permanent memory of the server PC. The permanent memory of the server PC is large but not unlimited, and therefore it is possible in some cases to create more results than can be stored at the server PC. The server PC permanent memory can store up to 100GB of result data without danger of data-loss.</p> <p>Warning</p> <p>If more than 100GB are stored in the permanent memory, the data may be erased after a short time to ensure the permanent storage is not overfilled. To ensure that job results are not erased, always make sure that no more than 100GB of data are generated by the QUA program without being fetched.</p> <p>The results will not be immediately erased from the server once they are fetched. To clear the permanent storage and ensure that all of the 100GB are available, use the <code>clear_all_job_results()</code> method.</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#data-loss-notification","title":"Data loss notification","text":"<p>When collecting results from a stream, the system can usually estimate how much data is expected to be received. For example, if the <code>measure</code> command plays a pulse with a duration of 1000 samples, we expect to collect an output of that length. In cases where the expected amount of data does not match the received amount, an error message will appear when the <code>res.my_stream.fetch_all()</code> or <code>.fetch()</code> commands are called. It can also be manually checked by calling</p> <pre><code>res.my_stream.has_data_loss()\n</code></pre>","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#video-tutorials","title":"Video Tutorials","text":"","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#stream-processing-introduction","title":"Stream processing - introduction","text":"","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#stream-processing-save-and-save_all","title":"Stream processing - save and save_all","text":"","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#stream-processing-buffer","title":"Stream processing - buffer","text":"","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#stream-processing-averaging","title":"Stream processing - averaging","text":"","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#stream-processing-average-within-a-buffer","title":"Stream processing - average within a buffer","text":"","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#stream-processing-bufferaveragebuffer","title":"Stream processing - buffer.average.buffer","text":"","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#stream_processing-advance-example-part-1","title":"Stream_processing - advance example (part 1)","text":"","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#stream_processing-advanced-example-part-2","title":"Stream_processing - advanced example (part 2)","text":"","boost":4},{"location":"qm-qua-sdk/docs/Guides/stream_proc/#glossary","title":"Glossary","text":"<p>Stream Variable</p> <p>: A source (or start point) of a pipeline, receives values of QUA variables   or raw input samples as input</p> <p>Save Terminal</p> <p>: An overriding named sink or (end point) of a pipeline that creates a result.   Each new stream item received at this terminal, will override the previous.   The result is a single item, the last one received in a stream</p> <p>Warning</p> <p>Using a save terminal can result in data loss. It is to be used only in cases where data loss is acceptable, such as streaming plots.</p> <p>Save All Terminal</p> <p>: A named sink or end point of a pipeline that creates a result, which stores   all the stream items in the pipeline.   All stream items are appended to the result, complete history of the stream   is preserved</p> <p>Pipeline</p> <p>: An ordered collection of operations that is performed on an input stream to return   a processed version of the stream (output stream)   In the context of stream processing, it is the collection of operations that   can be performed starting from a stream variable and terminating in a \"save terminal\" or   \"save all terminal\" node</p> <p>Stream</p> <p>: An ordered set of values that are being sent from a QUA program into a pipeline.   A stream is set up when a QUA program is started and is torn down when it is   finished.</p> <p>Stream item</p> <p>: A single discrete unit of data of a stream.   Can be one of the following:</p> <ul> <li>ICP result</li> <li>Single input sample from the controller</li> <li>An input trace vector (single measure statement)</li> </ul> <p>It is possible to augment the timestamp to each item using <code>withTimestamp</code></p> <p>Result</p> <p>: The last or accumulated stream items that are created by save or save_all terminals, respectively</p> <p>Result Handle</p> <p>: An object through which results can be fetched</p>","boost":4},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/","title":"Timing in QUA","text":"<p>A QUA program defines not only the pulses that are played, but also specifies when they should be played.</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#pulse-dependency","title":"Pulse Dependency","text":"<p>The QUA syntax defines an implicit pulse dependency, which determines the order of pulses execution. The dependency can be summarized as follows:</p> <ol> <li>Each pulse is played immediately, unless specified otherwise or a calculation has to be done.</li> <li>We can delay the pulse play by using a qm.qua._dsl.wait command. Dependency-wise, this is equivalent to a play with zero amplitude.</li> <li>Pulses applied to the same element are dependent on each other according to the order in which they appear in the program.</li> <li>We can create a dependency between different elements via the qm.qua._dsl.align command. Whenever elements are 'aligned', the execution of operations that come after the alignment is dependent on the operations that come before.</li> </ol> <p>Note</p> <p>Each element has its own thread, unless defined otherwise. If elements do share threads, they are dependent on each other as in case 3 above.</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#the-align-command","title":"The Align Command","text":"<p>To further illustrate point number 4 above, consider the following pseudo-code examples:</p> <pre><code>with program() as prog:\n## operations on element_1\nalign(element_1, element_2)\n## operations on element_2\n</code></pre> <p>In this example, the operations on <code>element_2</code> will only begin execution after the last operation on <code>element_1</code> took place (before the alignment).</p> <p>Let's consider a slightly more complex example:</p> <pre><code>with program() as prog:\n## operations on element_1\n## operations on element_2\n## operations on element_3\nalign(element_1, element_2)\n## operations on element_1\n## operations on element_2\n## operations on element_3\n</code></pre> <p>In the first part of the program above, before the alignment, the operations on the different elements will occur simultaneously, according to the dependency rules above. In the second half, after the alignment, the operations on <code>element_1</code> &amp; <code>element_2</code> will only begin after the operations from the first half, on both elements, has finished. Operations on <code>element_3</code> are independent of the other elements and will ignore the align command.</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#the-implicit-align","title":"The Implicit Align","text":"<p>There is an implicit align whenever several elements participate in a flow control branch. That means that when elements appear together in a for loop, while loop, if / else / elif block or a switch case, they are aligned in the beginning of the flow control branch.</p> <p>For example, the following example:</p> <pre><code>with program() as prog:\n## operations on element_1\nwith while_(some_condition):\n## operations on element_1\n## operations on element_2\n</code></pre> <p>To the compiler, it is actually:</p> <pre><code>with program() as prog:\n## operations on element_1\nalign(element_1, element_2)\nwith while_(some_condition):\nalign(element_1, element_2)\n## operations on element_1\n## operations on element_2\n</code></pre> <p>In the program, the while loop will only start after the pre-loop operations on <code>element_1</code> has finished. In addition, every iteration will begin only after the operations on both element have ended. Therefore, the loops duration will be determined by the longest of the two operation sequences.</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#gaps-in-qua","title":"Gaps in QUA","text":"<p>The QUA syntax of pulses and operations only defines their order of execution, it does not guarantee that they would be played without introducing gaps. This means that two consecutive <code>play</code> commands on the same element may have a short gap between them. The compiler tries to minimize these gaps, but it is not always possible to completely eliminate them. For tips on how to reduce these gaps, see QUA Best Practice Guide. It is also possible to indicate to the compiler sections in which it is critical to have no gaps, this can be done with the qm.qua.dsl.strict_timing block.</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#strict-timing","title":"Strict Timing","text":"<p>Note</p> <p>{{ qop2 }} The strict timing feature only exists in the OPX+</p> <p>Any command written inside a qm.qua.dsl.strict_timing block will be required to be played without gaps. In cases where this is not possible, an error will be raised indicating the gaps. It is possible to add the flag <code>not-strict-timing</code> to the execution to raise warnings instead of errors. For more information on how to use flags, see compilation options.</p> <p>In the following example, the two pulses will happen with no gaps in between:</p> <pre><code>with strict_timing_():\nplay('x180', 'qubit')\nplay('y90', 'qubit')\n</code></pre> <p>In the next example, the qm.qua.dsl.for loop is also inside the strict timing, which also requires that there will be no gaps between different iterations of the loop. i.e., this means that the following code will produce a chain of 200 pulses alternating between <code>x180</code> and <code>y90</code> with no gaps at all.</p> <pre><code>with strict_timing_():\nwith for_(n, 0, n&lt;100, n+1):\nplay('x180', 'qubit')\nplay('y90', 'qubit')\n</code></pre>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#deterministic-vs-non-deterministic-align","title":"Deterministic Vs. non-Deterministic Align","text":"<p>Generally, an align command requires the passage of information from one thread to the other. When a thread reaches its last instruction before an alignment, it sends a signal to all the other threads that participate in the alignment, also known as a \"hardware sync\". This passage of information takes several clock cycles and introduces gaps to the pulse sequence. In cases where the duration of the operation on all the elements is known during compilation (Deterministic case), the compiler optimizes the sequence and replaces the hardware sync with precalculated wait commands for each element. This optimization ensures that there are no gaps formed in a deterministic case. However, if the run-time of one of the elements is not known during compilation (non-Deterministic case), gaps will be formed. See examples 3 and 4 below for more details.</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#examples-for-timing-scenarios-in-qua","title":"Examples for Timing scenarios in QUA","text":"<p>We will present five examples in order to demonstrate the timing in qua:</p> <ol> <li>Two pulses from different elements.</li> <li>Two pulses from different elements with wait command.</li> <li>Two pulses from different elements with align command (deterministic case).</li> <li>Two pulses from different elements with align command (non-deterministic case).</li> <li>Two pulses from the same element.</li> </ol> <p>Note</p> <p>For the executable examples look at timing tutorial.</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#example-1","title":"Example #1","text":"<p>Two pulses from different elements.</p> <pre><code>with program() as prog:\nplay('cw1', 'qubit')\nplay('cw2', 'resonator')\n</code></pre> <p></p> <p>The two pulses start at the same time since they relate to different elements.</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#example-2","title":"Example #2","text":"<p>Two pulses from different elements with wait command.</p> <pre><code>with program() as prog:\nplay('cw1', 'qubit')\nwait(100)\nplay('cw2', 'resonator')\n</code></pre> <p></p> <p>The play on the resonator is delayed by a 400 ns (100 cycles).</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#example-3","title":"Example #3","text":"<p>Two pulses from different elements with align command (deterministic case)</p> <pre><code>with program() as prog:\nplay('cw1','qubit')\nalign('qubit', 'resonator')\nplay('cw2', 'resonator')\n</code></pre> <p></p> <p>The play on the resonator starts right after the qubit's play ends. This is due to the align command (in the deterministic case).</p> <p>Note</p> <p>In the deterministic case above, the align command is translated to the wait command with the specific known wait time.</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#example-4","title":"Example #4","text":"<p>Two pulses from different elements with align command (non-deterministic case)</p> <pre><code>with program() as prog:\n# some calculation of t in real time\nplay('cw1','qubit', duration=t)\nalign('qubit', 'resonator')\nplay('cw2', 'resonator')\n</code></pre> <p>While t is calculated in real-time.</p> <p></p> <p>If we zoom in to the area where one element ends and the other starts, we can see a gap between them.</p> <p></p> <p>Note</p> <p>When playing two elements with align command in the non-deterministic case, there is a few cycles delay between the pulses. Since in the non deterministic case it takes few cycles to pass the information from one thread to the other.</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/timing_in_qua/#example-5","title":"Example #5","text":"<p>Two pulses from the same element.</p> <pre><code>with program() as prog:\nplay('cw1','qubit')\nplay('cw2', 'qubit')\n</code></pre> <p></p> <p>The two play commands are played one after the other since they are played from the same element.</p>","boost":3},{"location":"qm-qua-sdk/docs/Guides/variables/","title":"Variables in QUA","text":"<p>The following page describes the three types of variables in QUA: Integers, fixed point numbers and booleans.</p>"},{"location":"qm-qua-sdk/docs/Guides/variables/#definitions","title":"Definitions","text":""},{"location":"qm-qua-sdk/docs/Guides/variables/#integers","title":"Integers","text":"<p>Integers in QUA are 32 bit, so their range is  \\([-2^{31}, 2^{31}-1]\\) which is roughly \\(\\pm 2e9\\).</p> <p>To create an integer variable we use:</p> <pre><code>i = declare(int)  # creates a variable named \"i\" of type integer\n</code></pre> <p>Note</p> <p>If assigning a value outside of the range, the variable will overflow. When a number overflows, the value will \"wrap around\". For example:</p> <pre><code>big_number = declare(int)\nassign(big_number, 2**31-1)\n# big_number is now 2^31-1\nassign(big_number, big_number+1)\n# big_number is now -2^31\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/variables/#fixed-point-numbers","title":"Fixed point numbers","text":"<p>Fixed point numbers in QUA are in 4.28 format. There are 4 integer bits, including a sign bit, and 28 fractional bits. Therefore, the range of the fixed point number is \\([-8, 8)\\) in steps of \\(2^{-28} = ~3.7e-9\\).</p> <p>To create a fixed point variable we use:</p> <pre><code>i = declare(fixed)  # creates a variable named \"i\" of type fixed point\n</code></pre> <p>Note</p> <p>If assigning a value larger than 8, the variable will overflow. When a number overflows, the value will be the modulo 16 unsigned, i.e. \\(((x + 8) % 16) - 8\\). In other words, the value will be wrapped around the range. For example:</p> <ul> <li>\\(8.0 \\rightarrow -8.0\\)</li> <li>\\(9.0 \\rightarrow -7.0\\)</li> <li>\\(17.0 \\rightarrow 1.0\\)</li> <li>\\(100.0 \\rightarrow 4.0\\)</li> </ul>"},{"location":"qm-qua-sdk/docs/Guides/variables/#booleans","title":"Booleans","text":"<p>Booleans are declared using:</p> <pre><code>b = declare(bool)  # creates a variable named \"b\" of type fixed boolean\n</code></pre> <p>When assigning the truth value of the boolean, every non-zero value will be considered as true, and zero will be false. For example:</p> <pre><code>b = declare(bool)\n## True:\nassign(b, True)\nassign(b, 4&lt;8)\nassign(b, 2)\nassign(b, 0.1)\n## False:\nassign(b, False)\nassign(b, 4&gt;8)\nassign(b, 0)\nassign(b, 0.0)\n</code></pre>"},{"location":"qm-qua-sdk/docs/Guides/variables/#casting","title":"Casting","text":"<p>QUA enables casting between different types of variables using the Cast library. There are three normal casting operations, two casting by multiplication operations and two \"unsafe\" casting operations.</p> <p>We list a few things to note while casting from one type to another:</p> <ul> <li>Casting from int to fixed only gives an expected result when the integer is in the range [-8,7]. Otherwise, the result fixed variable will overflow.</li> <li>Casting to Boolean, will behave according to the examples above.</li> <li>The unsafe casting operation <code>unsafe_cast_fixed()</code> treats the input, bitwise, as a fixed number. When applied to an integer, this is equivalent to a multiplication by \\(2^{-28}\\).</li> <li>The unsafe casting operation <code>unsafe_cast_int()</code> treats the input, bitwise, as an integer. When applied to a fixed number, this is equivalent to a multiplication by \\(2^{28}\\).</li> </ul>"},{"location":"qm-qua-sdk/docs/Hardware/","title":"Hardware","text":"<p>This section provides details on QM's hardware products. Please select from the menu on the left specific hardware device you are interested in.</p>"},{"location":"qm-qua-sdk/docs/Hardware/OPX_hardware/","title":"OPX &amp; OPX+ Hardware Specifications","text":"<p>This page describes the hardware components of the OPX &amp; OPX+.</p>"},{"location":"qm-qua-sdk/docs/Hardware/OPX_hardware/#port-specifications","title":"Port specifications","text":"<p>In the table below are regrouped the main characteristics of the OPX &amp; OPX+ ports.</p> OPX ports Analog outputs Analog inputs Digital outputs External trigger Voltage settings \u00b10.5 V or 4 dBm \u00b10.5 V or 4 dBm 3.3 V (LVTTL) 3.3V (LVTTL) Bandwidth \u00b1350 MHz \u00b1350 MHz pulse width &gt; 2ns pulse width &gt; 4ns Resolution 16 bit DAC 12 bit ADC 1 bit 1 bit Impedance 50 \u03a9 50 \u03a9 High Z High Z <p>Note</p> <p>If the external trigger requires a low impedance port, the best is to add a 50 \\(\\Omega\\) terminator to the line. See Guide on External Triggering for more details regarding the usage of external triggering in the OPX.</p>"},{"location":"qm-qua-sdk/docs/Hardware/OPX_hardware/#opx-block-diagram","title":"OPX+ Block Diagram","text":"<p>The simplified block diagram model for the OPX+ can be seen below. You can click on the figure in order to enlarge it and get links to more information regarding each step.</p> <p></p>"},{"location":"qm-qua-sdk/docs/Hardware/OPX_hardware/#analog-input-stage","title":"Analog Input Stage","text":"<p>The signals acquired by the OPX using the analog input channels are first passed through an analog input stage and then digitized. Here we discuss the voltage limits, gain and offset calibrations that can be applied to the signal to be digitized.</p>"},{"location":"qm-qua-sdk/docs/Hardware/OPX_hardware/#acquiring-analog-signals-with-the-opx-opx","title":"Acquiring analog signals with the OPX &amp; OPX+","text":"<p>The signal chain can be seen in Fig. 1. The signal source can be either AC or DC coupled.</p> DC coupled signal sourceAC coupled signal source <p>If the signal source is DC coupled and has 50ohm DC resistance to ground, it can be directly connected to the analog input. This can be seen in Option 1 of Fig. 1</p> <p>If the signal source is AC coupled and does not have a 50ohm resistance to ground, a bias T is needed in order to bias the input amplifier. The required setup can be seen in option 2 of Fig. 1. In this case, the source will still need to have a 50ohm AC impedance throughout its bandwidth for proper operation.</p> <p>Note</p> <p>The OPX &amp; OPX+ input has a common-mode voltage of 0.25V when measured with 50ohm.</p>"},{"location":"qm-qua-sdk/docs/Hardware/OPX_hardware/#setting-the-voltage-gain","title":"Setting the voltage gain","text":"<p>The voltage gain can be set by adding a <code>\"gain_db\"</code> field to the <code>\"analog_inputs\"</code> field of the controller in the config. It can take integer values between -12 dB to 20 dB. Here we show an example with the relevant fields:</p> <pre><code>config = {\n'version': 1,\n'controllers': {\n'con1': {\n'analog_inputs': {\n1: {'offset': 0.0, 'gain_db': -1},\n2: {'offset': 0.0, 'gain_db': 1},\n}\n}\n},\n}\n</code></pre> <p>Warning</p> <p>When the gain is set to max attenuation, -12dBm, the maximal power that can be input to the ADC without significant distortion is 16dBm or 4Vpp.</p> <p>Please avoid exceeding 4dBm (1Vpp) without attenuation. This may damage the controller.</p> <p>Note</p> <p>When changing the gain, the input DC offset needs to be recalibrated.</p>"},{"location":"qm-qua-sdk/docs/Hardware/OPX_hardware/#back-panel-description","title":"Back Panel Description","text":"<p>The back panel of the OPX is the interface for control, power and connectivity to other devices. The following section details the back panel of the OPX and the OPX+ controllers.</p>"},{"location":"qm-qua-sdk/docs/Hardware/OPX_hardware/#opx","title":"OPX","text":"<p>The OPX has several back panel versions. Click on the toggle keys to view them.</p> Multi-OPX connectivity version <p></p> <p>Back Panel Description</p> Number Label Description 1 PCIe Connection to the server 2 Ext1 Not in use 3 Ext2 Not in use 4 USB 2 USB 3.0 ports. Server connects to the lower one 5 LAN Not in use 6 Inter OPX communication 10 optical ports for fast communication between OPX's 7 External clock External clock reference (10,100,1000 MHz) 8 Sync Synchornization with the OPT 9 Aux1 External trigger input 10 Aux 2 Not in use 11 Line Power inlet and switch Single OPX version <p>Important</p> <p>Some early back panels might have different labels. However, the correct labels are the ones shown on this page.</p> <p></p> <p>Back Panel Description </p> Number Label Description 1 PCIe Connection to the server 2 Ext1 Not in use 3 Ext2 Not in use 4 USB 2 USB 3.0 ports. Server connects to the lower one 5 LAN Not in use 6 Aux1 External trigger input 7 Aux2 Not in use 8 External clocl External clock reference (10,100,1000 MHz) 9 Sync Not in use 10 Line Power inlet and switch"},{"location":"qm-qua-sdk/docs/Hardware/OPX_hardware/#opx_1","title":"OPX+","text":"OPX+ with inter-OPX connectivity <p>Important</p> <p>Some early back panels might have different labels. These which might appear different are marked with an astrix. The correct labels are the ones shown on this page.</p> <p></p> <p>Back Panel Description</p> Number Label Description 1 LAN LAN port for network connection to router 2 Ground symbol Chassis earth ground 3 OPC Com. Inter-OPX optical connectivity (for a multi-OPX system) 4 reset Factory reset 5 None 2 USB ports 6 Clock in External clock reference (10,100,1000 MHz) 7 100GBE Not in use 8 Sync Sync from OPT (for a multi-OPX system) 9 Ext. trig (3.3V)* External trigger 10 Digital Ext. Connection for OPD - digital input/output extension 11 AUX 1 (1.8V)* QSync 12 AUX 2 (1.8V)* QSync 13 Line Power inlet and switch"},{"location":"qm-qua-sdk/docs/Hardware/dib/","title":"OPD - Operator Digital","text":"<p>The OPD is a separate box that enhances the OPX input with 10 more digital signals. These 10 inputs have programmable thresholds and are sampled at 1ns resolution. They are \\(50 \\Omega\\) matched and accept up to 3.3V (LVTTL).</p>","boost":0.5},{"location":"qm-qua-sdk/docs/Hardware/dib/#usage","title":"Usage","text":"<p>The OPD is directly connected to the OPX. When it is present, the input channels can be defined in the configuration file similarly to other channels:</p> <pre><code>'controllers': {\n'con1'': {\n'type': 'opx1',\n\"analog_outputs\": {\n...\n},\n'digital_inputs': {\n1: {'polarity': 'RISING', 'deadtime': 4, \"threshold\": 0.1},\n2: {'polarity': 'RISING', 'deadtime': 15, \"threshold\": 3.2},\n},\n'analog_inputs': {\n...\n},\n},\n},\n</code></pre> <p>When defining a digital input, several parameters needs to be defined:</p> <ul> <li><code>polarity</code> - Whether it is triggered when <code>RISING</code> (rising edge) or <code>FALLING</code> (falling edge)</li> <li><code>deadtime</code> - Minimal time between pulses in ns. i.e. If it is set to 16ns, then only the 1st pulse out of two pulses 10ns apart will be detected. 'deadtime' should be between 4 and 16ns.</li> <li><code>threshold</code> - Voltage threshold</li> </ul> <p>Once defined in the controller, it can be used in a quantum element:</p> <pre><code>\"elements\": {\n\"qubit\": {\n\"mixInputs\": {\n...\n},\n'digitalOutputs': {\n'out1': ('con1', 2)\n},\n...\n},\n},\n</code></pre>","boost":0.5},{"location":"qm-qua-sdk/docs/Hardware/dib/#measuring","title":"Measuring","text":"<p>Time Tagging with the OPD is done similarly to a normal time tagging measurement:</p> <pre><code>times = declare(int, size=10)\ncounts = declare(int)\nmeasure([pulse], [element], [stream], time_tagging.digital([times], [max_time], [counts], [element_output])\n</code></pre> <ul> <li><code>times</code> is a vector of integers that is populated by the measurement.</li> <li><code>max_time</code> gives the maximum time window, in ns, during which the statement waits for tag arrival.</li> <li><code>counts</code> is a variable that is populated with the number of tags which arrived during the measurement.</li> <li><code>element_output</code> must be defined if the <code>element</code> has more than one digital output. In this case, it is a string indicating the output to be measured. It can be left empty when the element has only one input (default is empty string).</li> </ul> <p>The time-tagging operation ends either at the set duration or when the <code>times</code> is fully populated (first one of the two).</p> <p>Note that the information in <code>times</code> is only valid up to <code>counts</code>.</p> <p>In addition, with the OPD you can directly count pulses:</p> <pre><code>counts = declare(int)\nmeasure([pulse], [element], [stream], counting.digital([counts], [max_time], [element_outputs]))\n</code></pre> <ul> <li><code>counts</code> is a variable that is populated with the number of pulses which arrived during the measurement.</li> <li><code>max_time</code> gives the maximum time window, in ns, during which the statement waits for incoming pulses.</li> <li><code>element_outputs</code> must be defined if the <code>element</code> has more than one digital input. In this case, it is either a string indicating the output to be measured or a tuple with list of strings corresponding to the outputs to be measured. It can be left empty when the element has only one input (default is empty string).</li> </ul>","boost":0.5},{"location":"qm-qua-sdk/docs/Hardware/dib/#wait-for-trigger","title":"Wait for trigger","text":"<p>It is possible for any element to wait until an pulse arrives at one of the OPD inputs.</p> <pre><code>wait_for_trigger(element_waiting, pulse_to_play=None, trigger_element=None)\n</code></pre> <ul> <li><code>element_waiting</code> is the element waiting.</li> <li><code>pulse_to_play</code> is the name of the pulse to play on the element while waiting for the external trigger. Must be a constant pulse. Can be None to play nothing while waiting.</li> <li><code>trigger_element</code> is an element with digital inputs, when one of his digital inputs is triggered, the <code>element_waiting</code> will continue. If <code>trigger_element</code> has multiple digital inputs, a specific one must be chosen: <code>trigger_element</code> can be a tuple, with the 1st item being the element name and the 2nd item being the trigger input. If <code>trigger_element</code> is left empty, then it waits for the trigger input in the back panel of the OPX.</li> </ul>","boost":0.5},{"location":"qm-qua-sdk/docs/Hardware/octave/","title":"Octave","text":"<p>The Octave is a separate product that enhances the OPX by up- and down-converting its analog outputs, yielding a seamless and calibrated RF front-end from the Quantum Orchestration Platform. The Octave has five RF outputs and two combined RF inputs operating in a frequency band of 2GHz to 18GHz. Controlling the Octave is done with its own API that directly connects with the QM Python package.</p> <p></p>"},{"location":"qm-qua-sdk/docs/Hardware/octave/#octave-features-and-specifications","title":"Octave Features and Specifications","text":"<p>The purpose of the Octave is to take the intermediate-frequency control signals originating in the OPX and up-convert them to match the qubit frequency. The conversion method used in the Octave is IQ mixing, meaning we use pair of IQ signals at the intermediate frequency (the ones coming from the OPX) and mix them with an RF LO signal, which can be generated inside the Octave or be fed from an external LO source. The resulting signal is a high-frequency RF signal at IF+LO. The up-converters outputs are AC coupled.</p> <p>Four internal LO sources are connected to the mixers of the up and down converters:</p> <ul> <li>Synthesizer 1 - connected to up-converter 1 and down-converter 1</li> <li>Synthesizer 2 - connected to up-converter 2 &amp; 3</li> <li>Synthesizer 3 - connected to up-converter 4 &amp; 5</li> <li>Calibration Synthesizer - connected to down-converter 1 &amp; 2</li> </ul> <p>The mixers are automatically calibrated internally by a calibration signal path from each up converter to down converter 2. The Octave outputs can be triggered by the OPX or other external sources for fast conditional pulsing. In addition, the Octave has controllable tunable gain, enabling gain values at the range of \\(-10:0.5:20 dB\\) on the RF outputs. The two down-converted channels are amplified and the input power should be between \\(-30 dBm\\) to \\(-40 dBm\\).</p> <p>Important</p> <p>When using an external LO source, its power should be \\(12-15 dBm\\)</p>"},{"location":"qm-qua-sdk/docs/Hardware/octave/#getting-started","title":"Getting Started","text":"<p>Take your octave out of the box and place it in the rack with your OPX, preferably directly above or below it. Plug the supplied power supplier to the Octave and connect an ethernet cable from the most right bottom LAN port to the same router your OPX is connected to. Connect IF OUT1 from the octave to analog input 1 on the opx and IF OUT2 from the octave to analog input 2. If you want to use an external clock or an OPT, connect it to the external clock port on the back panel of the octave. Now you can power up the octave and connect it to the OPX. Connect the Octave to the OPX in a way that suits you experiment setup. The default connection map should be:</p> <p></p> <p>Now connect the RF outputs and inputs to your fridge (or a spectrum analyzer if you want to see the signals) and proceed to the next section.</p>"},{"location":"qm-qua-sdk/docs/Hardware/octave/#pre-requisites","title":"Pre-requisites","text":"<ol> <li>Install the latest <code>QUA</code> package by typing <code>pip install -U qm-qua</code> to a shell with an active Python environment.</li> <li>Install the latest <code>Octave-SDK</code> package by typing <code>pip install -U qm-octave</code> to a shell with an active Python environment.</li> </ol>"},{"location":"qm-qua-sdk/docs/Hardware/octave/#sample-code","title":"Sample Code","text":"<p>We start by importing the required packages we installed in the last sections</p> <pre><code>import os\nimport time\nfrom qm.QuantumMachinesManager import QuantumMachinesManager\nfrom qm.octave import *\nfrom qm.qua import *\nimport numpy as np\n</code></pre> <p>Now, we need to define our config file. If you used IQ mixers before in your OPX setup you should notice that there is nothing new in it. There are a few new things in the config to pay attention to when using octave:</p> <pre><code>'qubit': {\n'mixInputs': {\n'I': ('con1', 1),\n'Q': ('con1', 2),\n'lo_frequency': LO_frequency , # The mixer's LO\n'mixer': 'mixer_name'  # The mixer's name\n},\n...\n},\n'mixers': {\n'mixer_name':\n[\n{\n'intermediate_frequency': IF_frequency,\n'lo_frequency': LO_frequency,\n'correction': [1.0, 0.0, 0.0, 1.0]\n} # parameters for correction\n],\n},\n</code></pre> <p>Important</p> <p>Mixers names must be in the form: <code>octave_{OCTAVE_NAME}_{RF_PORT}</code>. For example for octave1 with up-converter one it will be octave_octave1_1</p> <p>Here is a simple configuration code that uses one mixer at LO = 6GHz and IF = 100 MHz</p> Configuration <pre><code>  readout_len = 10e6\nif_freq = 100e6\nlo_freq=6e9\ncalibration_amp = 0.125\ncalibration_pulse_length = 10e3\ntime_of_flight = 192\noffset_amp = 2 ** -3  # (0.125)\nconfig = {\n\"version\": 1,\n\"controllers\": {\n\"con1\": {\n\"analog_outputs\": {\n1: {\"offset\": +0.0},\n2: {\"offset\": +0.0},\n},\n\"analog_inputs\": {\n1: {\"offset\": +0.0},\n2: {\"offset\": +0.0},\n},\n}\n},\n\"elements\": {\n\"qe1\": {\n\"mixInputs\": {\n\"I\": (\"con1\", 1),\n\"Q\": (\"con1\", 2),\n\"lo_frequency\": lo_freq,\n\"mixer\": \"octave_octave1_1\",\n},\n\"intermediate_frequency\": if_freq,\n\"operations\": {\n\"CW\": \"calibration_pulse\",\n},\n\"digitalInputs\": {},\n},\n},\n\"pulses\": {\n\"calibration_pulse\": {\n\"operation\": \"control\",\n\"length\": calibration_pulse_length,\n\"waveforms\": {\n\"I\": \"CW_wf\",\n\"Q\": \"zero_wf\",\n},\n},\n\"waveforms\": {\n\"CW_wf\": {\n\"type\": \"constant\",\n\"sample\": calibration_amp,\n},\n\"zero_wf\": {\n\"type\": \"constant\",\n\"sample\": 0.0,\n},\n},\n\"digital_waveforms\": {\n\"ON\": {\"samples\": [(1, 0)]},\n\"OFF\": {\"samples\": [(0, 0)]},\n},\n\"integration_weights\": {\n\"cosine_weights\": {\n\"cosine\": [(1.0, calibration_pulse_length)],\n\"sine\": [(0.0, calibration_pulse_length)],\n},\n\"sine_weights\": {\n\"cosine\": [(0.0, calibration_pulse_length)],\n\"sine\": [(1.0, calibration_pulse_length)],\n},\n\"minus_sine_weights\": {\n\"cosine\": [(0.0, calibration_pulse_length)],\n\"sine\": [(-1.0, calibration_pulse_length)],\n},\n},\n\"mixers\": {\n\"octave_octave1_1\": [\n{\n\"intermediate_frequency\": if_freq,\n\"lo_frequency\": lo_freq,\n\"correction\": [1,0,0,1],\n},\n],\n},\n}\n</code></pre> <p>Note</p> <p>For best performance the IF amplitude should be set to 0.125 [V]</p> <p>To use Octave in our setup we must first create a new instance of <code>QmOctaveConfig</code> and then set device info with <code>add_device_info()</code> for all Octaves in the setup.</p> <pre><code>opx_ip = 'xxx.xxx.xxx.xxx'\nopx_port = 80\noctave_ip = 'xxx.xxx.xxx.xxx'\noctave_port = 80\noctave_config = QmOctaveConfig()\noctave_config.add_device_info('octave1', octave_ip, octave_port)\n</code></pre> <p>After we added our Octaves, we want to tell QUA and the OPX how the systems are connected. This is done by <code>set_opx_octave_mapping()</code> which gets a list of tuples, where each tuple is a set of <code>(opx, octave)</code> by their names. This function will set the port map to the default where <code>(I1, Q1)</code> goes to RF1, <code>(I2, Q2)</code> goes to RF2, and so on.</p> <pre><code>octave_config.set_opx_octave_mapping([(\"con1\",\"octave1\")])\n</code></pre> <p>If we want to configure the port mapping between the OPXs and Octaves in another way, It can be done with the function <code>add_opx_octave_port_mapping()</code> by giving the function a precise mapping of OPX to octave ports.</p> <pre><code>octave_config.add_opx_octave_port_mapping(portmap)\n</code></pre> <p>We then would like to tell the OPX the path to the calibration database (If it is the first calibration, a database will be generated in that path). It is done by calling <code>set_calibration_db()</code></p> <pre><code>octave_config.set_calibration_db(os.getcwd())\n</code></pre> <p>It is now possible to open a <code>QuantumMachinesManager</code> which now also gets the Octave config object</p> <pre><code>qmm = QuantumMachinesManager(host=opx_ip, port=opx_port, octave=octave_config)\n</code></pre> <p>For the sake of simplicity the sample qua code for this example will just play constant wave</p> <pre><code>with program() as prog:\nwith infinite_loop_():\nplay('CW','qe1')\n</code></pre> <p>Now you should open a quantum machine with the configuration</p> <pre><code>qm = qmm.open_qm(config)\n</code></pre> <p>It is possible to set the clock of the octave now. If nothing is done regarding the clock, the octave will boot with the last clock configuration that was set. Setting the clock to use the internal clock is done with the following:</p> <pre><code>qm.octave.set_clock(\"octave1\", ClockType.Internal, ClockFrequency.MHZ_10)\n</code></pre> <p>Setting the clock to use the external clock is done with:</p> <pre><code>qm.octave.set_clock(\"octave1\", ClockType.External, ClockFrequency.MHZ_1000)\n</code></pre> <p>External clock source can be at one of three frequencies: 10, 100, and 1000 MHz and the clock signal amplitude should be between -4dBm to +4dBm.</p> <p>Now before executing our QUA program, we should configure a few things on the Octave:</p> <ul> <li> <p><code>set_lo_frequency()</code>: this function will override the LO frequency written in the configuration file for the element.</p> </li> <li> <p><code>set_rf_output_gain()</code>: this function will set the output gain of the element.</p> </li> <li> <p><code>set_rf_output_mode()</code>: with this function, it is possible to set the RF output mode to:</p> <ul> <li><code>on</code> - Output is always on</li> <li><code>off</code> - Output is always off</li> <li><code>trig_normal</code> - The output will play when a digital trigger is detected in the Octave's digital port</li> <li><code>trig_inverse</code> - The output will play when a digital trigger is set off in the Octave's digital port</li> </ul> </li> </ul> <p>For example:</p> <pre><code>qm.octave.set_lo_frequency(element, lo_freq)\nqm.octave.set_rf_output_gain(element, -10)\nqm.octave.set_rf_output_mode(element, RFOutputMode.on)\n</code></pre> <p>Note</p> <p>Notice that the internal LO resolution is 250MHz</p> <p>We can also set the LO source to be external or internal. Supported internal connections are per the block diagram.</p> <pre><code>qm.octave.set_lo_source(element, OctaveLOSource.LO1)\n</code></pre> <p>Now we would like to calibrate the up converter. It is possible to calibrate it manually by using the OPX's dc offsets, but the Octave can do it automatically per element, LO frequency and IF frequency using the function <code>calibrate_element()</code>. It can even calibrate for a list of (LO, IF) couples.</p> <p>Important</p> <p>After calibration is done, we must open the quantum machine again.</p> <pre><code>qm.octave.calibrate_element(element, [(lo_freq, if_freq)])\nqm = qmm.open_qm(config)\n</code></pre> <p>We can also define the downconversion port per element with <code>set_qua_element_octave_rf_in_port()</code> and <code>set_downconversion()</code>. In order to use internal LO source use:</p> <pre><code>qm.octave.set_qua_element_octave_rf_in_port(element,\"octave1\", 1)\nqm.octave.set_downconversion(element)\n</code></pre> <p>in order to use an external LO source use:</p> <pre><code>qm.octave.set_qua_element_octave_rf_in_port(element,\"octave1\", 1)\nqm.octave.set_downconversion(element,lo_source=RFInputLOSource.Dmd1LO)\n</code></pre> <p>After we configured everything for our experiment, we can execute the program</p> <pre><code>qm.execute(prog)\n</code></pre>"},{"location":"qm-qua-sdk/docs/Hardware/octave/#octave-block-diagram","title":"Octave Block Diagram","text":"<p>Click the image to enlarge</p> <p></p>"},{"location":"qm-qua-sdk/docs/Hardware/octave/#octave-front-panel","title":"Octave Front Panel","text":"<p>Click the image to enlarge</p> <p></p>"},{"location":"qm-qua-sdk/docs/Hardware/octave/#octave-back-panel","title":"Octave Back Panel","text":"<p>Click the image to enlarge</p> <p></p> <p>Important</p> <p>Ports <code>synth 1/2/3</code> should always be kept terminated to 50\u03a9 when not in use</p>"},{"location":"qm-qua-sdk/docs/Hardware/opx%2Binstallation/","title":"OPX+ Installation Guide","text":"<p>The following page describes the installation procedure of a single OPX+ or a multi-OPX+ with an OPT topology. It covers network configuration, OPX+ connectivity, rack scheme and more.</p>"},{"location":"qm-qua-sdk/docs/Hardware/opx%2Binstallation/#network-overview","title":"Network Overview","text":"<p>The OPX+ controllers use an external router for network access. The communication is done via the external IP of the router, and the OPX+ controllers are preconfigured in the router's internal network. We call this configuration a cluster. Each cluster is composed of a main OPX+ controller, an OPT, and other OPX+ controllers. The cluster is created and configured using the QMApp desktop.</p> <p></p>"},{"location":"qm-qua-sdk/docs/Hardware/opx%2Binstallation/#installation-prerequisites","title":"Installation Prerequisites","text":"<p>Prior to the installation procedure, follow these prerequisites:</p> <ul> <li>If your local network requires whitelisting MAC address, make sure you whitelist the router's MAC address. If you don't know the address, follow the guide below or contact your QM representative.</li> <li>If your local network requires the use of a static IP make sure that you know which one to use.</li> </ul>"},{"location":"qm-qua-sdk/docs/Hardware/opx%2Binstallation/#installation-procedure","title":"Installation Procedure","text":"<ol> <li> <p>Verify you have all of the required components.</p> </li> <li> <p>Connect the router to the external network on the 1st port, marked as \u201cPoE In\u201d. If necessary, connect the router to the provided power supply.</p> </li> <li> <p>If the external IP to the router needs to be static, configure the router to a static IP.</p> </li> <li> <p>Mount the system:</p> Single-OPX+ SystemMulti-OPX+ System <p>Mount the OPX+ and the router in a rack or on a shelf.</p> <p>Place the OPX+ controllers and the OPT in the rack according to the rack scheme.</p> </li> <li> <p>Connect the system:</p> Single-OPX+stemSingle-OPX+ with OctaveMulti-OPX+ (&lt;= 6 devices)Multi-OPX+ (&gt;6 devices) <ol> <li>Connect the OPX+ to the power.</li> <li>Optional: Connect the OPX to an external reference clock.</li> <li>Connect the OPX+ to port 2 of the router.</li> </ol> <ol> <li>Connect the OPX+ clock input to the Octave clock output via an SMA cable with a DC Block.</li> <li>Optional: Connect the Octave to an external reference clock.</li> <li>Connect the OPX+ and octave to the power.</li> <li>Connect the OPX+ and octave to ports 2 &amp; 3 of the router.</li> </ol> <p>Up to 6 devices - OPX+es and Octaves.</p> <p>Connect the cables according to the connectivity scheme, in the following order:</p> <ol> <li>Connect the OPX+ and Octaves to the clock distributed from the OPT via an SMA cable with a DC Block.</li> <li>Connect the USB from the OPT to any USB port of the main OPX+.</li> <li>Optional: Connect the OPT to an external reference clock.</li> <li>Connect the OPX+ controllers via a SMA cable with a DC block to form a chain, connecting AUX 2 from one controller to another controller's AUX 3.</li> <li>Connect the optical cables used for data sharing between controllers. Remove the connectors' protectors if present.</li> <li>Connect the OPX+ and Octaves to the router via the ethernet cables, starting from port 2 onwards.</li> <li>Connect the OPX+, Octaves and the OPT to the power outlet.</li> </ol> <p>More than 6 devices - OPX+es and Octaves</p> <ol> <li>Use one OPT as a main OPT, connecting all other OPTs' Clk In to the main OPT clock outputs.</li> <li>Connect the USB from the main OPT to any USB port of the main OPX+.</li> <li>Connect the USB from the other OPTs to any USB port of other OPX+es.</li> <li>Optional: Connect the main OPT to an external reference clock.</li> <li>Connect the OPX+ and Octaves to the clock distributed from the OPTs via an SMA cable with a DC Block.</li> <li>Connect the OPX+ controllers via a SMA cable with a DC block to form a chain, connecting AUX 2 from one controller to another controller's AUX 3.</li> <li>Connect the optical cables used for data sharing between controllers. Remove the connectors' protectors if present.</li> <li>Connect the OPX+ and Octaves to the router via the ethernet cables, starting from port 2 onwards.</li> <li>Connect the OPX+, Octaves and the OPTes to the power outlet.</li> </ol> </li> <li> <p>Turn on all of the devices.</p> </li> <li> <p>The system will now start calibrations, the booting sequence should take a few minutes.</p> </li> <li> <p>Install the latest Python package by typing <code>pip install --upgrade qm-qua</code> in the desired Python environment.</p> </li> <li> <p>Verify that the connection to the server has been established by running the following commands:</p> <p><pre><code>from qm.QuantumMachinesManager import QuantumMachinesManager\nQuantumMachinesManager(host='xxx.xxx.xxx.xxx', port='80')  # enter the router's external IP in the host field\n</code></pre> You should see the message <code>qm - INFO - Health check passed</code> in the console.</p> </li> </ol>"},{"location":"qm-qua-sdk/docs/Hardware/opx%2Binstallation/#extra-topics","title":"Extra Topics","text":""},{"location":"qm-qua-sdk/docs/Hardware/opx%2Binstallation/#required-components","title":"Required components","text":"List of Components <p>To ensure a smooth installation, please make sure you have the following components:</p> Component name Quantity Notes OPX+ controllers \\(N_{opx+}\\) nan OPX Power cables \\(N_{opx+}\\) nan Router 1 Supplied by QM, with at least \\(N_{opx+}+1\\) ports Ethernet cables \\(1 + N_{opx+}\\) nan Router power supply 1 nan SMA cables \\(2 * N_{opx+} - 1\\) Only for a Multi-OPX+ system, Identical Cables DC Blocks \\(2 * N_{opx+} - 1\\) Only for a Multi-OPX+ system, Identical Cables Optical cables \\(6 * N_{opx+}\\) Only for a Multi-OPX+ system OPT 1 Only for a Multi-OPX+ system OPT Power cables 1 Only for a Multi-OPX+ system USB cable (OPT to main OPX+) 1 Only for a Multi-OPX+ system"},{"location":"qm-qua-sdk/docs/Hardware/opx%2Binstallation/#rack-scheme","title":"Rack Scheme","text":"Rack scheme <p>The system fits a standard 19\" rack. The sizes of the controllers are shown in the image below. The controllers can be mounted to the the rack with the supplied adaptors or stacked on a shelf. The router can be rack-mounted at the back of the rack or simply stacked. For a system of more than 2 OPX+ controllers, it is recommended to place the OPT in the center of the stack, such that equal-length cables will reach all controllers.</p> <p>The image below demonstrates the preferable OPX+ controllers and OPT placement for a system of 4 controllers.</p> <p></p>"},{"location":"qm-qua-sdk/docs/Hardware/opx%2Binstallation/#connectivity-scheme","title":"Connectivity Scheme","text":"<p>The multi OPX+ system has four required connectivity groups. Clock &amp; sync, Inter-controller communication, Network and Power</p> Clock &amp; sync <p>The clock signal is distributed by the OPT with an SMA cable per controller. An inner/outer DC block is optional and can be added to reduce ground loops. In addition, the main OPX+ of the cluster connects to the OPT via USB, to any of the 2 USB ports of the OPX+.</p> <p>A sync signal is passed between the controllers via SMA cables between the AUX ports. The connectivity should alternate between AUX1 (1.8V) to AUX1 (1.8V), and AUX2 (1.8V) to AUX2 (1.8V), as seen in the picture. An inner/outer DC block (supplied) is required to avoid potential damage to the devices and to reduce ground loops.</p> <p></p> <p>Note</p> <p>In some back panels the label are different. AUX1 is AUX2, and AUX2 is AUX3. The location of the port is the same as in the picture above.</p> Inter-controller Optical Connectivity Scheme <p>Data transfer and communication between controllers is operated via optical cables in an <code>all-to-all</code> connectivity. Each OPX+ has 12 optical ports and the preferred connectivity configuration differ with the number of controllers, as shown in the animations below.</p> <p>Click on each configuration to see the preferred connectivity scheme.</p> 2 OPX+ <p></p> 3 OPX+ <p></p> 4 OPX+ <p></p> 5 OPX+ <p></p> 6 OPX+ <p></p>"},{"location":"qm-qua-sdk/docs/Hardware/opx%2Binstallation/#configuring-the-router-to-static-ip","title":"Configuring the router to static IP","text":"Configuring the router to static IP <p>If static IP is needed for your system, follow these steps:</p> <ol> <li>Connect a computer to the router (to any port 2-10).</li> <li>Connect through the browser to <code>http://192.168.88.1</code> (Default gateway, the IP can be checked by typing <code>ifconfig</code> in a command prompt)</li> <li>Click cancel in the change password dialog.</li> <li>Click \"Quick Set\" at the top banner.</li> <li>Set up the Static IP:</li> </ol> <p></p> <ol> <li>Click \"apply configuration\" to save changes.</li> <li>Disconnect the computer from the router.</li> </ol> <p>Note</p> <p>The router's IP and MAC addresses can also be seen on this page.</p> View the router's IP and MAC addresses <p>Use the touch screen on the router's front panel to view information and optional configuration. At any stage you can click back and return to the previous screen.</p> <ol> <li> <p>Click on \"Interfaces\" once</p> </li> <li> <p>Click on \"ether1\"</p> </li> <li> <p>To view the IP address press \"Addresses\" and to view the MAC address press \"Info\"</p> </li> </ol>"},{"location":"qm-qua-sdk/docs/Introduction/config/","title":"The Configuration","text":"<p>Before diving into the many features and possibilities of QUA, it is important to understand the importance and the basics of the configuration in QUA. In the following tutorial we describe the components of the configuration, and the principles behind it.</p> <p>Note</p> <p>The configurations can vary a lot from project to project. The examples below are brought to demonstrate the general building blocks of the configuration. We don't recommend copy-pasting them into your own project.</p>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#overview","title":"Overview","text":"<p>The configuration is a crucial piece of the QOP which enables writing advanced QUA protocols simply and intuitively, using 'human language'.</p> <p>As described in the conceptual overview, the configuration is where we define our 'Quantum machine' with its elements and their operations.</p> <p>For example, a simple quantum machine may be the combination of two analog output ports connected to a superconducting qubit through an IQ mixer, together with a readout resonator connected to two analog input ports through another mixer.</p> <p>In the configuration we will define: (a partial list):</p> <ul> <li>The setup connectivity and associated dc offsets.</li> <li>Intermediate frequencies of the qubit and resonator.</li> <li>Waveforms, amplitudes and lengths of control and measurements pulses.</li> <li>IQ mixer correction parameters.</li> </ul> <p>When performing an operation (e.g., a pi pulse on the qubit), the relevant waveform will be sent out of the associated analog outputs, adjusted to the required length and amplitude, modulated by the qubit's frequency, and corrected to account for the IQ mixer imbalance. All of that in a simple, single line of code.</p> <p>This is an example of the powerful 'set and forget' approach of QUA.</p> <p>We will get back to this example later, but for now, let's look at some of the configuration's components.</p> <pre><code>config = {\n'version': 1,\n'controllers': {...},\n'elements': {...},\n'pulses': {...},\n'waveforms': {...},\n'digital_waveforms': {...},\n'integration_weights': {...},\n'mixers': {...},\n'oscillators': {...}\n}\n</code></pre> <p>As we can see, the configuration is essentially a Python dictionary of dictionaries, each defining a subsection of the quantum machine.</p> <p>Tip</p> <p>Time values in the configuration are in units of ns, and some are required to be divisible by 4.</p>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#configuration-components","title":"Configuration Components","text":"","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#version","title":"Version","text":"<p>Currently, the version value must be set to 1.</p>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#controllers","title":"Controllers","text":"<p>The controllers dictionary sets the input and output ports of the control hardware. For every controller we define the ports that participates in the quantum machine and can correct for DC offsets. In the example below we have one controller of type OPX1 with 4 analog outputs, 2 analog inputs and no digital outputs.</p> <pre><code>'controllers': {\n'con1': {\n'type': 'opx1',\n'analog_outputs': {\n1: {'offset': 0.0},\n2: {'offset': 0.0},\n3: {'offset': 0.0},\n4: {'offset': 0.0},\n},\n'digital_outputs': {},\n'analog_inputs': {\n1: {'offset': 0.0}\n2: {'offset': 0.0}\n}\n}\n},\n</code></pre>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#analog-outputs","title":"Analog Outputs","text":"<p>Each analog output port is defined with a <code>key:item</code> pair, where the key is the port number and the item is a Python dictionary holding some port-specific configuration. We can set an <code>offset</code>, a <code>filter</code>, and in  we can also specify a <code>delay</code> to the port in units of ns.</p> <p>For example, we can define an analog output with a 20 mV offset and a 71 ns delay as follows:</p> <pre><code>1: {'offset': 0.02, 'delay': 71}\n</code></pre> <p>For more information on the <code>filter</code> capabilities, please refer to the Guide on output filters.</p>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#elements","title":"Elements","text":"<p>In the element section, each element is defined with its own dictionary. For example, a quantum machine with two qubits, two readout resonators and a flux line is defined as follows:</p> <pre><code>'elements': {\n'qubit1': {...},\n'qubit2': {...},\n'resonator1': {...},\n'resonator2': {...},\n'flux_line': {...},\n}\n</code></pre> <p>Within each element's dictionary, we set the input and output parameters, we map between operations and pulses and more. Let's take a closer look at two examples:</p> <ul> <li>Mixed Inputs Element</li> <li>Single Input Element</li> </ul>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#mixed-inputs-element","title":"Mixed Inputs Element","text":"<pre><code>'qubit1': {\n'mixInputs': {\n'I': ('con1', 1),\n'Q': ('con1', 2),\n'lo_frequency': qubit_LO,\n'mixer': 'mixer_qubit'\n},\n'intermediate_frequency': qubit_IF,\n'operations': {\n'saturation': 'saturation_pulse',\n'pi': 'pi_pulse',\n'pi_half': 'pi_half_pulse',\n},\n</code></pre> <p>First, in the <code>'mixInput'</code> dictionary, we configure which hardware port is connected to the qubit, as \"seen\" from the qubit's perspective. In this case, analog output ports 1 and 2 from controller 1, are connected to the I and Q ports of the qubit's IQ mixer, respectively.</p> <p>Moreover, in the <code>'lo_frequency'</code> key we define the local oscillator's frequency as an integer in units of Hz, and in the <code>'mixer'</code> key we map to a mixer instance, as defined in the mixers section.</p> <p>The <code>'intermediate_frequency'</code> key defines the frequency at which the waveform samples, as defined in the waveforms section, will be modulated with. We can get a DC pulse by setting this frequency to zero.</p> <p>In the <code>'operations'</code> dictionary we map between the abstract operations relevant to the element (i.e., pi, saturation, measurement, etc.) and their respective pulse instance, as defined in the pulses section. This mapping between an <code>abstract</code> operation and a pulse allows keeping QUA codes simple and readable while accounting for the many possible variations, as no two qubits are the same.</p> <p>Taking a look at an example of a readout resonator, we can see a few more properties, relevant to a measurement element:</p> <pre><code>'resonator1': {\n'mixInputs': {...},\n'intermediate_frequency': rr_IF,\n'operations': {...},\n\"outputs\": {\n'out1': ('con1', 1)\n},\n'time_of_flight': 180,\n'smearing': 0\n},\n</code></pre> <p>Note how we define the output of an element, from the perspective of the element. In the case above, the output of the resonator is connected to input 1 of controller 1. The <code>time_of_flight</code> and <code>smearing</code> keys are parameters related to the timing of the signal and are further explained in the Guide on demodulation, section on timing of measurement.</p>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#single-input-element","title":"Single Input Element","text":"<pre><code>'flux_line': {\n'singleInput': {\n'port': ('con1', 9),\n},\n...\n},\n</code></pre> <p>In the <code>'singleInput'</code> dictionary, we configure which hardware port is connected to the <code>flux_line</code> element, as \"seen\" from the flux line's perspective. In this case analog output port 9 from controller 1 is connected to the flux line.</p>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#pulses","title":"Pulses","text":"<p>Similar to other components, every pulse is defined with a dictionary. Let\u2019s take a look at an example of a simple pi pulse:</p> <pre><code>'pi_pulse': {\n'operation': 'control',\n'length': 60,\n'waveforms': {\n'I': 'pi_wf',\n'Q': 'zero_wf'\n}\n},\n</code></pre> <p>In the <code>'operation'</code> key we define whether the pulse is a control or a measurement operation. The <code>'length'</code> sets the pulse duration in units of nanoseconds and must be divisible by 4. In the <code>'waveforms'</code> key, we map between the input name (defined in the element section) and a waveform, as defined in the waveforms section. Note that even though the waveform in Q is set to zero, there will be an output from both ports. See the following Mixed input elements section in QUA overview for more details.</p> <p>For a measurement pulse we also map to optional integration weights to be used in the demodulation process, as shown below. You can read more about the integration weights usage in the Guide on measure statement features.</p> <pre><code>\"readout_pulse\": {\n\"operation\": \"measurement\",\n...\n\"integration_weights\": {\n\"cos\": \"integW_cos\",\n\"sin\": \"integW_sin\",\n},\n</code></pre> <p>Note</p> <p>If the pulse is related to a Single Input element, the <code>'waveforms'</code> key holds only one waveform. For example:</p> <pre><code>'const_flux_pulse': {\n...\n'waveforms': {\n'single': 'const_flux_wf',\n},\n},\n</code></pre>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#waveforms","title":"Waveforms","text":"<p>In this section we define the waveforms to be used in the pulses. We can define either a constant value waveform or an arbitrary one. An arbitrary waveform needs to be provided with a list of samples with length which is equal to the pulse duration. i.e. A Gaussian. Note that in both cases, we define the envelope of the pulse before the modulation by the IF frequency. For example, in the code below we define a constant 0.4 Volt waveform and an arbitrary waveform.</p> <pre><code>'waveforms': {\n'const_flux_wf': {\n'type': 'constant',\n'sample': 0.4\n},\n'pi_wf': {\n'type': 'arbitrary',\n# a list of values describing a Gaussian of length equal to the pulse duration\n'samples': [0, 1.2486367355980437e-05, 2.6352133635387178e-05, ... , 2.6352133635387273e-05, 1.248636735598048e-05, 0]\n},\n</code></pre> <p>Tip</p> <p>In the QUA tools section you can find a lot of useful tools for writing QUA programs. In particular, Config tools which include Waveform Tools package that provides tools for easy waveform creation and manipulation.</p>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#digital-waveform","title":"Digital Waveform","text":"<p>In this section we define the digital waveforms to be used in the program as follows:</p> <pre><code>'digital_waveforms': {\n'ON': {\n'samples': [(1, 0)]\n}\n},\n</code></pre> <p>Here we defined a digital high waveform named 'ON' that will be played for the entire duration of the pulse it is associated with. Read more on how to configure digital outputs.</p>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#integration-weights","title":"Integration Weights","text":"<p>The integration weights are used in the demodulation process as part of the measurement and are defined as a list of tuples. The first element in every tuple is the value of the integration weight and the second is the duration, in ns, for which this value should be used. The duration must be divisible by 4.</p> <p>In the simple example below, we define two sets of integration weights, <code>\"cos\"</code> and <code>\"sin\"</code>. The first have the value <code>1.0</code> in the cosine component and <code>0.0</code> in the sine component for the entire duration of of the pulse. Read more about the usage of integration weights and see an advanced usage of the integration weights.</p> <pre><code>\"integration_weights\": {\n\"cos\": {\n\"cosine\": [(1.0, readout_len)],\n\"sine\": [(0.0, readout_len)]\n},\n\"sin\": {\n\"cosine\": [(0.0, readout_len)],\n\"sine\": [(1.0, readout_len)],\n},\n},\n</code></pre> <p>Tip</p> <p>In the QUA tools repository you can find a lot of useful tools for writing QUA programs. In particular, Config tools which include Integration Weights Tools package that allows for easy conversion and compression of the integration weights.</p>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#mixers","title":"Mixers","text":"<p>In this section we configure the IQ mixer instances that are used by the elements. Each mixer instance contains a list of dictionaries for the correction matrix for every pair of IF and LO.</p> <pre><code>'mixers': {\n'mixer_qubit': [\n{'intermediate_frequency': qubit_IF, 'lo_frequency': qubit_LO,\n'correction': [1.0, 0.0, 0.0, 1.0]}\n],\n'mixer_RR': [\n{'intermediate_frequency': rr_IF, 'lo_frequency': rr_LO,\n'correction': [1.0, 0.0, 0.0, 1.0]}\n],\n}\n</code></pre>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#oscillators","title":"Oscillators","text":"<p>In the oscillators section, we can specifically define oscillators that can be shared between elements. When multiple elements share an oscillator, then any operation on that oscillator (frequency, frame or correction changes) will affect both elements. It is defined as follows:</p> <pre><code>'oscillators': {\n'osc': {...},\n'osc2': {...},\n}\n</code></pre> <p>With each oscillator defined as follows:</p> <pre><code>\"osc\": {\n\"intermediate_frequency\": osc_IF,\n'lo_frequency': osc_LO,\n'mixer': 'mixer_qubit'\n}\n</code></pre> <p>Defining the <code>lo_frequency</code> and <code>mixer</code> is optional and is only used if the oscillator is being used by an element with a <code>mixInputs</code>. Note that even if two elements output to different ports (and different mixers), they will have to use the same correction matrix.</p> <p>In order to use the oscillator with multiple elements, the oscillator must be declared in the element's configuration instead of declaring an <code>intermediate_frequency</code>. For example:</p> <pre><code>'qubit1': {\n'mixInputs': {...},\n'oscillator': \"osc\",\n'operations': {...}\n</code></pre>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/config/#further-details","title":"Further details","text":"<p>You can find a <code>beta</code> tool detailing the complete config specification.</p>","boost":3},{"location":"qm-qua-sdk/docs/Introduction/qop_overview/","title":"QOP Conceptual Overview","text":"<p>This section describes the main concepts constituting the Quantum Orchestration Platform (QOP).</p>"},{"location":"qm-qua-sdk/docs/Introduction/qop_overview/#quantum-orchestration-platform","title":"Quantum Orchestration Platform","text":"<p>QM's Quantum Orchestration Platform (QOP) is a hardware and software platform for designing quantum control protocols, executing them on a wide range of quantum hardware platforms and optimizing performance. QOP is designed to meet the extremely demanding requirements of quantum control, including synchronized multi-channel pulse sequences, pulse parametrization, real-time classical calculations, complex flow control with real-time decision making, and ultra-low latency feedback.</p>"},{"location":"qm-qua-sdk/docs/Introduction/qop_overview/#quantum-machine","title":"Quantum Machine","text":"<p>It is important to understand the QOP concept of a Quantum Machine. As shown in the figure below, QOP's control hardware, the Operator-X (OPX), is integrated with your quantum system.</p> <p>The combination of your quantum system and the OPX are referred to as a Quantum Machine. The Quantum Machine is configured using a python dictionary, containing the relevant parameters of the experimental setup and defining the possible operations.</p> <p>Our programing language QUA allows programming complex protocols that run in real-time on the Quantum Machine. Real-time execution of QUA Programs is made possible thanks to the QOP's unique compiler and FPGA-based Pulse Processor, thus saving huge amounts of time and resources, improving performance, and opening new possibilities in quantum experiments.</p> <p>The QM Orchestrator is the system's core software component. The quantum developer communicates with QM Orchestrator using a Python package. See the figure below.</p> <p> Conceptual presentation of a quantum machine</p>"},{"location":"qm-qua-sdk/docs/Introduction/qop_overview/#qua-development-environment","title":"QUA Development Environment","text":"<p>On the client's computer, the quantum developer communicates with the QOP using a Python package.</p> <p>Via the desktop app, the user finds the orchestrator on the network, initialize communication with it, and manages QM's software versions and updates.</p> <p>The Python package is used by the quantum developer to:</p> <ul> <li>Instantiate quantum machines and communicate with them (via the quantum machine API).</li> <li>Write QUA programs and execute them on quantum machines.</li> <li>Execute and simulate Qua programs.</li> </ul> <p>Read more about the Python package features in the QUA Langauge Features guide.</p> <p> Quantum Machine and QUA Environment</p>"},{"location":"qm-qua-sdk/docs/Introduction/qop_overview/#multi-quantum-machine-orchestration","title":"Multi Quantum Machine Orchestration","text":"<p>As shown in the figure below, QOP can support many Quantum Machines in the same platform in a seamless way:</p> <p>The orchestrator creates an abstraction of the quantum machines, which allows QUA developers to send programs from any client computer to be executed on any of the quantum machines. Multiple QUA developers can work in parallel from one or more client interfaces.</p> <p> Scaled-up: multiple quantum machines, OPXs per machine, developers</p>"},{"location":"qm-qua-sdk/docs/Introduction/qop_overview/#scalable-architecture","title":"Scalable Architecture","text":"<p>Multiple OPXs can be connected to a single quantum system, to allow working with a large number of qubits, while the software interface and in particular programing QUA programs, remains the same.</p>"},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/","title":"Overview of QUA","text":"<p>A QUA program defines the sequence of:</p> <ol> <li>Pulses sent to the quantum device.</li> <li>Measurements of pulses returning from the quantum device.</li> <li>Real-time classical calculations done on the measured data.</li> <li>Real-time classical calculations done on general classical variables.</li> <li>Real-time decision making that affects the flow of the program.</li> </ol> <p>In addition to the specification of which pulses are played, it also specifies when they should be played through both explicit and implicit statements and dependency constructs. Thus, a QUA program also defines exactly the timing in which pulses are played, down to the single sample level.</p> <p>The pulses syntax defines an implicit pulse dependency, which determines the order of pulse execution. The dependency can be summarized as follows:</p> <ol> <li>Each pulse is played immediately, unless dependent on a previous pulse, transformation or calculation.</li> <li>Pulses applied to the same quantum element are dependent on each other according to the order in which they are    written in the program</li> </ol> <p>We first describe in detail the pulses and measurement statements and their relation to the configuration and then list and specify the language statements and data types.</p> <p>QUA is a pulse-level-control programming language for quantum devices. This means that it allows programmers to control the shapes and timing of the pulses that are sent to the quantum elements in the quantum device. This enables programmers to perform operations on them, as well as set the timing and parameters of the measurement sequences applied to the signals returning from the quantum elements. Thus, the most basic statements in QUA are the <code>play()</code> and <code>measure()</code> statements.</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#play-statement","title":"Play Statement","text":"<p>The most basic statement in QUA is the <code>play()</code> statement:</p> <pre><code>play(pulse, element)\n</code></pre> <p>This statement instructs the OPX to send the indicated pulse to the indicated element. Importantly, the OPX will modify or manipulate the pulse according to the element's properties defined in the configuration.</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#analog-waveform-manipulations","title":"Analog Waveform Manipulations","text":"","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#single-input-element","title":"Single Input Element","text":"<p>If the considered element has a single input, the pulse sent to it must be defined with a single waveform. For example, the configuration file would look like:</p> <pre><code>'elements': {\n'qubit': {\n'singleInput': {\n'port': ('con1', 1),\n},\n'intermediate_frequency': 70e6,\n'operations': {\n'pulse1': 'pulse1'\n},\n},\n},\n'pulses': {\n'pulse1': {\n'operation': 'control',\n'length': 16,\n'waveforms': {\n'single': 'wf1',\n},\n}\n},\n'waveforms': {\n'wf1': {\n'type': 'arbitrary',\n'samples': [0.49, 0.47, 0.44, ...]\n},\n}\n</code></pre> <p>Let us denote the samples of the waveform by \\(s_i\\). The <code>play()</code> statement instructs the OPX to modulate the waveform samples with the <code>intermediate_frequency</code> of the element:</p> \\[ \\tilde{s_i} = A s_i \\cos(\\omega_{IF} t + \\phi_F), \\] <p>Where \\(A\\) is the amplitude transformation, \\(\\omega_{IF}\\) is the intermediate frequency defined in the configuration of the element and \\(\\phi_F\\) is the frame phase, initially set to zero (see the <code>frame_rotation_2pi()</code> function specifications for more information). The OPX plays \\(\\tilde{s_i}\\) to the analog output port defined in the configuration of the element (port 1 in the above example).</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#mixed-inputs-element","title":"Mixed Inputs Element","text":"<p>If the element has two inputs (i.e. two output ports of the OPX are connected to the element via an IQ mixer), a <code>mixer</code> and <code>lo_frequency</code> are also defined in the configuration. For example:</p> <pre><code>'elements': {\n'qubit': {\n'mixInputs': {\n'I': ('con1', 1),\n'Q': ('con1', 2),\n'mixer': 'mixer1',\n'lo_frequency': 5.1e9,\n},\n'intermediate_frequency': 70e6,\n'operations': {\n'pulse1': 'pulse1'\n},\n},\n},\n</code></pre> <p>A pulse that is sent to such element must be defined with two waveforms. For example:</p> <pre><code>'pulses': {\n'pulse1': {\n'operation': 'control',\n'length': 12,\n'waveforms': {\n'I': 'wf_I',\n'Q': 'wf_Q',\n},\n},\n},\n'waveforms': {\n'wf_I': {\n'type': 'arbitrary',\n'samples': [0.49, 0.47, 0.44, ...]\n},\n'wf_Q': {\n'type': 'arbitrary',\n'samples': [-0.02, -0.03, -0.03, ...]\n},\n}\n</code></pre> <p>In addition, a mixer must be defined with a mixer correction matrix that corresponds to the <code>intermediate_frequency</code> and the <code>lo_frequency</code>. For example:</p> <pre><code>'mixers': {\n'mixer1': [\n{'intermediate_frequency': 70e6, 'lo_frequency': 5.1e9, 'correction': [0.9, 0.003, 0.0, 1.05]}\n],\n}\n</code></pre> <p>Denoting the samples of the waveforms by \\(I_i\\) and \\(Q_i\\), the <code>play()</code> statement instructs the OPX to modulate the waveforms with the intermediate frequency of the element and to apply the mixer correction matrix in the following way:</p> \\[ \\begin{pmatrix} \\tilde{I_i} \\\\ \\tilde{Q_i} \\end{pmatrix} = \\begin{pmatrix} C_{00} &amp; C_{01}\\\\ C_{10} &amp; C_{11} \\end{pmatrix} \\begin{pmatrix} \\cos(\\omega_{IF}t+\\phi_F) &amp; -\\sin(\\omega_{IF}t+\\phi_F)\\\\ \\sin(\\omega_{IF}t+\\phi_F) &amp; \\cos(\\omega_{IF}t+\\phi_F) \\end{pmatrix} \\begin{pmatrix} A_{00} &amp; A_{01}\\\\ A_{10} &amp; A_{11} \\end{pmatrix} \\begin{pmatrix} I_i \\\\ Q_i \\end{pmatrix} \\label{pulse_output_chain} \\] <p>Where \\(\\omega_{IF}\\) is the intermediate frequency defined in the configuration of the element and \\(\\phi_F\\) is the frame phase, initially set to zero (see the <code>frame_rotation_2pi()</code> function specifications for more information). \\(A_{ij}\\)'s are the matrix element defining the amplitude transformations. \\(C_{ij}\\)'s are the matrix elements of the correction matrix defined in the mixer configuration for the relevant <code>intermediate_frequency</code> and <code>lo_frequency</code>, see The C Matrix for more information. The OPX then plays \\(\\tilde{I_i}\\) and \\(\\tilde{Q_i}\\) to the analog output ports defined in the configuration of the element (in the above example, port 1 and port 2, respectively).</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#the-c-matrix","title":"The C Matrix","text":"<p>Just before a pulse leaves the pulse processor, it is multiplied by the C (correction) matrix to compensates the mixer gain and phase imbalances. It is an arbitrary 2x2 transformation matrix multiplying the \\((I,Q)\\) vector supplied by the user:</p> \\[ C = \\begin{pmatrix} C_{00} &amp; C_{01}\\\\ C_{10} &amp; C_{11} \\end{pmatrix} \\] <p>Note</p> <p>The elements of C are limited to the range of \\(-2\\) to \\(2 - 2^{-16}\\) with a \\(2^{-16}\\) accuracy.</p> <p>The matrix values are specified for each element from the <code>correction</code> parameter in the <code>mixers</code> construct in the configuration:</p> <pre><code>'mixers': {\n'mixer1': [\n{'intermediate_frequency': 70e6, 'lo_frequency': 5.1e9, 'correction': [0.9, 0.003, 0.0, 1.05]}\n],\n}\n</code></pre> <p>The matrix can also be updated when a program is running by either:</p> <ul> <li>Using the Quantum Machine API: <code>set_mixer_correction()</code>.</li> <li>Using the Job API: <code>set_element_correction()</code>.</li> <li>Using the <code>update_correction()</code> function in QUA.</li> </ul> <pre><code># updating the C matrix associated with qubit\nupdate_correction('qubit', C_00, C_01, C_10, C_11)\n</code></pre> <p>The dynamic correction parameters can of course be calculated in real time, based on, for example, the outcome of measurements.</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#amplitude-transformations","title":"Amplitude transformations","text":"<p>The pulses amplitude can be changed via the <code>amp()</code> parameter inside the <code>play()</code> command:</p> <pre><code>play(pulse*amp(A), element)\n</code></pre> <p>Where <code>A</code> can either be a matrix (In case that the element is a Mixed Inputs Element or a Scalar (for both kind of elements). If a scalar <code>A</code> is supplied to a Mixed Inputs Element, then it is multiplied by the identity matrix)</p> <p>Note</p> <p>A is limited to the range of \\(-2\\) to \\(2 - 2^{-16}\\) with a \\(2^{-16}\\) accuracy.</p> <p>Note</p> <p>This transformation requires real-time computation that can introduce gaps. It should only be used when the pulse amplitude needs to be updated during the program, either dynamically in QUA or manually.</p> <p>For usage examples, see <code>play()</code>.</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#digital-waveform-manipulations","title":"Digital Waveform Manipulations","text":"<p>To understand how digital signals are treated, we will consider the following example: We output an analog signal to a <code>qubit</code>, and then perform a readout of the same pulse as it returns from the <code>qubit</code>. Both the input and output are gated by switches. This is shown in the figure below:</p> <p></p> <p>The signal going from the OPX has some propagation delay as it travels down the wire and towards the switch. The returning signal will be further delayed by all of the elements until it reaches the second switch. We therefore want to delay the digital signal such that the switch is open at the correct timing. Additionally, there may be some dispersion broadening the analog pulse and we may want to take this effect into account. Because they are associated with the physical configuration of the connections to the device (wire lengths, resonator ring up times, etc). Setting up these parameters in QUA is done by setting the values as part of the quantum element configuration.</p> <p>Important</p> <p>The maximal number of digital routes is 12. That is, the total number of digital inputs that can be defined for all elements in a program. In addition, recording an ADC trace also uses a digital route. Attempting to declare more routes, will result in a failure to allocate resources.</p> <p>Note</p> <p>There is an intrinsic delay of the analog channel with respect to the digital channel of 136ns.</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#configuring-a-digital-pulse","title":"Configuring a digital pulse","text":"<p>To define a digital input of a quantum element the configuration must have the following three properties: <code>port</code>, <code>delay</code>, and <code>buffer</code>. <code>delay</code> represents the signal propagation time and <code>buffer</code> defines the broadening of the signal. It is a symmetrical window before and after the analog pulse. Both parameters are in units of ns. Configuration is done as follows:</p> <pre><code>'elements': {\n'qubit': {\n'mixedInputs': {\n'I': ('con1', 1),\n'Q': ('con1', 2),\n'mixer': 'mixer1',\n'lo_frequency': 5.1e9,\n},\n'intermediate_frequency': 70e6,\n'digitalInputs': {\n'output_switch': {\n'port': ('con1', 1),\n'delay': 99,\n'buffer': 7,\n},\n'input_switch': {\n'port': ('con1', 2),\n'delay': 144,\n'buffer': 20,\n}\n},\n'operations': {\n'pulse1': 'pulse1'\n},\n'outputs': {\n'output1': ('con1', 1)\n},\n'time_of_flight': 184,\n'smearing': 0\n},\n}\n</code></pre>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#defining-digital-pulses","title":"Defining digital pulses","text":"<p>A pulse that is played to a quantum element with a digital input, can include a single digital marker which points to a single digital waveform. For example:</p> <pre><code>'pulses': {\n'pulse1': {\n'operation': 'control',\n'length': 40,\n'waveforms': {\n'I': 'wf_I',\n'Q': 'wf_Q',\n},\n'digital_marker': 'digital_waveform_high'\n},\n},\n'digital_waveforms': {\n'digital_waveform_high': {\n'samples': [(1, 0)]\n},\n}\n</code></pre> <p>The encoding of the digital waveform is a list of the form: <code>[(value, length), (value, length), \u2026, (value, length)]</code>, where each value is either 0 or 1, indicating the digital value to be played (digital high or low). Each length is an integer indicating for how many nanoseconds the value should be played. A length 0 indicates that the corresponding value is to be played for the remaining duration of the pulse. In the example above, the digital waveform is a digital high for the entire duration of the pulse.</p> <p>Note</p> <p>If the digital waveform is longer than the pulse length, then it will be truncated.</p> <p>Note</p> <p>Changing the pulse duration inside a <code>play()</code> command will not change the sequences of the digital waveform but will pad the digital waveform to fit the new pulse duration. For example, a digital waveform defined as <code>[(1,10), (0,10), (1,0)]</code> associated with some pulse of length 100, will have the same initial sequence <code>(1,10), (0,10)</code> and will be padded with 1's to fit the new pulse length upon using <code>play('pulse', 'qubit', duration=200)</code></p> <p>When such pulse is played to the element, via the <code>play()</code> or the measurement command, the digital waveform is sent to all the digital inputs of the element. For each digital input the OPX performs the following:</p> <ul> <li>Delays the digital waveform by the <code>delay</code> that is defined in the configuration of the digital input (given in ns).</li> <li>For a simple waveform which is high for the entire duration, it expands the digital waveform by twice the <code>buffer</code>   parameter, once from each side (given in ns) - See note below for the full behavior.</li> <li>Plays the digital waveform to the digital output of the OPX as defined in the associated quantum element.</li> </ul> <p>Note</p> <p>The digital waveform is actually convolved with a digital pattern that is high for \\(1 + 2b\\), where <code>b</code> is the <code>buffer</code>.</p> <p>In the example above a <code>play('pulse1', 'qubit')</code> command would play:</p> <ul> <li>A digital waveform to digital output 1, which starts 44 ns before the analog waveform (\\(136 - 99 + 7 = 44\\)),   and is high for 54 ns (the length of the pulse plus 2*7 ns).</li> <li>A digital waveform to digital output 2, which starts 12 ns before the analog waveform (\\(136 - 144 + 20 = 12\\)),   and is high for 80 ns (the length of the pulse plus 2*20 ns).</li> </ul> <p>Where 136 ns is the intrinsic delay discussed above.</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#digital-markers-and-quantum-element-readout","title":"Digital markers and quantum element readout","text":"<p>The output of a quantum element can be read by the OPX. Returning to the example we considered above, the same effects of delay and dispersion can affect the readout. For this reason we configure the time-of-flight and smearing parameters, which are identical to the delay and buffer we defined above, but are for the readout of the element's output. This is discussed in detail in the Demodulations and measurement section. The digital waveform used to define this behavior is called a digital marker and is a part of the way the OPX performs a raw ADC stream readout. When a digital marker is not defined, a raw ADC stream will be measured as a list of zeros. This is a common pitfall when taking raw analog data. We emphasize this point:</p> <p>Warning</p> <p>Even if a measurement is performed without the need of a digital channel, a digital marker MUST be defined if an ADC stream is required.</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#frequency-and-phase-transformations","title":"Frequency and phase transformations","text":"<p>In this section we describe how to control the frequency/phase matrix in Eq. \\(\\eqref{pulse_output_chain}\\). A more detailed discussion on phase and frame can be found in Phase and Frame in QUA.</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#updating-the-frequency","title":"Updating the frequency","text":"<p>The frequency associated with an element can be updated using the <code>update_frequency()</code> function in the following way:</p> <pre><code># update frequency of element_1 to 10 MHz\nupdate_frequency('element_1', 10e6)\n# update frequency of element_1 with the value stored in the variable `frequency`\nupdate_frequency('element_1', frequency)\n# update the frequency with a continuous phase transition\nupdate_frequency('element_1', frequency, keep_phase=True)\n</code></pre>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#sub-hz-resolution","title":"Sub-Hz resolution","text":"<p>In the configuration, the element's frequency is defined in units of Hz. Sub-Hz resolution can be achieved by setting the <code>Units</code> parameter to the desired resolution. For example:</p> <pre><code># update frequency of element_1 with mHz accuracy\nupdate_frequency('element_1', 100755, units='mHz')  # will set the frequency to 100.755 Hz\n</code></pre>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#resetting-the-global-phase","title":"Resetting the global phase","text":"<p>One can reset the global phase \\(\\omega_{IF}t\\) associated with a frequency using <code>reset_phase()</code>:</p> <pre><code># resetting the phase of element_1\nreset_phase('element_1')\n</code></pre>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#updating-the-frame-phase","title":"Updating the frame phase","text":"<p>Adding a fixed phase \\(\\phi_F\\) is possible using the <code>frame_rotation()</code> or <code>frame_rotation_2pi()</code> functions:</p> <pre><code># setting the phase of element_1 to pi\nframe_rotation(np.pi, 'element_1')\n# setting the phase of element_1 to pi using the 2pi function\nframe_rotation_2pi(0.5, 'element_1')\n# setting the phase of element_1 to the value stored in variable phi\nphi = declare(fixed)\nassign(phi, 0.5)\nframe_rotation_2pi(phi, 'element_1')\n</code></pre> <p>Note</p> <p>The phase is accumulated with a resolution of 16 bit. Therefore, N changes to the phase can result in a phase inaccuracy of about \\(N \\cdot 2^{-16}\\). To null out this accumulated error, it is recommended to use <code>reset_frame()</code> from time to time.</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#resetting-the-frame-phase","title":"Resetting the frame phase","text":"<p>To reset the frame phase \\(\\phi_F\\) back to zero, the <code>reset_frame()</code> command can be used:</p> <pre><code># setting F to be the identity matrix (phi=0)\nreset_frame('element_1')\n</code></pre>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#measure-statement","title":"Measure statement","text":"<p>The measurement statement, <code>measure()</code>, is the most complex statement in QUA, and looks like this:</p> <pre><code>measure(pulse, element, stream_name, demod.full(integration_weights, variable), demod.full(integration_weights, variable))\n</code></pre> <p>It can only be done for an element that has outputs defined in the configuration. For example:</p> <pre><code>'elements': {\n'resonator': {\n'mixedInputs': {\n'I': ('con1', 3),\n'Q': ('con1', 4),\n'mixer': 'mixer1',\n'lo_frequency': 7.3e9,\n},\n'operations':{'pulse1':'pulse1'},\n'intermediate_frequency': 50e6,\n'outputs': {\n'out1': ('con1', 1),\n},\n'time_of_flight': 196,\n'smearing': 20,\n},\n}\n</code></pre> <p>As seen in this example, when a quantum element has outputs, two additional properties must be defined: <code>time_of_flight</code> and <code>smearing</code>. The pulse used in a measurement statement must also be defined as a measurement pulse. If integration or demodulation is to be used (as in the example have) then it must also have <code>integration_weights</code> defined. For example:</p> <pre><code>'pulses': {\n'pulse1': {\n'operation': 'measurement',\n'length': 400,\n'waveforms': {\n'I': 'meas_wf_I',\n'Q': 'meas_wf_Q',\n},\n'integration_weights': {\n'integ1': 'integW1',\n'integ2': 'integW2',\n},\n},\n},\n'integration_weights': {\n'integW1': {\n'cosine': [0.0, 0.5, 1.0, 1.0, ..., 1.0, 0.5, 0.0]\n'sine': [0.0, 0.0, ..., 0.0]\n},\n'integW2': {\n'cosine': [0.0, 0.0, ..., 0.0]\n'sine': [0.0, 0.5, 1.0, 1.0, ..., 1.0, 0.5, 0.0]\n},\n}\n</code></pre> <p>A measurement statement, such as the one shown above, instructs the OPX to:</p> <ol> <li>Send the indicated pulse to the indicated element, manipulating the waveforms in the same manner that is described    in the <code>play()</code> statement section above.</li> <li>After a time period <code>time_of_flight</code> (given in ns), samples the returning pulse at the OPX input port/s that are    connected to the output/s of the element. It saves the sampled data under <code>stream_name</code>    (unless <code>stream_name</code> = <code>None</code>, in which case the sampled data will not be saved).    The sampling time window will be of a duration that is the duration of the pulse plus twice the smearing    (given in ns). This accounts for the returning pulse that is longer than the sent pulse due to the response of the    quantum device, as well as for the cables and other elements in the pulse's path.</li> <li>Demodulate the sampled data with a frequency <code>intermediate_frequency</code>, defined in the configuration of the element,    perform weighted integration on the demodulated data with the <code>integration_weights</code> that are defined in the    configuration, and put the result in the indicated variable. The OPX can perform multiple demodulations and    integrations at any given point in time, which may or may not be a part of the same measurement statement.    The precise mathematical operation on the sampled data is:</li> </ol> \\[ \\mathrm{variable} = \\sum_i \\tilde{s_i} \\left[ w_c^i \\cos(\\omega_{IF} t_i + \\phi_F) + w_s^i\\sin(\\omega_{IF} t_i + \\phi_F)\\right] \\] <p>where \\(\\omega_{IF}\\) corresponds to <code>intermediate_frequency</code>, \\(\\phi_F\\) is the frame phase discussed above, and \\(w_c^i\\) and \\(w_s^i\\) are the cosine and sine <code>integration_weights</code>, respectively.</p> <p>For a more detailed description of the measurement operation, see Measure Statement Features.</p> <p>The OPX also supports the demodulation of two outputs simultaneously, utilizing the following formula:</p> \\[\\begin{eqnarray} \\mathrm{variable} &amp;= \\sum_i \\tilde{s}_{1i} \\left[ w_{c1}^i \\cos(\\omega_{IF} t_i + \\phi_F) + w_{s1}^i\\sin(\\omega_{IF} t_i + \\phi_F)\\right] \\nonumber \\\\               &amp;+ \\tilde{s}_{2i} \\left[ w_{c2}^i \\cos(\\omega_{IF} t_i + \\phi_F) + w_{s2}^i\\sin(\\omega_{IF} t_i + \\phi_F)\\right] \\end{eqnarray}\\] <p>This feature, called dual demodulation, allows us to perform a demodulation process on two ADC signals simultaneously. Further explanation can be found in the Demodulation and measurement section.</p> <p>Note</p> <p>The <code>integration_weights</code> are defined with a time resolution of 4 ns, while the sampling is done with a time resolution of 1 ns (1GSa/sec sampling rate):</p> \\[ w_{c/s}^{4i} = w_{c/s}^{4i} + w_{c/s}^{4i+1} + w_{c/s}^{4i+2} + w_{c/s}^{4i+3} \\]","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/qua_overview/#multiple-opx-timing-and-latencies","title":"Multiple OPX timing and latencies","text":"<p>When operating with multiple controllers, an additional latency due to communication overhead might occur. This happens in two cases:</p> <ol> <li>When aligning two quantum elements which are on separate controllers, and it is impossible for the compiler    to determine how long each of the elements will need to wait for the other (for example, due to a branching    in the code)</li> <li>When performing a measurement on a quantum element in one controller and using the result of that measurement    to affect the playing of a quantum element in a different controller.</li> </ol> <p>When transferring arrays, the latency will also increase with the length of the array.</p>","boost":2.0},{"location":"qm-qua-sdk/docs/Introduction/use_case/","title":"Example Use Case","text":"<p>The quickest way to understand the QOP's unique approach and to start performing quantum computing experiments with it is through use case examples.</p> <p>This section describes a typical use case example, end-to-end. The use case begins by discussing the theoretical background of the experiment and its goals and showing a typical setup on which it is implemented. We then show, step by step, how to program the QOP to perform this experiment, how to execute it, and how to retrieve the results.</p>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#goal-of-the-experiment","title":"Goal of the Experiment","text":"<p>In this experiment, we want to measure Rabi oscillations that are oscillations of the qubit state when driven by a control signal.</p> <p>Assuming that the qubit is initially in the ground state (state \\(\\left|0\\right&gt;\\)), a drive pulse is applied to rotate it on the Bloch sphere around a rotation axis in the x-y plane. The qubit state is then measured by calculating the effect of the readout resonator (that is coupled to the qubit) on a measurement pulse. Since the rotation angle, and consequently the probability to find the qubit in the excited state (\\(\\left|1\\right&gt;\\)), depends on the amplitude of the drive pulse, this protocol is repeated with varying amplitudes (\\(a\\)). For averaging purposes, this sequence is itself repeated many times. The extracted transition probability is then plotted as a function of the drive amplitude, exhibiting the so-called power Rabi oscillations. Note that the rotation angle induced by the drive can be calculated from the transition probability.</p> <p>This experiment provides an important tool for calibrating quantum gates. For example, the amplitude at which the qubit reaches a rotation of 180 degrees gives us the required amplitude for performing an X-gate (the quantum NOT gate). Similarly, we can run this program to identify the amplitude required to perform a \u03c0/2-rotation.</p>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#system-setup","title":"System Setup","text":"<p>An example of the quantum machine setup is shown in the figure below. The quantum device is a superconducting circuit composed of a single, fixed frequency qubit and a readout resonator, governed by the following Hamiltonian:</p> \\[ H_0 = \\frac{\\hbar}{2}\\omega_Q \\sigma_z + \\hbar \\omega_R a^\\dagger a + \\hbar g (a^\\dagger \\sigma^- + a \\sigma^+). \\] <p>Since the interaction between the qubit and resonator is dispersive (\\(|\\omega_R - \\omega_Q| \\gg g\\)), we can make an approximation that leads to the following form of the Hamiltonian:</p> \\[ H_0 = \\frac{\\hbar}{2}\\left( \\omega_Q + \\frac{g^2}{\\Delta}\\right)\\sigma_z + \\hbar \\left( \\omega_R + \\frac{g^2}{\\Delta}\\sigma_z\\right)a^\\dagger a, \\] <p>where \\(\\Delta = \\omega_Q - \\omega_R\\). Finally, we can explicitly include the qubit and resonator driving terms, leading to the total Hamiltonian:</p> \\[ H = H_0 + \\hbar s(t)\\sigma_x + \\frac{m(t)}{2}(a^\\dagger e^{-i\\omega t} + a e^{i\\omega t}), \\] <p>where \\(s(t)\\) and \\(m(t)\\) are the qubit and resonator driving terms.</p> <p>We assume that the frequencies of both the qubit and the resonator were calibrated in advance.</p> <p> Setup of the Quantum Orchestration System</p>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#methodology","title":"Methodology","text":"<p>A signal, at the resonance frequency of the qubit, of the form</p> \\[ s(t) = A\\cos(\\omega_Q t + \\phi) \\] <p>rotates the Bloch vector of the qubit at a rate \\(A\\) around the axis which is on the x-y plane and rotated by an angle \\(\\phi\\) from the x-axis:</p> <p> Qubit rotation</p> <p>If the parameters \\(A(t)\\) and \\(\\phi(t)\\) are varied slowly compared to \\(\\omega_Q\\), then this still holds at each point in time. Thus, if a pulse is sent (i.e. a signal that is finite in time) to the qubit of the form</p> \\[ s(t) = A(t) \\cos(\\omega_Q t + \\phi) \\] <p>the Bloch vector will be rotated around the above axis by a total angle which is given by the integral of \\(A(t)\\):</p> \\[ \\theta = \\int_{t_0}^{t_0 + \\tau} A(t) dt \\] <p>Here \\(t_0\\) is the time at which the pulse starts and \\(\\tau\\) is the duration of the pulse.</p> <p>In a typical Power Rabi Oscillations experiment, the shape and duration of the pulse \\(A(t)\\) are fixed (e.g. a 20-nanosecond gaussian pulse) and only its amplitude is varied in order to get different rotation angles \u03b8. The experiment is performed by repeating the following basic sequence:</p> <ol> <li>Initialize the qubit to the ground state \\(\\left|0\\right&gt;\\).</li> <li>Apply a pulse with amplitude \\(a\\) (e.g. \\(A(t)\\) is a gaussian shaped pulse with peak amplitude \\(a\\)), which rotates the qubit by \\(\\theta_a\\) so that the qubit is in the state</li> </ol> \\[ \\cos(\\theta_a)\\left| 0\\right&gt; + \\sin(\\theta_a)e^{i\\phi}\\left| 1\\right&gt; \\] <ol> <li>Apply a resonant pulse to the readout resonator, and from the phase of the reflected pulse, deduce the state of the qubit.</li> </ol> <p>This basic sequence is repeated in the program for a varying of amplitudes \\(a\\), where for each amplitude, it is repeated N times (i.e. N identical basic sequences with the same a). N identical measurements are required because of quantum mechanical state collapsing. The outcome of each measurement is either 0 (qubit state \\(\\left|0\\right&gt;\\)) or 1 (qubit state \\(\\left|1\\right&gt;\\)), even if before the measurement the qubit was in a superposition of states. However, it can be shown that the averaged (over N identical sequences) transition probability \\(P_{\\left|1\\right&gt;}(a)\\) is equal to \\(\\sin^2(\\theta_a)\\).</p> <p>The results of the whole experiment can be summarized by plotting \\(P_{\\left|1\\right&gt;}(a)\\) as a function of a:</p> <p> Power Rabi oscillations</p> <p>We can use this to calibrate any single qubit rotation gate that rotates the qubit by an angle \u03b8, around a rotation axis that is on the x-y plane and is rotated with an angle \u03d5 from the x-axis. Such a gate is denoted by \\(R_{\\phi}(\\theta)\\). In fact, one of the typical goals of the Power Rabi Oscillations experiment is to calibrate the amplitude of a given pulse so that it performs a \u03c0-rotation (X-gate) or a \u03c0/2-rotation. However, \u03d5 cannot be determined from the Rabi oscillations and more complicated protocols have to be implemented (e.g. tomography).</p>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#implementation","title":"Implementation","text":"<p>We now describe the implementation of the experiment from the software side, after having set up and characterized the system.</p> <p>As explained earlier, the programming is done in Python using QM's package. However, it is crucial to keep in mind that in our case, Python is used as a \"host\" programming language in which we embed the QOP programming constructs. This is explained in more details below.</p>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#steps","title":"Steps","text":"<p>The experiment is implemented on the QOP as follows:</p> <ol> <li>Defining a quantum machine configuration</li> <li>Opening an interface to the quantum machine</li> <li>Writing the program</li> <li>Running the program</li> <li>Saving the results</li> </ol>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#configuring-the-quantum-machine","title":"Configuring the Quantum Machine","text":"<p>The configuration is a description of the physical elements present in our experimental setup and their properties, as well as the connectivity between the elements and the OPXs.</p> <p>The physical elements that are connected to the OPXs are denoted in the configuration as elements, which are discrete entities such as qubits, readout resonators, flux lines, gate electrodes, etc. Each of these has inputs and in some cases outputs, connected to the OPXs. The properties of the elements and their connectivity to the OPXs are used by the QOP to interpret and execute QUA programs correctly (e.g. a pulse played to a certain qubit is modulated by the OPX with the intermediate frequency defined for this element).</p> <p>The pulses applied to the elements are also specified in the configuration, where each pulse is defined as a collection of temporal waveforms. For example, a pulse to an element with two analog inputs and one digital input will specify the two waveforms applied to the analog inputs of the element and the digital pulse applied to its digital input.</p> <p>Also in the configuration, are specified the properties of auxiliary components that affect the actual output of the controller, such as IQ mixers and local oscillators. The configuration is defined as a set of nested Python dictionaries.</p> <p>Read more about the configuration in the configuration section.</p>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#configuration-for-the-quantum-machine","title":"Configuration for the Quantum Machine","text":"Configuration <pre><code> config = {\n'version': 1,\n'controllers': {\n'con1': {\n'type': 'opx1',\n'analog_outputs': {\n1: {'offset': +0.0},\n2: {'offset': +0.0},\n3: {'offset': +0.0},\n4: {'offset': +0.0},\n},\n'digital_outputs': {\n1: {},\n},\n'analog_inputs': {\n1: {'offset': +0.0},\n2: {'offset': +0.0},\n}\n}\n},\n'elements': {\n'qubit': {\n'mixInputs': {\n'I': ('con1', 1),\n'Q': ('con1', 2),\n'lo_frequency': 5.10e9,\n'mixer': 'mixer_qubit'\n},\n'intermediate_frequency': 5.15e6,\n'operations': {\n'gauss_pulse': 'gauss_pulse_in'\n},\n},\n'resonator': {\n'mixInputs': {\n'I': ('con1', 3),\n'Q': ('con1', 4),\n'lo_frequency': 6.00e9,\n'mixer': 'mixer_res'\n},\n'intermediate_frequency': 6.12e6,\n'operations': {\n'readout': 'meas_pulse_in',\n},\n'time_of_flight': 180,\n'smearing': 0,\n'outputs': {\n'out1': ('con1', 1)\n'out2': ('con1', 2)\n}\n},\n},\n'pulses': {\n'meas_pulse_in': {\n'operation': 'measurement',\n'length': 20,\n'waveforms': {\n'I': 'exc_wf',\n'Q': 'zero_wf'\n},\n'integration_weights': {\n'cos': 'cos',\n'sin': 'sin',\n'minus_sin': 'minus_sin',\n},\n'digital_marker': 'marker1'\n},\n'gauss_pulse_in': {\n'operation': 'control',\n'length': 20,\n'waveforms': {\n'I': 'gauss_wf',\n'Q': 'zero_wf'\n},\n}\n},\n'waveforms': {\n'exc_wf': {\n'type': 'constant',\n'sample': 0.479\n},\n'zero_wf': {\n'type': 'constant',\n'sample': 0.0\n},\n'gauss_wf': {\n'type': 'arbitrary',\n'samples': [0.005, 0.013,\n0.02935, 0.05899883936462147,\n0.10732436763802927, 0.1767030571463228,\n0.2633180579359862, 0.35514694106994277,\n0.43353720001453067, 0.479, 0.479,\n0.4335372000145308, 0.3551469410699429,\n0.26331805793598645, 0.17670305714632292,\n0.10732436763802936, 0.05899883936462152,\n0.029354822126316085, 0.01321923408389493,\n0.005387955348880817]\n}\n},\n'digital_waveforms': {\n'marker1': {\n'samples': [(1, 4), (0, 2), (1, 1), (1, 0)]\n}\n},\n'integration_weights': {\n'cos': {\n'cosine': [(4.0,20)],\n'sine': [(0.0,20)]\n},\n'sin': {\n'cosine': [(0.0,20)],\n'sine': [(4.0,20)]\n},\n'minus_sin': {\n'cosine': [(0.0,20)],\n'sine': [(-4.0,20)]\n},\n},\n'mixers': {\n'mixer_res': [\n{'intermediate_frequency': 6.12e6, 'lo_freq': 6.00e9, 'correction': [1.0, 0.0, 0.0, 1.0]}\n],\n'mixer_qubit': [\n{'intermediate_frequency': 5.15e6, 'lo_freq': 5.10e9, 'correction': [1.0, 0.0, 0.0, 1.0]}\n],\n}\n}\n</code></pre> <p>Because the programing interface is embedded in Python, we can use Python variables and functions when creating the configuration (as well as when writing QUA programs and when using the QM API). We could, for example define the shape of the <code>gaus_wf</code> waveform before the configuration and then use it to define the samples of the waveform in the configuration:</p> <pre><code>gaus_pulse_len = 20 # nsec\ngaus_arg = np.linspace(-3, 3, gaus_pulse_len)\ngaus_wf = np.exp(-gaus_arg**2/2)\ngaus_wf = Amp * gaus_wf / np.max(gaus_wf)\nconfig = {\n'version': 1,\n'controllers': {\n'con1': {\n'type': 'opx1',\n'analog': {\n.\n.\n.\n'waveforms': {\n'exc_wf': {\n'type': 'constant',\n'sample': 0.479\n},\n'zero_wf': {\n'type': 'constant',\n'sample': 0.0\n},\n'gauss_wf': {\n'type': 'arbitrary',\n'samples': gaus_wf.tolist()\n}\n}\n}\n</code></pre> <p>This approach can be used for all configuration elements.</p>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#importing-libraries","title":"Importing Libraries","text":"<p>As every Python script, we start by importing the necessary modules. In our case we require:</p> <pre><code>from qm.qua import *\nfrom qm.QuantumMachinesManager import QuantumMachinesManager\n</code></pre> <p>The first line imports all the functions and classes required for writing QUA programs. The second imports the manager class which is used to control and manage quantum machines.</p>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#opening-the-quantum-machine","title":"Opening the Quantum Machine","text":"<p>After defining the configuration, we can open an interface to a new quantum machine with the following commands:</p> <pre><code>qmm = QuantumMachinesManager()  # creates a manager instance\nqm = qmm.open_qm(config)  # opens a quantum machine with the specified configuration\n</code></pre>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#writing-the-program","title":"Writing the Program","text":"<p>After having defined the configuration, write the QUA program. Here we show the power Rabi program, which is intuitive, while in the next section we describe in great detail the language, and list its commands:</p> <pre><code>with program() as powerRabiProg :\nI = declare(fixed)\nQ = declare(fixed)\na = declare(fixed)\nNrep = declare(int)\nwith for_(Nrep, 0, Nrep &lt; 100, Nrep + 1):\nwith for_(a, 0.00, a &lt; 1.0 + 0.01/2, a + 0.01):\nplay('gauss_pulse'*amp(a), 'qubit')\nalign(\"qubit\", \"resonator\")\nmeasure(\"readout\", \"resonator\", None,\ndual_demod.full(\"cos\", \"out1\", \"sin\", \"out2\", I),\ndual_demod.full(\"minus_sin\", \"out1\", \"cos\", \"out2\", Q))\nsave(I, 'I')\nsave(Q, 'Q')\nsave(a, 'a')\n</code></pre> <p>This program:</p> <ul> <li> <p>Defines the variables \\(a\\) (amplitude) and \\(Nrep\\) (number of repetitions), as well as the variables I and Q that will store the demodulation result.</p> </li> <li> <p>Performs 100 repetitions (the loop over \\(Nrep\\)), where in each scan it:</p> <ul> <li>loops over 100 values of \\(a\\), from 0 to 1 in increments of 0.01 and for each value of \\(a\\) performs the Rabi sequence:</li> <li>Playing a pulse with amplitude \\(a\\) to the qubit</li> <li>Aligning the resonator and the qubit. Since operations on different elements are run in parallel, this qm.qua._dsl.align function forces here the system to wait until the qubit operation is done before operating the resonator.</li> <li>Measuring the resonator response and extracting from it the state of the qubit. This is done by sending a measurement pulse to the resonator and demodulating and integrating the returning pulse using the indicated integration weights.</li> <li>Saving the demodulation and integration results, I and Q, as well as the corresponding amplitude.</li> </ul> </li> </ul> <p>This Python code block creates an object named <code>powerRabiProg</code>, which is a QUA program that can be executed on an open quantum machine. It is important to note that this program, while embedded in Python, is not a Python program: it is a QUA program that will be compiled and run on the OPX controller in real-time with repeatable timing down to the single sample level.</p> <p>Note</p> <p>For simplicity, the code showed above uses the legacy save option. We recommend using the stream processing for data streaming and saving</p>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#running-the-program","title":"Running the Program","text":"<p>Run the program on the previously opened quantum machine:</p> <pre><code>my_job = qm.execute(powerRabiProg)\n</code></pre> <p>This command executes the powerRabiProg program and saves the results in the job object my_job.</p>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#pulling-the-results","title":"Pulling the Results","text":"<p>After the program is executed, the results can be pulled:</p> <pre><code>res_handle = my_job.result_handles\nres_handle.wait_for_all_values()\nI = res_handles.get('I').fetch_all()\nQ = res_handles.get('Q').fetch_all()\n</code></pre> <p>We first create a results handle object <code>res_handles</code> and then qm.results.base_streaming_result_fetcher.BaseStreamingResultFetcher.wait_for_all_values waits until all values are obtained. We can then pull the results from <code>res_handles</code> using the fetch method. Read more on results fetching in the stream processing guide.</p> <p>Note</p> <p>Results can also be fetched while the program is being executed. For example:</p> <pre><code>job.result_handles.get('I').wait_for_values(1)  # wait until the first value arrives to I\nI = res_handles.get('I').fetch_all()  # will hold the results so far for I\n</code></pre>"},{"location":"qm-qua-sdk/docs/Introduction/use_case/#further-examples","title":"Further examples","text":"<p>You can find many more hands-on examples and tutorials in our github library.</p>"},{"location":"qm-qua-sdk/docs/Libraries/libs_repository/","title":"QUA libraries repository","text":"<p>In QUA libraries repository you can find many relevant tutorials and a lot of examples that will boost your QUA expertise and help you realize your experiments.</p> <p>The repository consists of two sections:</p> <ul> <li>The Tutorials  folder contains various tutorials and guides for working with the OPX. If you feel that you need initial guidance or you want some hands-on examples, that's an excellent place to go!</li> <li>Quantum Control Applications folder which contains scripts and examples for different qubit types, from fundamental to advanced protocols. It offers a variety of tested, essential protocols and provides an excellent starting point for realizing more complex experiments. Moreover you can find various inspiring QUA protocols and results from leading labs.</li> </ul> <p>Do you have a nice protocol you would like to share? You are more than welcome! Just click here and contribute to the QUA community!</p>"},{"location":"qm-qua-sdk/docs/Libraries/tools_repository/","title":"QUA tools repository","text":"<p>In the QUA tools repository, you can find various tools useful while writing your QUA programs, making it much easier and simpler to perform your experiments.</p> <p>Do you have any additional tool to share with the QUA community? We would love to have your contribution! Just click here and add it.</p>"},{"location":"qm-qua-sdk/docs/Libraries/tools_repository/#config-tools","title":"Config Tools","text":"<p>Config Tools package includes tools related to the QOP configuration file. Using this package, you can, for example, create useful waveforms for your experiment via the Waveform Tools package. Moreover, creating and manipulating integration weights is very comfortable with the Integration Weights Tools package.</p>"},{"location":"qm-qua-sdk/docs/Libraries/tools_repository/#unit-tools","title":"Unit Tools","text":"<p>The Unit Tools library includes simple tools for using units (MHz, us, mV...) and converting data to other units such as converting demodulated data to volts.</p> <p>To show the simplicity of this tool, look at the snippet of code below that plots the converted demodulated data in millivolts.</p> <pre><code>u = unit()\nplt.figure()\nplt.plot(u.raw2volts(raw_data) * u.mV)\nplt.ylabel(\"Raw trace [mV]\")\n</code></pre>"},{"location":"qm-qua-sdk/docs/Libraries/tools_repository/#qua-loops-tools","title":"QUA Loops Tools","text":"<p>The QUA Loops Tools  library includes tools for parametrizing QUA for loops using the NumPy (linspace, arrange, logspace) syntax or by directly inputting a NumPy array as an iterable. Moreover, it validates the input so you don't have to worry about exceeding the range of the variables, for example. These tools make writing the loops inside your QUA program much simpler!</p> <p>For example:</p> <pre><code>pulse_amplitude = np.arange(-0.3, 0.3 , 0.01)\nwith program() as prog:\na = declare(fixed)\nwith for_(*from_array(a, pulse_amplitude)):\n# The variable 'a' will be looped over the values from pulse_amplitude\n...\n</code></pre>"},{"location":"qm-qua-sdk/docs/Libraries/tools_repository/#result-tools","title":"Result Tools","text":"<p>The Result Tools library includes tools for easy fetching and handling of results from your QUA program. For example, you can add a progress bar to your job execution or live plot the data from the stream processing! This can be seen below:</p> <pre><code>my_results = fetching_tool(job, data_list=[\"I\", \"Q\", \"Ie\", \"Qe\", \"Ig\", \"Qg\"], mode=\"live\")\nfig = plt.figure(figsize=(15, 15))\nwhile job.result_handles.is_processing():\n# Live plotting\nI, Q, Ie, Qe, Ig, Qg = my_results.fetch_all()\n...\n</code></pre>"},{"location":"qm-qua-sdk/docs/Libraries/tools_repository/#analysis-tools","title":"Analysis Tools","text":"<p>The Analysis Tools library includes tools for analyzing data from experiments.</p> <p>Currently, it contains one important tool: the <code>Discriminator</code>. This tool allows you to discriminate between two states in the IQ plane and be (almost) sure that your qubit is, in fact, in the right state.</p>"},{"location":"qm-qua-sdk/docs/Libraries/tools_repository/#bakery","title":"Bakery","text":"<p>The Bakery library introduces a framework for creating arbitrary waveforms and storing them in the configuration file. It allows defining waveforms in a QUA-like manner while working with 1ns resolution (or higher).</p> <p>Using this tool provides an advantage by embedding into one single waveform a series of instructions that allows program memory preservation. This way, you can generate the desired samples, for example, based on two previous ones. While baking the waveform, one of the instructions can even be waiting a negative amount of time!</p> <p>All this is easily done by creating the baked waveform and using the run command inside your QUA program. See an example of the framework below:</p> <pre><code>with baking(config, \"left\"):\n#Create your baked waveform\n#Open QUA program:\nwith program() as QUA_prog:\nb.run()\n</code></pre>"},{"location":"qm-qua-sdk/docs/Libraries/tools_repository/#control-panel","title":"Control Panel","text":"<p>The Control Panel package includes tools for directly controlling the OPX. This may help you control the OPX's outputs. For example, you can turn on and off digital channels and change the amplitude and frequency of the analog channels. This is very convenient if you want to output signals from the OPX without writing a QUA program.</p> <p>Note</p> <p>This is a stand-alone module.</p>"},{"location":"qm-qua-sdk/docs/Libraries/tools_repository/#addons","title":"Addons","text":"<p>Note</p> <p>This is a beta package. Some of these tools are not fully supported and tested, but we believe have a true product value.</p> <p>The Addons package includes more generic tools; <code>InteractivePlotLib</code> and <code>Calibration</code>. The former extends the capabilities of matplotlib and makes it much easier to analyze the data via, for example, fitting, editing, and saving the raw data. The latter allows you to easily perform most of the standard single qubit calibrations such as time_of_flight, resonator spectroscopy, Rabi and more!</p>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/","title":"Python Package (qm-qua) Releases","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog.</p>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#102-2023-01-01","title":"1.0.2 - 2023-01-01","text":"<p>Removed</p> <ul> <li>Removed deprecated <code>math</code> library (use {class}<code>~qm.qua.lib.Math</code> instead).</li> <li>Removed deprecated <code>qrun_</code> context manager (use {func}<code>~qm.qua._dsl.strict_timing_</code> instead).</li> </ul> <p>Added</p> <ul> <li>Better exception error printing.</li> <li>An api to add more information to error printing <code>activate_verbose_errors</code></li> <li>Add support for OPD (Please check the OPD documentation for more details).</li> <li>Added timestamps for {func}<code>~qm.qua._dsl.play</code> and {func}<code>~qm.qua._dsl.measure</code> statements.</li> <li>Support for numpy float128.</li> <li>Added the function {func}<code>qm.user_config.create_new_user_config</code> to create a configuration file with the QOP host IP &amp; Port to allow opening {func}<code>~qm.QuantumMachinesManager.QuantumMachinesManager</code> without inputs.</li> <li>Added infrastructure for anonymous log sending (by default, no logs are sent).</li> </ul> <p>Fixed</p> <ul> <li>Serializer - Added support for averaging on different axes.</li> <li>Serializer - Remove false message about lacking <code>play(ramp()...)</code> support.</li> <li>Serializer - Fixed the serialization when <code>.length()</code> is used.</li> <li>Serializer - Fixed cases in which the serializer did not deal with <code>adc_trace=true</code> properly.</li> <li>Serializer - The serializer does not report failed serialization when the only difference is the streams' order.</li> <li>Serializer - The serializer now correctly serialize the configuration when an element's name has a <code>'</code>.</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#101-2022-09-22","title":"1.0.1 - 2022-09-22","text":"<p>Changed</p> <ul> <li>Octave - Added a flag to not close all the quantum machines in {func}<code>~qm.octave.qm_octave.QmOctave.calibrate_element</code>.</li> <li>Octave - The quantum machine doing the calibrations will be closed after the calibration is done.</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#100-2022-09-04","title":"1.0.0 - 2022-09-04","text":"<ul> <li>Removed deprecated entries from the configuration schema</li> <li>Removed dependency in <code>qua</code> package</li> </ul> <p>Fixed</p> <ul> <li>QuantumMachineManager - Fixed a bug where you could not connect using SSL on python version 3.10+</li> <li>Serializer - Fixed <code>declare_stream()</code> with <code>adc_true=True</code></li> </ul> <p>Changed</p> <ul> <li>Update betterproto version.</li> <li>OctaveConfig: changed <code>set_device_info</code> name to <code>add_device_info</code></li> <li>OctaveConfig: changed <code>add_opx_connections</code> name to <code>add_opx_octave_port_mapping</code></li> <li>OctaveConfig: changed <code>get_opx_octave_connections</code> name to <code>get_opx_octave_port_mapping</code></li> </ul> <p>Added</p> <ul> <li>API to control Octave - an up-conversion and down-conversion module with built-in Local Oscillator (LO) sources.</li> <li>Support Numpy as input - Support numpy scalars and arrays as valid input. Numpy object can now be used interchangeably with python scalars and lists. This applies to all statements imported with <code>from qm.qua import *</code></li> <li>Serializer - Added support for legacy save</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#038-2022-07-10","title":"0.3.8 - 2022-07-10","text":"<p>Fixed</p> <ul> <li>Serializer - Fixed a bug which caused binary expression to fail</li> </ul> <p>Changed</p> <ul> <li>QuantumMachineManager will try to connect to 80 before 9510 if the user did not specify a port.</li> <li>QuantumMachineManager will give an error if no host is given and config file does not contain one.</li> <li>QRun - Change qrun to strict_timing</li> <li>Input Stream - Fixed API for input stream</li> </ul> <p>Added</p> <ul> <li>Serializer - add strict_timing to serializer</li> <li>Logger - Can now add an environment variable to disable the output to stdout</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#037-2022-05-31","title":"0.3.7 - 2022-05-31","text":"<p>Fixed</p> <ul> <li>Serializer - Fixed a bug which caused the serializer to fail when given completely arbitrary integration weights</li> <li>Serializer - Fixed a bug which caused the serializer to fail when given a list of correction matrices</li> <li>Serializer - Added support for \"pass\" inside blocks (if, for, etc). \"pass\" inside \"else\" is not supported.</li> </ul> <p>Added</p> <ul> <li>play - Add support for continue chirp feature</li> <li>High Resolution Time Tagging - Add support for high resolution time-tagging measure process</li> <li>Input Stream - Add support for streaming data from the computer to the program</li> <li>OPD - Added missing OPD timetagging function</li> </ul> <p>Changed</p> <ul> <li>set_dc_offset - 2nd input for function was renamed from <code>input_reference</code> to <code>element_input</code></li> <li>QuantumMachineManager will try to connect to ports 9510 and 80 if the user did not specify a port.</li> <li>set_output_dc_offset_by_element - can now accept a tuple of ports and offsets</li> <li><code>signalPolarity</code> in the timetagging parameters (<code>outputPulseParameters</code> in configuration) now accept <code>Above</code> and <code>Below</code> instead of <code>Rising</code> and <code>Falling</code>, which better represent it's meaning.</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#036-2022-01-23","title":"0.3.6 - 2022-01-23","text":"<p>Added</p> <ul> <li><code>signalPolarity</code> in the timetagging parameters (<code>outputPulseParameters</code> in configuration) now accept also <code>Rising</code> and <code>Falling</code>, which better represent it's meaning.</li> <li><code>derivativePolarity</code> in the timetagging parameters (<code>outputPulseParameters</code> in configuration) now accept also <code>Above</code> and <code>Below</code>, which better represent it's meaning.</li> <li>Add unsafe switch to <code>generate_qua_config</code> function.</li> <li>Add library functions and <code>amp()</code> in measure statement to <code>generate_qua_config</code> function.</li> </ul> <p>Changed</p> <ul> <li>Better error for library functions as save source</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#035-2021-12-27","title":"0.3.5 - 2021-12-27","text":"<p>Added</p> <ul> <li>Raises an error when using Python logical operators</li> <li>Add elif statement to <code>generate_qua_config</code> function</li> </ul> <p>Changed</p> <ul> <li>Fix indentation problem on the end of for_each block in <code>generate_qua_config</code> function</li> <li>The <code>generate_qua_config</code> now compresses lists to make the resulting file smaller and more readable</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#034-2021-12-05","title":"0.3.4 - 2021-12-05","text":"<p>Added</p> <ul> <li>Define multiple elements with shared oscillator.</li> <li>Define an analog port with channel weights.</li> <li>Add measure and play features to <code>generate_qua_config</code> function</li> <li>format <code>generate_qua_config</code> function output</li> <li>improve <code>wait_for_all_values</code> execution time</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#033-2021-10-24","title":"0.3.3 - 2021-10-24","text":"<p>Added</p> <ul> <li>Define an analog port with delay.</li> <li>New <code>set_dc_offset()</code> statement that can change the DC offset of element input in real time.</li> <li>New input stream capabilities facilitating data transfer from job to QUA.</li> <li>New flag for stream processing fft operator to control output type.</li> <li>Add information about demod on a tuple.</li> <li>Added best practice guide.</li> </ul> <p>Changed</p> <ul> <li>Validate that element has one and only one of the available input type QMQUA-26</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#032-2021-10-03","title":"0.3.2 - 2021-10-03","text":"<p>Added</p> <ul> <li>QuantumMachinesManager health check shows errors and warnings.</li> <li>Fetching job results indicates if there were execution errors.</li> <li>Define an element with multiple input ports.</li> <li>Stream processing demod now supports named argument <code>integrate</code>. If <code>False</code> is provided the demod will not sum the items, but only multiply by weights.</li> </ul> <p>Changed</p> <ul> <li>Documentation structure and content.</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#031-2021-09-13","title":"0.3.1 - 2021-09-13","text":"<p>Fixed</p> <ul> <li>Fixed serialization of IO values.</li> <li>Support running <code>QuantumMachinesManager</code> inside ipython or jupyter notebook.</li> </ul> <p>Changed</p> <ul> <li>Removing deprecation notice from <code>with_timestamps</code> method on result streams.</li> <li>Setting <code>time_of_flight</code> or <code>smearing</code> are required if element has <code>outputs</code> and must not appear if it does not.</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#030-2021-09-03","title":"0.3.0 - 2021-09-03","text":"<p>Changed</p> <ul> <li>Support for result fetching of both versions of QM Server.</li> <li>Now the SDK supports all version of QM server.</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#021-2021-09-01","title":"0.2.1 - 2021-09-01","text":"<p>Changed</p> <ul> <li>Default port when creating new <code>QuantumMachineManager</code> is now <code>80</code> and user config file is ignored.</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#020-2021-08-31","title":"0.2.0 - 2021-08-31","text":"<p>Added</p> <ul> <li>The original QM SDK for QOP 2.</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#010-2021-08-31","title":"0.1.0 - 2021-08-31","text":"<p>Added</p> <ul> <li>The original QM SDK for QOP 1.</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qm_qua_releases/#legend","title":"Legend","text":"<ul> <li>Features that are server specific and depend on capabilities and version</li> <li>Documentation only change</li> </ul>"},{"location":"qm-qua-sdk/docs/Releases/qop1_releases/","title":"OPX (QOP 1) Releases","text":"<p>Here you can find release notes and version files for the latest version of {{ qop1 }}</p>"},{"location":"qm-qua-sdk/docs/Releases/qop1_releases/#qop-13","title":"QOP 1.3","text":"<p>The release notes and files for the latest version can be found here.</p> <p>Note</p> <p>Only registered customers can view this link. Please contact your QM representative if you are a customer and don\u2019t have access.</p>"},{"location":"qm-qua-sdk/docs/Releases/qop2_releases/","title":"OPX+ (QOP 2) Releases","text":"<p>Here you can find release notes and version files for the latest version of {{ qop2 }}</p>"},{"location":"qm-qua-sdk/docs/Releases/qop2_releases/#qop-20","title":"QOP 2.0","text":"<p>For an in-depth review of the  version's new features and upgrades, please see the release notes.</p>"},{"location":"qm-qua-sdk/docs/Releases/qop2_releases/#qop-202","title":"QOP 2.0.2","text":"<p>The version files and installation steps can be found here.</p> <p>Note</p> <p>Only registered customers can view this link. Please contact your QM representative if you are a customer and don\u2019t have access.</p>"},{"location":"qm-qua-sdk/docs/legal/cookie_policy/","title":"Cookie policy","text":"<p>(cookie-policy)=</p>"},{"location":"qm-qua-sdk/docs/legal/cookie_policy/#cookie-policy","title":"Cookie Policy","text":"<p>This policy explains how Q.M Technologies Ltd. (\"QM\" or \"we\"), uses cookies, similar tracking technology and your related choices. For more information on other ways we collect and use information from you and your use of our websites, at: www.quantum-machines.co (\"Website\"), please see our Privacy Policy (\u201cPrivacy Policy\u201d).</p> <p>In this Cookie Policy we use the term \u201ccookies\u201d to refer to any applicable tracking technologies described herein. Any capitalized terms not otherwise defined in this Cookie Policy shall have the meaning ascribed to them in the Privacy Policy.</p> <ol> <li>WHAT ARE COOKIES AND SIMILAR TECHNOLOGY    : - Cookies are small text files that are stored on your device to help websites and mobile apps remember things about you. Session-based cookies last only while your browser is open and are automatically deleted when you close your browser. Persistent cookies last until you or your browser delete them or until they expire. To learn more about cookies, visit http://www.allaboutcookies.org/.<ul> <li>Pixel Tags (also known as web beacons or clear GIFs) are transparent images, iFrames, or JavaScript placed on a website or in marketing emails that are used in order to understand how you interact with such websites or emails.</li> <li>Social Media Features, such as the Facebook \u201clike\u201d button, may collect your IP address and which page you are visiting on a website, and may set a cookie to enable the feature to function properly. Your interactions with these features are governed by the privacy policy of the company providing the relevant Social Media Features.</li> <li>Single Sign-on allows you to log in to certain websites or mobile applications using sign-in services provided by third parties, such as Facebook or Google. These services will authenticate your identity and provide you the option to share certain personal information with us such as your name and email address to pre-populate our sign-up form.</li> <li>Ad ID is a unique number issued to you by an entity which received your permission to serve you with advertisements. The Ad ID allows persons or entities with whom you interact to gather and store information they learn about you in connection with your Ad ID. Most entities that have assigned you with an Ad ID allow you to delete or change such Ad ID and thereby prevent third parties from colleting information concerning your behavior across multiple sessions. To learn more about Ad ID and how change or delete it on Android and Apple, please refer to https://support.google.com/My-Ad-Center-Help/ and https://support.apple.com/en-il/HT205223.</li> </ul> </li> <li> <p>HOW WE USE COOKIES    : The cookies we use can be classified in one of the following categories:</p> <p><pre><code>+--------------------+-----------------------------------------------------------------------------------------+\n| Strictly Necessary | We use these cookies in order to enable you to use our Website's features,              |\n|                    | such as enabling movement between pages and remembering information you enter on forms. |\n| cookies            |                                                                                         |\n|                    | Without these necessary cookies, certain services on our Website will not be possible   |\n|                    | and our Website will not perform as smoothly as it should.                              |\n+--------------------+-----------------------------------------------------------------------------------------+\n| Security cookies   | We use these cookies to help identify and prevent security risks.                       |\n+--------------------+-----------------------------------------------------------------------------------------+\n| Performance and    | We use these cookies to collect information about the use of our Website in order to    |\n|                    | help improve the way it works.                                                          |\n| Analytics cookies  |                                                                                         |\n+--------------------+-----------------------------------------------------------------------------------------+\n| Functionality and  | We use these cookies to remember the choices you make such as which language you prefer |\n|                    | and to provide you with personalized features.                                          |\n| Preference cookies |                                                                                         |\n+--------------------+-----------------------------------------------------------------------------------------+\n</code></pre> 3. WHAT THIRD PARTY COOKIES WE USE    : We use the following Third-Party Cookies:</p> Name Functionality Link to applicable privacy policy Google Analytics Analytics https://policies.google.com/privacy Hotjar Analytics https://www.hotjar.com/legal/policies/privacy Hubspot Marketing https://legal.hubspot.com/privacy-policy/ reCaptcha by Google Security https://policies.google.com/terms?hl=enhttps://policies.google.com/privacy?hl=en 4. We use the following First-Party Cookies: : - Authentication data (Security cookie) - User selection (Functionality and Preference cookie) 5. YOUR CHOICES : - Strictly Necessary Cookies : - These cookies are essential to operate our Website, its functionality and accessibility, and therefor are always enabled. - Targeting and Advertising Cookies: : - You can opt out of interest-based targeting provided by participating ad servers through the Network Advertising Initiative at https://thenai.org/opt-out/ or the Digital Advertising Alliance at www.aboutads.info/ - You may be able to change your device settings (on your iPhone, iPad or Android) to control whether you see online interest-based ads and thereby to prevent multiple session tracking. - You can opt out of third party tracking technologies by following the instructions provided by each third party service provider in its privacy policy. - You can learn more about your options by visiting https://youradchoices.com/, https://www.youronlinechoices.eu/, https://support.google.com/My-Ad-Center-Help/ and https://support.apple.com/en-il/HT205223. - Other Cookies: : - You can follow the instructions provided by your web browser or mobile browser (usually located within the \"Help\", \"Tools\" or \"Edit\" facility) to modify your cookie and Ad ID settings. - You can opt out of third-party tracking technologies by following the instructions provided by each third party service provider in its privacy policy. - Deletion of Cookie history: : - You can choose to delete your cookie history and to opt-out from future usage of cookies by QM, by sending a deletion request the following email: info@quantum-machines.co 6. DO NOT TRACK : We do not currently commit to responding to your browsers\u2019 \u2018Do Not Track\u2019 signals with respect to our Website, in part, because no common industry standard for \u2018Do Not Track\u2019 has been adopted by regulators, including no consistent standard of interpreting a user\u2019s intent. We are committed to monitoring the developments around \u2018Do Not Track\u2019 and the implementation of a standard. 7. CHANGES TO THIS COOKIE POLICY : We may update this Cookie Policy from time to time. We encourage you to periodically review this Cookie Policy to stay informed about our use of cookies, the information we collect via cookies, and any updates in relation thereto. If we make any changes to this Cookie Policy that significantly impact the way we use cookies, we will endeavor to provide you with notice in advance of such change by highlighting the change on our Website. Your continued use of our Website constitutes your agreement to this Cookie Policy and any updates. 8. CONTACT US : If you have any questions about our use of cookies, please contact us at: info@quantum-machines.co </li> </ol>"},{"location":"qm-qua-sdk/docs/legal/privacy_policy/","title":"Privacy policy","text":"<p>(privacy-policy)=</p>"},{"location":"qm-qua-sdk/docs/legal/privacy_policy/#website-privacy-policy","title":"Website Privacy Policy","text":"<p>Last Revised: January 1st, 2020</p> <ol> <li> <p>INTRODUCTION     : Q.M Technologies Ltd. (\u201cQM\u201d, \u201cwe\u201d, \u201cus\u201d or \u201cour\u201d) welcomes you to our owned and operated website,       at: https://qm-docs.qualang.io/index.html (the \u201cWebsite\u201d).</p> <p>This Website Privacy Policy (the \u201cPrivacy Policy\u201d) applies to:   (i) the use of our Website;   (ii) our marketing and related activities, including registrations as part of our webinars, conferences, events,   emails, customer success activities etc.; and (iii) any other product or activity that links to   or otherwise references this Privacy Policy (collectively, including the Website, the \u201cMarketing Platforms\u201d).   We are committed to the privacy of the visitors and/or users of our Website and (if applicable) Marketing Platforms   (collectively, the \u201cUser(s)\u201d or \u201cyou\u201d) and are committed to protect the personal data that our Users   share with us, in compliance with applicable privacy and personal data laws and regulations.</p> <p>The Privacy Policy is intended to describe our practices regarding the information we may collect from you or to which we may have access, when you use or interact with our Marketing Platforms, and the manners in which we may use such information, and the choices and rights available to you. 02. YOUR CONSENT : PLEASE READ CAREFULLY THIS PRIVACY POLICY BEFORE ACCESSING AND USING OUR MARKETING PLATFORMS.   BY ACCESSING OR USING OUR MARKETING PLATFORM YOU ARE ACCEPTING THE PRACTICES DESCRIBED IN THIS PRIVACY POLICY.   IF YOU DISAGREE TO ANY TERM PROVIDED HEREIN, DO NOT ACCESS OR USE THE MARKETING PLATFORM.</p> <p>PLEASE NOTE: YOU ARE NOT OBLIGATED BY LAW TO PROVIDE US WITH ANY PERSONAL DATA.   HENCE, YOU HEREBY ACKNOWLEDGE AND AGREE THAT YOU ARE PROVIDING US WITH PERSONAL DATA AT YOUR OWN FREE WILL,   FOR THE PURPOSES DESCRIBED IN SECTION 4 BELOW, AND THAT WE MAY RETAIN AND USE SUCH PERSONAL DATA   IN ACCORDANCE WITH THIS PRIVACY POLICY AND ANY APPLICABLE LAWS AND REGULATIONS. 03. WHAT INFORMATION DO WE COLLECT FROM OUR USERS? : We may collect several types of information from and about our Users.   In this section, we describe the categories of information which we may collect,   and the applicable circumstances under which such collection is performed.</p> <p>First \u2013 What is personal data?</p> <p>Personal information refers to identifiable information regarding an individual,   namely information that identifies an individual or may with reasonable efforts   or together with additional information we have access to, enable the identification of an individual,   or may be of private or sensitive nature information, relating to an identified or identifiable natural person.   Identification of an individual includes association of such individual with an persistent identifier   such as a name, an identification number, persistent cookie identifier etc.   Personal information does not include information that has been anonymized or aggregated so that it can   no longer be used to identify a specific natural person.</p> <ol> <li> <p>We collect personal data from you when you use or interact with our Marketing Platforms      : We collect personal data from you and any devices (including mobile devices) you use when you: use, interact or access our Marketing Platforms, provide us information on a web form or other text field within our Website or through correspondence you and we conduct with each other.        More specifically we collect and use the following categories and types of information        in the following respective circumstances:</p> <ul> <li> <p>Personal data Users provide us actively and voluntarily when they use or interact with our Marketing Platform:</p> <ul> <li>Contact information, such as name, email, company, position, country, and telephone number, all when (i) a user fills our online form or register for an account (if applicable) with us or when they update their account details; (ii) if you contacted us or contracted with us (also on behalf of your employer) in connection with the purchase of our products or services .</li> <li>Information you voluntarily provide us, for example, when you register to one of our events, request that we contact you through our online forms, submit your CV (see section 11 of this Privacy Policy regarding your information as an employment candidate), or when you request to receive certain content that we may make available like research and white papers.</li> <li>Interaction with our customer support, which may include text/video/audio recording and transcripts of such communications.</li> <li>Information required or authorized by applicable national laws, meaning information we ask Users to provide us in order to authenticate or identify them or to verify the information we have collected or otherwise provide them with our Marketing Platforms.</li> </ul> </li> <li> <p>Personal data we automatically obtain when Users use or interact with our Website:</p> <ul> <li>Website Interactions. When Users access or interact with our Website, we perform automatic collection of information through use of cookies, web beacons, unique identifiers, and similar technologies which allow us to collect information about the pages and screens you view, the links you click, and other actions you take when using our Website, as further detailed in section 7 below.</li> </ul> </li> </ul> <p>Keep in mind \u2013 Most devices allow you to control or disable the use of certain collectable information including location services, in the device\u2019s settings menu.       2. Personal data collected from other sources  : We may collect personal data concerning you, from third parties who have assured us that they have obtained your consent for such provision of information.    Please Note \u2013 While most of the information we collect from you is not Personal data, we acknowledge that under certain jurisdictions the data we do receive when a User is using the Website may be deemed personal data as it is associated with a Technical Identifier, and therefore, where applicable, will be treated as such.    You have the rights to choose how we collect and use your Information. See \u201cYour Rights\u201d at section 12 below for more information. 04. THE PURPOSES     : 1. Lawful grounds for collecting information on our users  : We collect and process your information for the purposes described in this policy, based at least on one of the following legal grounds:</p> <ul> <li>Contract: We collect and process your personal information in order to provide you with the Service, following your acceptance of these Terms; to maintain and improve our Services; to develop new services and features for our Users; and to personalize the Service in order to deliver better user experience.</li> <li>With your consent: We ask for your agreement to process your information for specific purposes and you have the right to withdraw your consent at any time. For example, we ask for your consent to provide you with personalized content and ads through the use of cookies;</li> <li>Legitimate interests: We process your information for our legitimate interests while applying appropriate safeguards that protect your privacy. This means that we process your information for things like detecting, preventing, or otherwise addressing fraud, abuse, security, usability, functionality or technical issues with our services, protecting against harm to the rights, property or safety of our properties, or our users, or the public as required or permitted by law; Enforcing legal claims, including investigation of potential violations of this Privacy Policy; in order to comply and/or fulfil our obligation under applicable laws, regulation, guidelines, industry standards and contractual requirements, legal process, subpoena or governmental request, as well as our Terms of Service.<ol> <li>We use Information for the following purposes:  : - To provide you with our products, services and support which you have purchased from us (either on your own behalf or on behalf of your employer).</li> </ol> </li> <li>To process your inquiries and to respond to your requests. For example, when you contact us to learn more about our products or services or when you request to receive certain materials from us (e.g. white papers, research papers, product and services information). Additionally, if you submit your CV, we use it to evaluate your candidacy (including by assessing your qualifications and skills).</li> <li>To send you information related to our services and products that we believe may interest you, such as newsletters or product and service updates. Such communications will be sent to you when you have chosen to receive such communication or when we have a legitimate interest to market our products and services. In any event, you will always be able to opt-out of receiving such communications. Opting out may be done either directly in the communication received or through the ways described in the instructions in the \u201cYour Rights\u201d section, at section 12 below.</li> <li>To understand how you have used our Website and to customize it in accordance with your interests and past actions and choices. We do this based on our legitimate interest to operate our Website, diagnose any problems with the Website and to improve the experience when navigating through it.</li> <li>In our legitimate interest to prevent fraud or harm to us or to any third party, and ensure the security of our network and services.</li> <li>Where it is necessary for QM to comply with its legal obligations and to exercise and enforce its legal rights.</li> <li>We may use certain third-party marketing and advertising networks to help us market our products on our own Marketing Platforms and on third party websites (e.g. re-marketing ads across the Internet by Google).</li> <li>WHERE DO WE STORE USER\u2019S PERSONAL DATA?     : Information regarding the Users will be maintained, processed and stored by us and our authorized affiliates and service providers in Israel , and as necessary, in secured cloud storage, provided by our third party service provider.       While the data protection laws in the above jurisdictions may be different than the laws of your residence or location, please know that we, our affiliates and our service providers that store or process your Personal data on the our behalf are each committed to keep it protected and secured, pursuant to this Privacy Policy and industry standards, regardless of any lesser legal requirements that may apply in their jurisdiction. You hereby accept the place of storage and the transfer of information as described above.</li> <li>WHO DO WE SHARE USER INFORMATION WITH AND WHY?     : We may share your Personal data with third parties (or otherwise allow them access to it) only in the following manners and instances:</li> </ul> </li> </ol> <ul> <li>To satisfy any applicable law, regulation, legal process, subpoena or governmental request, whenever we believes in good faith that it is legally bound to share such information.</li> <li>To enforce this Privacy Policy and the Terms of Use including investigation of potential violations thereof.</li> <li>To detect, prevent, or otherwise address fraud, security or technical issues.</li> <li>To respond to User\u2019s support requests.</li> <li>To respond to claims that contact information or any other private or proprietary information (e.g. name, e-mail address, etc.) of a third-party has been used, posted or transmitted without their consent or as a form of harassment.</li> <li>To protect the rights, property, or personal safety of us, our Users or the general public.</li> <li>When we undergo any change in control, including by means of merger, acquisition or purchase of all or substantially all of its assets.</li> <li>To collect, hold and/or manage Users\u2019 Personal data through our authorized third party service providers, as contemplated hereunder, who may be located outside of Israel (for example: Google Analytics, Hubspot, Hotjar) Such third party services providers may receive or otherwise have access to our Users\u2019 Personal data, depending on each of their particular roles and purposes in facilitating and enhancing our Website and related services, namely to allow serving of personalized content and advertisement, and for analytics of the functionality and usability of our Website. and may only use it for such purposes.</li> <li>Pursuant to your explicit approval prior to the disclosure.</li> </ul> <p>For avoidance of doubt, we may share anonymized or de-identified information with any other third party, at our sole discretion. 07. USING COOKIES AND OTHER TRACKING TECHNOLOGIES : We use certain monitoring and tracking technologies, including ones offered by third party service providers. These technologies are used in order to maintain, provide and improve our Website on an ongoing basis, and in order to provide a better experience to our Users. For example, these technologies enable us to: (i) keep track of our Users\u2019 preferences and authenticated sessions, (ii) secure our website by detecting abnormal behaviors, (iii) identify technical issues and improve the overall performance of our website, (iv) create and monitor analytics, and (v) deliver you targeted advertisements that are more tailored to you based on your browsing activities and inferred interests and track ad performance (For more information about this practice, click here: http://www.aboutads.info/choices/).   Please see our {ref}<code>Cookie Policy &lt;cookie_policy&gt;</code>.   Learn more about your choices and how to opt-out of tracking technologies: In order to delete or block any tracking technologies, please refer to the \u201cHelp\u201d area on your internet browser for further instructions, or You may also opt out of third party tracking technologies by following the instructions provided by each third party service provider in its privacy policy listed above or visiting www.youronlinechoices.eu.   Please note however that deleting any of our tracking technologies or disabling future tracking technologies may prevent you from accessing certain areas or features of our website, or may otherwise adversely affect your user experience. 08. MINORS : To use our website, you must be over the age of sixteen (16). Therefore, we do not knowingly collect Personal data from minors under the age of sixteen (16) and do not wish to do so. We reserve the right to request proof of age at any stage so that we can verify that minors under the age of sixteen (16) are not using the Website. 09. INFORMATION SECURITY : We employ industry standard procedures and policies to ensure the safety of its Users\u2019 Personal data, reduce the risks stemming from loss of information and prevent unauthorized use of any such information. However, no measure can provide absolute information security. 10. DATA RETENTION : We retain the Personal data we collect only for as long as needed in order to provide you with our services and to comply with applicable laws and regulations. We then either delete from our systems or anonymize it without further notice to you.   If you withdraw your consent to us processing your Personal data, we will delete your Personal data from our systems (except to the extent such data in whole or in part to comply with any applicable rule or regulation and/or response or defend against legal proceedings versus us or our affiliates). 11. JOB CANDIDATES: : QM welcomes all qualified Candidates to apply to any of the open positions posted on our Website and/or on Linkedin, by sending us their contact details and CV (\u201cCandidates Information\u201d). We are committed to keep Candidates\u2019 Information private and use it solely for our internal recruitment purposes (including for identifying Candidates, evaluating their applications, making hiring and employment decisions, and contacting Candidates by phone or in writing).   Please note that the QM may retain Candidates Information submitted to it even after the applied position has been filled or closed. This is done so we could re-consider Candidates for other positions and opportunities at the Company; so we could use their Candidates Information as reference for future applications submitted by them; and in case the Candidate is hired, for additional employment and business purposes related to their work. If you previously submitted your Candidates Information to the Company, and now wish to access it, update it or have it deleted from our systems, please contact us at: info@quantum-machines.co 12. YOUR RIGHTS : You may choose to stop receiving our newsletter or marketing materials by following the unsubscribe instructions included in these emails or by emailing us at: info@quantum-machines.co.   You can manage your preferences related to our use of cookies and similar technologies, please see our {ref}<code>Cookie Policy &lt;cookie_policy&gt;</code> for instructions.   If the law applicable to you grants you such rights, you may ask to access, correct, or delete your Personal data that is stored in our systems. You may also ask for our confirmation as to whether or not we process your Personal data. You may also request that we suspend the use of any Personal data whose accuracy you contest while we verify the status of that data.   Subject to the limitations in law, you may also be entitled to obtain the Personal data you directly provided us (excluding data we obtained from other sources) in a structured, commonly used, and machine-readable format and may have the right to transmit such data to another party.   If you wish to exercise any of these rights, contact us at: info@quantum-machines.co.   When handling these requests we may ask for additional information to confirm your identity and your request. Please note, upon request to delete your Personal data, we may retain such data in whole or in part to comply with any applicable rule or regulation and/or response or defend against legal proceedings versus us or our affiliates.   To find out whether these rights apply to you and on any other privacy related matter, you can contact your local data protection authority if you have concerns regarding your rights under local law. 13. UPDATES TO THIS PRIVACY POLICY : We reserve the right to change this policy at any time, so please re-visit this page frequently. We will notify you regarding substantial changes of this Privacy Policy by changing the link to the Privacy Policy in the Website. Such substantial changes will take effect seven (7) days after such notice was provided on our Website. Otherwise, all other changes to this Privacy Policy are effective as of the stated \u201cLast Revised\u201d date and your continued use of the Website after the Last Revised date will constitute acceptance of, and agreement to be bound by, those changes. 14. GENERAL INFORMATION : This Privacy Policy, its interpretation, and any claims and disputes related hereto, shall be governed by the laws of the State of Israel, without respect to its criminal law principles. Any and all such claims and disputes shall be brought in, and you hereby consent to them being litigated in and decided exclusively by a court of competent jurisdiction located in Tel Aviv, Israel.   This Privacy Policy was written in English, and may be translated into other languages for your convenience. If a translated (non-English) version of this Privacy Policy conflicts in any way with the English version, the provisions of the English version shall prevail. 15. HAVE ANY QUESTIONS? : If you have any questions (or comments) concerning this Privacy Policy, you are welcome to send us an email at: info@quantum-machines.co and we will make an effort to reply within a reasonable timeframe.</p> </li> </ol>"},{"location":"qm-qua-sdk/docs/legal/terms_of_use/","title":"Terms of Use","text":"<p>Q.M Technologies Ltd., its affiliates and its existing subsidiaries (if any) (\u201cQM\", \"we\", \"our\", \"Company\") welcomes you (the \"User(s)\", or \"you\") to our solution documentation website, at: https://qm-docs.qualang.io/index.html (the \u201cWebsite\u201d). Our Website offers technical information the compiler above. Each of the Website\u2019s Users may use the Website in accordance with the terms and conditions hereunder.</p> <ol> <li>Acceptance of the Terms     : By entering to, connecting to, accessing or using the Website,       you acknowledge that you have read and understood the following Terms of Use (the \u201cTerms of Use\u201d),       including the terms of our {ref}<code>Privacy Policy &lt;privacy_policy&gt;</code> (the \u201cPrivacy Policy\u201d,       collectively with the Terms of Use, the \"Terms\")       and you agree to be bound by them and to comply with all applicable laws and regulations       regarding your use of the Website and you acknowledge that these Terms constitute a binding and enforceable       legal contract between QM and you. IF YOU DO NOT AGREE TO THESE TERMS, PLEASE DO NOT ENTER TO, CONNECT TO,       ACCESS OR USE THE WEBSITE IN ANY MANNER.</li> <li>The Services     : The Website includes informative pages on our product and our Company.       In addition, there are forms the Users may fill in, which include:       (i) \u201cContact Us\u201d - enabling Users to ask questions and receive assistance from our support department;       and (ii) \u201cJoin Us\u201d - enabling Users to submit a candidacy to one of our open positions.       To learn more about the information you provide us when filling in one or more of the forms,       please visit our {ref}<code>Privacy Policy &lt;privacy_policy&gt;</code>.       The information is provided voluntarily by the Users and is used solely for marketing or recruitment purposes.</li> <li> <p>Use Restrictions     : There are certain conducts which are strictly prohibited on the Website.       Please read the following restrictions carefully.       Your failure to comply with the provisions set forth may, at QM\u2019s sole discretion,       result herein in the termination of your access to the Website and may also expose you to       civil and/or criminal liability.</p> <p>You may not, whether by yourself or anyone on your behalf:   (i) copy, scrape, modify, create derivative works of, adapt, emulate, translate, reverse engineer, compile,   decompile or disassemble any portion of the content on the Website and any other information, documents,   material and data available on the Website (collectively, the \u201cContent\u201d) in any way, or publicly display,   perform, or distribute the Content, without QM\u2019s prior written consent;   (ii) make any use of the Content on any other website or networked computer environment for any purpose,   or replicate or copy the Content without QM\u2019s prior written consent;   (iii) create a browser or border environment around the Website and/or Content, link, including in-line linking,   to elements on the Website, such as images, posters and videos, and/or frame or mirror any part of the Website,   unless as expressly permitted hereunder;   (iv) transmit, distribute, display or otherwise make available through or in connection   with the Website any content, which may infringe third party rights,   including Intellectual Property rights and privacy rights, or which may contain any unlawful content;   (v) transmit or otherwise make available in connection with the Website,   and/or use the Website to distribute and/or otherwise transmit any virus, worm, Trojan Horse, time bomb,   web bug, spyware, or any other computer code, file, or program that may or is intended to damage or hijack   the operation of any hardware, software, or telecommunications equipment, or any other actually or potentially   harmful, disruptive, or invasive code or component;   (vi) interfere with or disrupt the operation of the Website, or the servers or networks that host the   Website or make the Website available, or disobey any requirements, procedures, policies,   or regulations of such servers or networks; (vii) use the Content and/or the Website for any illegal,   immoral or unauthorized purpose;. 04. Privacy Policy : We respect the privacy of our Users and are committed to protecting the information you share with us   in connection with the Website.   Our policy and practices and the type of information collected are described in our   {ref}<code>Privacy Policy &lt;privacy_policy&gt;</code>.   If you intend to connect to, access or use the Website you must first read and agree to the Privacy Policy. 05. License : The Company is granting you with a limited, personal, not exclusive, non-assignable, not-tradeable,   non-sub-licensable, fully and immediately revocable at Company\u2019s discretion, license,   to use the Website and any Content made available for download, and downloaded by you from the Website   (the \u201cMaterials\u201d), all subject to the terms and conditions in this agreement.   These Terms do not entitle you with any right in the Website or in the Content or Materials,   rather than a limited right to use it in accordance herewith.</p> <p>The Materials are made available to you subject to the terms of Sections 3 above,   for your own personal limited use and without derogating from the restrictions set forth under these   Terms and in addition thereto you may not:   (a) distribute the Materials or any part thereof, directly or indirectly;   (b) make or allow any third party to make any commercial use of the Materials; and   (c) modify, add, subtract, aggregate or otherwise make any derivative work of the Materials   or allow a third party to do so.</p> <p>You hereby agree that upon Company\u2019s request you will immediately return all Materials,   purge your systems from any Materials and ensure that no copies,   extracts or other reproductions are retained by you. 06. Feedback : In the event that you provide QM with any suggestions, comments or other feedback relating to Website   and/or QM products and/or services (collectively, \u201cFeedback\u201d), such Feedback is deemed as   the sole and exclusive property of QM and you hereby irrevocably assign to QM all of its rights,   title and interest in and to all Feedback, if any, and waives any moral rights to it   (or anyone on its behalf) may have in such Feedback.   Without derogating from the foregoing, you hereby represent and warrant that   you shall not provide any Feedback which is subject to any third-party rights or any limitations,   and, without derogating from the foregoing, shall promptly inform QM as soon as it becomes aware of   any third party right or limitation which may apply to Feedback already provided. 07. Intellectual Property Rights : \u201cIntellectual Property\u201d means proprietary and intellectual property rights, including the Website,   its logos, graphics, icons, images, as well as the selection, assembly and arrangement thereof,   QM\u2019s proprietary software, algorithms and any and all intellectual property rights pertaining thereto, including,   without limitation, inventions, patents and patent applications, trademarks, trade names, logos,   copyrightable materials, graphics, text, images, designs   (including the \u201clook and feel\u201d of the Website and any part thereof),   specifications, methods, procedures, information, know-how, data, technical data, interactive features,   source and object code, files, interface and trade secrets, whether or not registered   and/or capable of being registered, and any and all Feedback.</p> <p>The Intellectual Property is owned and/or licensed to QM and is subject to copyright and other applicable   intellectual property rights under Israeli laws, foreign laws and international conventions.   You may not copy, distribute, display, execute publicly, make available to the public, emulate,   reduce to human readable form, decompile, disassemble, adapt, sublicense, make any commercial use, sell, rent,   lend, process, compile, reverse engineer, combine with other software, translate, modify   or create derivative works of any material that is subject to QM\u2019s proprietary rights,   including QM\u2019s Intellectual Property, either by yourself or by anyone on your behalf,   in any way or by any means, unless expressly permitted in the Terms.</p> <p>\u201cQM\u201d, \u201cQuantum Machines\u201d and all logos and other proprietary identifiers used by QM in connection   with the Website, (\u201cQM Trademarks\u201d) are all trademarks and/or trade names of QM,   whether or not registered.   All other trademarks, Website marks, trade names and logos which may appear on or with respect to the   Website belong to their respective owners (\u201cThird Party Marks\u201d). No right, license, or interest to   QM Trademarks and/or to the Third Party Marks is granted hereunder, and you agree that no such right,   license, or interest shall be asserted by you with respect to QM Trademarks or the Third Party Marks   and therefore you will avoid using any of those marks, unless expressly permitted herein.</p> <p>You are hereby prohibited from removing or deleting any and all copyright notices,   restrictions and signs indicating proprietary rights of QM and/or its licensors, including copyright mark [\u00a9]   or trademark [\u00ae or \u2122] contained in or accompanying the Website,   and you represent and warrant that you will abide by all applicable laws in this respect.   You are further prohibited from using, diluting or staining any name, mark or logo that is identical,   or confusingly similar to any of QM marks and logos, whether registered or not. 08. Third Party Components : The Website may use or include third party software, files and components that are subject to open source   and third party license terms (\u201cThird Party Components\u201d).   Your right to use such Third Party Components as part of, or in connection with,   the Website is subject to any applicable acknowledgements and license terms accompanying such   Third Party Components, contained therein or related thereto.   If there is a conflict between the licensing terms of such Third Party Components and these Terms,   the licensing terms of the Third Party Components shall prevail   only in connection with the related Third Party Components.   These Terms do not apply to any Third Party Components accompanying or contained in the Website   and QM disclaims all liability related thereto. You acknowledge that QM is not the author,   owner or licensor of any Third Party Components, and that QM makes no warranties or representations,   express or implied, as to the quality, capabilities, operations, performance   or suitability of Third Party Components.   Under no circumstances shall the Website or any portion thereof   (except for the Third Party Components contained therein) be deemed to be \u201copen source\u201d   or \u201cpublicly available\u201d software. 09. Availability : The Website\u2019s availability and functionality depend on various factors, such as communication networks,   software, hardware, and QM\u2019s Website providers and contractors.   QM does not warrant or guarantee that the Website will operate and/or be available at all times without disruption   or interruption, or that it will be immune from unauthorized access error-free 10. Changes to the Website : QM reserves the right, at its sole discretion, to modify, correct, amend, enhance, improve,   make any other changes to, or discontinue, temporarily or permanently, the Website (or any part thereof)   without notice, at any time. In addition, you hereby acknowledge that the Content available through   the Website may be changed, modified, edited or extended in terms of content and form or removed at any time   without any notice to you. You agree that QM shall not be liable to you or to any third party for any modification,   suspension, error, malfunction or discontinuance of the Website (or any part thereof). 11. Disclaimer and Warranties : QM DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE, THE INABILITY TO USE OR OPERATE,   OR THE RESULTS OF THE USE OR OPERATION OF THE WEBSITE (OR ANY PART THEREOF).</p> <p>QM SHALL NOT BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING, BUT NOT LIMITED TO, DIRECT, INDIRECT, SPECIAL,   INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,   WHETHER IT WAS CAUSED CONSEQUENTLY OR IN CONNECTION WITH THE USE OF THE WEBSITE,   WHETHER OR NOT THE COMPANY HAD INFORMED THE USER OF SUCH POSSIBLE DAMAGE.</p> <p>THE WEBSITE (AND ANY PART THEREOF), INCLUDING WITHOUT LIMITATION ANY CONTENT, DATA AND INFORMATION RELATED THERETO,   ARE PROVIDED ON AN \u201cAS IS\u201d AND \u201cAS AVAILABLE\u201d BASIS, WITHOUT ANY WARRANTIES OF ANY KIND,   EXPRESS OR IMPLIED, INCLUDING WARRANTIES OF TITLE OR NON-INFRINGEMENT OR IMPLIED WARRANTIES OF USE,   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE OR USE.   QM DISCLAIMS AND MAKES NO REPRESENTATIONS OR WARRANTIES AS TO THE ACCURACY, QUALITY, AVAILABILITY, RELIABILITY,   SUITABILITY, COMPLETENESS, TRUTHFULNESS, USEFULNESS, OR EFFECTIVENESS OF ANY CONTENT AVAILABLE ON OUR SERVICES.</p> <p>QM AND ITS AFFILIATES AND/OR ITS SUBSIDIARIES, INCLUDING ANY OF THEIR RESPECTIVE OFFICERS, DIRECTORS, SHAREHOLDERS,   EMPLOYEES, SUB-CONTRACTORS, AGENTS, PARENT COMPANIES, SUBSIDIARIES AND OTHER AFFILIATES   (COLLECTIVELY, \u201cQM AFFILIATES\u201d), JOINTLY AND SEVERALLY, DISCLAIM AND MAKE NO REPRESENTATIONS OR WARRANTIES   AS TO THE USABILITY, ACCURACY, QUALITY, AVAILABILITY, RELIABILITY, SUITABILITY, COMPLETENESS, TRUTHFULNESS,   USEFULNESS, OR EFFECTIVENESS OF ANY CONTENT, DATA, RESULTS, OR OTHER INFORMATION OBTAINED OR GENERATED   IN CONNECTION WITH YOUR OR ANY USER\u2019S USE OF THE WEBSITE.</p> <p>QM DOES NOT WARRANT THAT THE OPERATION OF THE WEBSITE IS OR WILL BE SECURE, ACCURATE, COMPLETE, UNINTERRUPTED,   WITHOUT ERROR, OR FREE OF VIRUSES, WORMS, OTHER HARMFUL COMPONENTS, OR OTHER PROGRAM LIMITATIONS.   QM MAY, AT ITS SOLE DISCRETION AND WITHOUT AN OBLIGATION TO DO SO, CORRECT, MODIFY, AMEND, ENHANCE,   IMPROVE AND MAKE ANY OTHER CHANGES TO THE WEBSITE AT ANY TIME, OR DISCONTINUE DISPLAYING OR PROVIDING   ANY CONTENT OR FEATURES WITHOUT ANY NOTICE TO YOU.</p> <p>YOU AGREE AND ACKNOWLEDGE THAT THE USE OF THE WEBSITE, INCLUDING USE OF AND/OR RELIANCE ON ANY CONTENT AVAILABLE   THROUGH THE WEBSITE, IS ENTIRELY, OR OTHERWISE TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, AT YOUR OWN RISK. 12. Limitation of Liability : IN NO EVENT SHALL QM AND/OR ANY OF THE QM AFFILIATES AND/OR SUBSIDIARIES BE LIABLE FOR ANY DAMAGES WHATSOEVER,   INCLUDING DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,   RESULTING FROM OR ARISING OUT OF THE WEBSITE, USE OR INABILITY TO USE THE WEBSITE,   FAILURE OF THE WEBSITE TO PERFORM AS REPRESENTED OR EXPECTED, LOSS OF GOODWILL, DATA OR PROFITS,   THE PERFORMANCE OR FAILURE OF QM TO PERFORM UNDER THESE TERMS, AND ANY OTHER ACT OR OMISSION OF QM   BY ANY OTHER CAUSE WHATSOEVER, INCLUDING WITHOUT LIMITATION DAMAGES ARISING FROM THE CONDUCT OF ANY   USERS AND/OR THIRD PARTY SITES.</p> <p>NO ACTION MAY BE BROUGHT BY YOU FOR ANY BREACH OF THESE TERMS MORE THAN ONE (1) YEAR AFTER THE ACCRUAL   OF SUCH CAUSE OF ACTION. AS SOME STATES DO NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL   OR CONSEQUENTIAL DAMAGES, THEN SUCH LIMITATIONS ONLY MAY NOT APPLY TO A USER RESIDING IN SUCH STATES.</p> <p>SUCH LIMITATIONS, EXCLUSIONS AND DISCLAIMERS SHALL APPLY TO ALL CLAIMS FOR DAMAGES,   WHETHER BASED IN AN ACTION OF CONTRACT, WARRANTY, STRICT LIABILITY, NEGLIGENCE, TORT, OR OTHERWISE.   YOU HEREBY ACKNOWLEDGE AND AGREE THAT THESE LIMITATIONS OF LIABILITY ARE AGREED ALLOCATIONS OF   RISK CONSTITUTING IN PART THE CONSIDERATION FOR QM\u2019S WEBSITE TO YOU,   AND SUCH LIMITATIONS WILL APPLY NOTWITHSTANDING THE FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY,   AND EVEN IF QM AND/OR ANY QM AFFILIATES HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH LIABILITIES AND/OR DAMAGES.   THE FOREGOING LIMITATION OF LIABILITY SHALL APPLY TO THE FULLEST EXTENT PERMITTED BY LAW IN THE APPLICABLE   JURISDICTION AND IN NO EVENT SHALL QM\u2019S CUMULATIVE LIABILITY TO YOU EXCEED AMOUNTS PAID BY YOU TO QM   FOR USE OF THE WEBSITE. IF YOU HAVE NOT MADE ANY PAYMENTS TO QM FOR THE USE OF THE WEBSITE,   THEN QM SHALL NOT HAVE ANY LIABILITY TOWARDS YOU. 13. Indemnification : You agree to defend, indemnify and hold harmless QM and any QM Affiliates from and against any and all claims,   damages, obligations, losses, liabilities, costs, debts, fines, late fees, cancellation fees and expenses   (including attorney's fees) arising directly or indirectly from:   (i) your use of the Website (or any part thereof);   (ii) breach of any term of these Terms by you or anyone on your behalf;   (iii) any damage of any sort, whether direct, indirect, special or consequential,   you may cause to any third party which relates to your use  of (or inability to use) the Website;   (iv) your violation of the Privacy Policy, any third party intellectual property rights,   privacy rights or other rights through your use of the Website or provision of information; and   (v) your violation of any applicable law or regulation. 14. Amendments to the Terms : QM may change the Terms from time to time, at its sole discretion and without any notice.   We will notify regarding substantial changes of these Terms on the homepage of the Website   and/or we will send you an e-mail regarding such changes to the e-mail address that you   provided in the contact form.   Such substantial changes will take effect seven (7) days after such notice was provided on our Website   or sent via email. Otherwise, all other changes to these Terms are effective as of the stated \u201cLast Revised\u201d   date and your continued use of the Website after the Last Revised date will constitute acceptance of,   and agreement to be bound by, those changes. 15. Minors : To enjoy the Website you must be over the age of sixteen (16).   We reserve the right to request proof of age at any stage so that we can verify that minors under the age of   sixteen (16) are not using the Website.   In the event that it comes to our knowledge that a person under the age of sixteen (16) is using the Site,   we will prohibit and block such User from accessing the Website and will make all efforts to promptly delete   any Personal Information. 16. General : These Terms do not, and shall not be construed to create any partnership, joint venture, employer-employee,   agency, or franchisor-franchisee relationship between the parties hereto.   Any claim relating to this Website or use of this Website will be governed by and interpreted in accordance   with the laws of the State of Israel, without reference to its conflict-of-laws principles.   Any dispute arising out of or related to your use of this Website will be brought in,   and you hereby consent to exclusive jurisdiction and venue in, the competent courts of the District of Tel Aviv,   Israel. If any provision of these Terms is found to be unlawful, void, or for any reason unenforceable,   then that provision will be deemed severable from these Terms and will not affect the validity   and enforceability of any remaining provision. You may not assign, sublicense or otherwise transfer   any or all of your rights or obligations under these Terms without QM's prior express written consent.   No waiver by either party of any breach or default hereunder will be deemed to be a waiver of   any preceding or subsequent breach or default. Any heading, caption or section title contained herein is   inserted only as a matter of convenience, and in no way defines or explains any section or provision hereof.   These Terms are the entire terms and conditions between you and QM relating to the subject matter herein and   supersedes any and all prior or contemporaneous written or oral agreements or understandings between you and QM   or Notices to you may be made via email or regular mail.   This Website may also provide notices of changes to these Terms or other matters,   by displaying such notices or by providing links to such notices.   Without limitation, you agree that a printed version of these Terms and of any notice given in electronic form   shall be admissible in judicial or administrative proceedings based upon or relating to these Terms to the   same extent and subject to the same conditions as other business documents and records   originally generated and maintained in printed form.</p> </li> </ol>"},{"location":"solutions/","title":"Solutions","text":"<p>Bootstrap your development by (re)using tools and examples.</p> <ul> <li> <p> QUA Tools</p> <p>Install <code>pip install --upgrade qualang-tools</code> and use many helpful tools developed for working with QUA</p> <p> Explore available tools</p> </li> <li> <p> Use cases</p> <p>Get inspired with in-depth, end-to-end use cases fresh from the labs around the world</p> <p> Explore use cases</p> </li> </ul>"}]}